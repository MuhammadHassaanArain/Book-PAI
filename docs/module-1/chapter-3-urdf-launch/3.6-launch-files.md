# ROS 2 Launch Systems and Python Launch Files

## Learning Objectives

- Understand the ROS 2 launch system architecture and its components
- Create Python launch files for complex humanoid robot systems
- Implement proper launch file organization for multi-node systems
- Recognize the importance of launch systems in robot deployment
- Design robust launch configurations for safety-critical humanoid operations

## Conceptual Explanation

The ROS 2 launch system provides a powerful framework for starting and managing multiple nodes simultaneously, along with their parameters, remappings, and other configuration details. Unlike ROS 1, which used XML-based launch files, ROS 2 uses Python-based launch files that offer greater flexibility and programmability.

The launch system consists of several key components:
- **Launch files**: Python scripts that define what nodes and processes to start
- **Launch descriptions**: Data structures that describe the processes to launch
- **Launch actions**: Individual operations that can be performed during launch
- **Launch conditions**: Mechanisms to conditionally execute actions
- **Launch parameters**: Configuration values that can be passed to nodes

Launch files in ROS 2 are Python scripts that use the launch library to define what nodes should be started. This allows for complex logic, parameter manipulation, and conditional launching that wasn't possible with ROS 1's XML-based system.

The launch system provides several advantages over manual node startup:
- **Consistency**: Ensures nodes are always started with the same parameters
- **Convenience**: Single command starts entire robot system
- **Coordination**: Manages node lifecycles and dependencies
- **Flexibility**: Supports conditional launching and parameter overrides
- **Monitoring**: Provides feedback on node status and health

Launch descriptions are composed of launch actions, which can include:
- **Node actions**: Starting executable nodes
- **Include launch descriptions**: Composing multiple launch files
- **Timer actions**: Delayed execution of other actions
- **Conditional actions**: Executing actions based on conditions
- **Log actions**: Writing messages to the launch log

Parameters in launch files can be defined at multiple levels:
- **Global parameters**: Applied to all nodes in the launch
- **Node-specific parameters**: Applied only to specific nodes
- **Command-line parameters**: Passed from the command line at launch time

Remapping in launch files allows changing the names of topics, services, and parameters at launch time, which is particularly useful for running multiple instances of the same node or for adapting to different robot configurations.

For safety-critical humanoid applications, the launch system provides mechanisms to ensure that safety-related nodes are started properly and that the entire system is brought up in a controlled manner.

## Humanoid Robotics Context

For humanoid robotics, the launch system is particularly important due to the complexity of humanoid robot systems, which typically consist of dozens of nodes that must be coordinated properly. Humanoid robots require simultaneous launching of multiple subsystems including perception, control, planning, and safety systems.

**Sensor integration launch** requires starting multiple sensor drivers simultaneously, each with appropriate parameters for calibration and configuration. The launch system ensures that all sensors are properly initialized before other nodes that depend on sensor data begin operation.

**Control system orchestration** involves launching multiple control nodes with coordinated parameters and proper initialization order. The launch system can ensure that controllers are started in the correct sequence, with appropriate delays between nodes that depend on each other.

**Safety system initialization** is critical for humanoid robots operating near humans. The launch system can ensure that safety monitoring nodes are started first and that safety parameters are properly configured before other systems become active.

**Behavior management launching** involves starting multiple behavior nodes that coordinate to provide high-level functionality. The launch system can manage the interaction between different behavior managers and ensure proper parameter sharing.

**Simulation vs. real robot launching** requires different configurations depending on whether the system is running in simulation or on real hardware. The launch system can conditionally include different sets of nodes based on environment variables or command-line arguments.

**Multi-robot coordination** in humanoid robotics may involve launching multiple robot instances or coordinating between multiple humanoid robots. The launch system can handle namespace management and inter-robot communication setup.

The launch system also supports parameter files in YAML format, which allows for complex configuration of humanoid robot systems with hundreds of parameters that need to be properly coordinated across multiple nodes.

## Practical ROS 2 Example (Python)

Let's create examples demonstrating launch file creation for humanoid robotics:

First, let's create a basic launch file for a humanoid robot:

```python
# humanoid_robot.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, TimerAction
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node, SetParameter
from launch_ros.substitutions import FindPackageShare
from ament_index_python.packages import get_package_share_directory
import os


def generate_launch_description():
    """
    Launch file for a complete humanoid robot system.
    This demonstrates how to create a comprehensive launch file
    for a humanoid robot with multiple subsystems.
    """

    # Declare launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='false')
    robot_namespace = LaunchConfiguration('robot_namespace', default='')
    launch_rviz = LaunchConfiguration('launch_rviz', default='true')
    robot_model_file = LaunchConfiguration('robot_model_file', default='humanoid.urdf.xacro')

    # Declare launch arguments
    declare_use_sim_time_arg = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation (Gazebo) clock if true'
    )

    declare_robot_namespace_arg = DeclareLaunchArgument(
        'robot_namespace',
        default_value='',
        description='Robot namespace for ROS nodes'
    )

    declare_launch_rviz_arg = DeclareLaunchArgument(
        'launch_rviz',
        default_value='true',
        description='Launch RViz for robot visualization'
    )

    declare_robot_model_file_arg = DeclareLaunchArgument(
        'robot_model_file',
        default_value='humanoid.urdf.xacro',
        description='URDF/XACRO file to use for the robot model'
    )

    # Set global parameters
    set_use_sim_time = SetParameter(name='use_sim_time', value=use_sim_time)

    # Get package directories
    robot_description_pkg = get_package_share_directory('humanoid_robot_description')
    robot_bringup_pkg = get_package_share_directory('humanoid_robot_bringup')

    # Robot state publisher node
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'robot_description': PathJoinSubstitution([
                FindPackageShare('humanoid_robot_description'),
                'urdf',
                robot_model_file
            ])}
        ],
        remappings=[
            ('/tf', 'tf'),
            ('/tf_static', 'tf_static'),
        ]
    )

    # Joint state publisher (for simulation or when no real joint states available)
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'rate': 50}  # 50 Hz update rate
        ],
        condition=IfCondition(LaunchConfiguration('use_fake_hardware'))
    )

    # Joint state publisher GUI (for manual testing)
    joint_state_publisher_gui = Node(
        package='joint_state_publisher_gui',
        executable='joint_state_publisher_gui',
        name='joint_state_publisher_gui',
        namespace=robot_namespace,
        condition=IfCondition(LaunchConfiguration('use_gui'))
    )

    # Main control nodes
    balance_controller = Node(
        package='humanoid_control',
        executable='balance_controller',
        name='balance_controller',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'control_frequency': 200},  # 200 Hz control loop
            {'stability_threshold': 0.1},  # Stability threshold in radians
        ],
        remappings=[
            ('/joint_states', 'joint_states'),
            ('/cmd_vel', 'cmd_vel'),
        ]
    )

    walking_controller = Node(
        package='humanoid_control',
        executable='walking_controller',
        name='walking_controller',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'step_height': 0.05},  # 5cm step height
            {'step_duration': 1.0},  # 1 second per step
            {'stance_width': 0.2},   # 20cm stance width
        ]
    )

    # Perception nodes
    imu_processor = Node(
        package='humanoid_perception',
        executable='imu_processor',
        name='imu_processor',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'filter_frequency': 100},  # 100 Hz filter
            {'calibration_file': PathJoinSubstitution([
                FindPackageShare('humanoid_perception'),
                'config',
                'imu_calibration.yaml'
            ])}
        ]
    )

    vision_processor = Node(
        package='humanoid_perception',
        executable='vision_processor',
        name='vision_processor',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'detection_frequency': 30},  # 30 Hz detection
            {'enable_tracking': True},
        ]
    )

    # Safety monitoring nodes
    safety_monitor = Node(
        package='humanoid_safety',
        executable='safety_monitor',
        name='safety_monitor',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'emergency_stop_timeout': 0.5},  # 500ms timeout
            {'safety_boundary_radius': 2.0},  # 2m safety radius
        ]
    )

    collision_detector = Node(
        package='humanoid_safety',
        executable='collision_detector',
        name='collision_detector',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'detection_frequency': 100},  # 100 Hz collision checking
            {'collision_buffer': 0.1},     # 10cm buffer zone
        ]
    )

    # RViz2 for visualization
    rviz_config_file = PathJoinSubstitution([
        FindPackageShare('humanoid_bringup'),
        'rviz',
        'humanoid_robot.rviz'
    ])

    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', rviz_config_file],
        condition=IfCondition(launch_rviz)
    )

    # Create launch description
    ld = LaunchDescription()

    # Add launch arguments
    ld.add_action(declare_use_sim_time_arg)
    ld.add_action(declare_robot_namespace_arg)
    ld.add_action(declare_launch_rviz_arg)
    ld.add_action(declare_robot_model_file_arg)

    # Add global parameter setting
    ld.add_action(set_use_sim_time)

    # Add nodes
    ld.add_action(robot_state_publisher)
    ld.add_action(joint_state_publisher)
    ld.add_action(joint_state_publisher_gui)
    ld.add_action(balance_controller)
    ld.add_action(walking_controller)
    ld.add_action(imu_processor)
    ld.add_action(vision_processor)
    ld.add_action(safety_monitor)
    ld.add_action(collision_detector)
    ld.add_action(rviz_node)

    return ld
```

Now let's create a more specialized launch file for safety-critical operations:

```python
# humanoid_safety_critical.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, RegisterEventHandler
from launch.event_handlers import OnProcessStart, OnProcessExit
from launch.events import Shutdown
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node, LifecycleNode
from launch_ros.substitutions import FindPackageShare
from ament_index_python.packages import get_package_share_directory
import os


def generate_launch_description():
    """
    Launch file for safety-critical humanoid robot operations.
    This demonstrates how to create a launch file with proper
    safety monitoring and emergency handling.
    """

    # Launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='false')
    robot_namespace = LaunchConfiguration('robot_namespace', default='humanoid')
    emergency_stop_topic = LaunchConfiguration('emergency_stop_topic', default='/emergency_stop')

    # Declare launch arguments
    declare_use_sim_time_arg = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation (Gazebo) clock if true'
    )

    declare_robot_namespace_arg = DeclareLaunchArgument(
        'robot_namespace',
        default_value='humanoid',
        description='Robot namespace for safety-critical operations'
    )

    declare_emergency_stop_topic_arg = DeclareLaunchArgument(
        'emergency_stop_topic',
        default_value='/emergency_stop',
        description='Topic for emergency stop commands'
    )

    # Safety supervisor node (highest priority)
    safety_supervisor = Node(
        package='humanoid_safety',
        executable='safety_supervisor',
        name='safety_supervisor',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'monitoring_frequency': 200},  # 200 Hz monitoring
            {'emergency_stop_timeout': 0.1},  # 100ms timeout
            {'critical_nodes': [
                'balance_controller',
                'walking_controller',
                'joint_trajectory_controller'
            ]},
        ],
        respawn=True,
        respawn_delay=2
    )

    # Critical controller nodes
    balance_controller = LifecycleNode(
        package='humanoid_control',
        executable='balance_controller',
        name='balance_controller',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'control_frequency': 500},  # Higher frequency for safety
            {'stability_threshold': 0.05},  # Tighter stability requirements
            {'max_tilt': 0.3},  # Maximum allowable tilt
        ],
        respawn=True
    )

    joint_trajectory_controller = LifecycleNode(
        package='controller_manager',
        executable='ros2_control_node',
        name='ros2_control_node',
        namespace=robot_namespace,
        parameters=[
            PathJoinSubstitution([
                FindPackageShare('humanoid_control'),
                'config',
                'controllers.yaml'
            ]),
            {'use_sim_time': use_sim_time}
        ],
        respawn=True
    )

    # Emergency stop handler
    emergency_handler = Node(
        package='humanoid_safety',
        executable='emergency_handler',
        name='emergency_handler',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'stop_topic': emergency_stop_topic},
            {'shutdown_sequence_duration': 0.5},  # 500ms shutdown sequence
        ],
        remappings=[
            (emergency_stop_topic, 'emergency_stop'),
        ]
    )

    # Humanoid-specific safety monitors
    com_monitor = Node(
        package='humanoid_safety',
        executable='center_of_mass_monitor',
        name='center_of_mass_monitor',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'com_threshold': 0.15},  # 15cm threshold from support polygon
            {'sampling_frequency': 100},  # 100 Hz sampling
        ]
    )

    # Add event handlers for safety monitoring
    # Trigger safety checks when critical nodes start/stop
    on_balance_controller_start = RegisterEventHandler(
        OnProcessStart(
            target_action=balance_controller,
            on_start=[
                # Additional safety checks when balance controller starts
            ]
        )
    )

    on_balance_controller_exit = RegisterEventHandler(
        OnProcessExit(
            target_action=balance_controller,
            on_exit=[
                # Trigger emergency stop if balance controller exits unexpectedly
                emergency_handler
            ]
        )
    )

    # Create launch description
    ld = LaunchDescription()

    # Add launch arguments
    ld.add_action(declare_use_sim_time_arg)
    ld.add_action(declare_robot_namespace_arg)
    ld.add_action(declare_emergency_stop_topic_arg)

    # Add safety-critical nodes
    ld.add_action(safety_supervisor)
    ld.add_action(balance_controller)
    ld.add_action(joint_trajectory_controller)
    ld.add_action(emergency_handler)
    ld.add_action(com_monitor)

    # Add event handlers
    ld.add_action(on_balance_controller_start)
    ld.add_action(on_balance_controller_exit)

    return ld
```

Now let's create a launch file for simulation:

```python
# humanoid_simulation.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, ExecuteProcess
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from ament_index_python.packages import get_package_share_directory
import os


def generate_launch_description():
    """
    Launch file for humanoid robot simulation in Gazebo.
    This demonstrates how to integrate simulation with the launch system.
    """

    # Launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time', default='true')
    robot_namespace = LaunchConfiguration('robot_namespace', default='humanoid')
    world = LaunchConfiguration('world', default='empty.sdf')
    headless = LaunchConfiguration('headless', default='false')

    # Declare launch arguments
    declare_use_sim_time_arg = DeclareLaunchArgument(
        'use_sim_time',
        default_value='true',
        description='Use simulation (Gazebo) clock if true'
    )

    declare_robot_namespace_arg = DeclareLaunchArgument(
        'robot_namespace',
        default_value='humanoid',
        description='Robot namespace for simulation'
    )

    declare_world_arg = DeclareLaunchArgument(
        'world',
        default_value='empty.sdf',
        description='Choose one of the world files from `/gazebo_worlds`'
    )

    declare_headless_arg = DeclareLaunchArgument(
        'headless',
        default_value='false',
        description='Run Gazebo without GUI'
    )

    # Get package directories
    gazebo_pkg = get_package_share_directory('gazebo_ros')
    robot_gazebo_pkg = get_package_share_directory('humanoid_gazebo')

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(gazebo_pkg, 'launch', 'gazebo.launch.py')
        ),
        launch_arguments={
            'world': PathJoinSubstitution([
                FindPackageShare('humanoid_gazebo'),
                'worlds',
                world
            ]),
            'gui': LaunchConfiguration('headless'),
            'verbose': 'false',
        }.items()
    )

    # Robot state publisher with simulation time
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'robot_description': PathJoinSubstitution([
                FindPackageShare('humanoid_description'),
                'urdf',
                'humanoid.urdf.xacro'
            ])}
        ]
    )

    # Spawn robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', PathJoinSubstitution([robot_namespace, 'robot_description']),
            '-entity', 'humanoid_robot',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '1.0',
            '-robot_namespace', robot_namespace
        ],
        output='screen'
    )

    # Controllers for simulation
    joint_state_broadcaster_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['joint_state_broadcaster'],
        parameters=[{'use_sim_time': use_sim_time}],
        namespace=robot_namespace
    )

    robot_controller_spawner = Node(
        package='controller_manager',
        executable='spawner',
        arguments=['forward_position_controller'],
        parameters=[{'use_sim_time': use_sim_time}],
        namespace=robot_namespace
    )

    # Simulation-specific nodes
    gazebo_odometry = Node(
        package='humanoid_gazebo',
        executable='gazebo_odometry_publisher',
        name='gazebo_odometry_publisher',
        namespace=robot_namespace,
        parameters=[
            {'use_sim_time': use_sim_time},
            {'publish_frequency': 50},
        ]
    )

    # Create launch description
    ld = LaunchDescription()

    # Add launch arguments
    ld.add_action(declare_use_sim_time_arg)
    ld.add_action(declare_robot_namespace_arg)
    ld.add_action(declare_world_arg)
    ld.add_action(declare_headless_arg)

    # Add simulation components
    ld.add_action(gazebo)
    ld.add_action(robot_state_publisher)
    ld.add_action(spawn_entity)
    ld.add_action(joint_state_broadcaster_spawner)
    ld.add_action(robot_controller_spawner)
    ld.add_action(gazebo_odometry)

    return ld
```

Now let's create a Python script that demonstrates launch file validation:

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Bool
from launch import LaunchService
from launch.actions import RegisterEventHandler
from launch.event_handlers import OnProcessStart, OnProcessExit
from launch.events import Shutdown
import subprocess
import sys
import yaml
from pathlib import Path


class LaunchValidator(Node):
    """
    A node that demonstrates validation of launch configurations
    for humanoid robot systems.
    """

    def __init__(self):
        super().__init__('launch_validator')

        # Publisher for validation results
        self.validation_result_publisher = self.create_publisher(
            String, 'launch_validation_results', 10)

        # Timer for validation checks
        self.validation_timer = self.create_timer(1.0, self.validate_launch_configs)

        # Store validation results
        self.validation_results = {}

        # Launch configuration files to validate
        self.launch_configs = [
            'humanoid_robot.launch.py',
            'humanoid_safety_critical.launch.py',
            'humanoid_simulation.launch.py'
        ]

        self.get_logger().info('Launch Validator initialized')

    def validate_launch_configs(self):
        """Validate launch configuration files"""
        self.get_logger().info('Validating launch configuration files...')

        for config_file in self.launch_configs:
            self.validate_single_launch_config(config_file)

    def validate_single_launch_config(self, config_file):
        """Validate a single launch configuration file"""
        self.get_logger().info(f'Validating launch config: {config_file}')

        # Check if file exists
        if not Path(config_file).exists():
            self.get_logger().error(f'Launch config file does not exist: {config_file}')
            self.validation_results[config_file] = False
            return

        try:
            # Validate Python syntax
            with open(config_file, 'r') as f:
                content = f.read()

            # Compile to check for Python syntax errors
            compile(content, config_file, 'exec')

            # Check for required imports
            required_imports = [
                'from launch import LaunchDescription',
                'from launch_ros.actions import Node'
            ]

            missing_imports = []
            for req_imp in required_imports:
                if req_imp not in content:
                    missing_imports.append(req_imp)

            if missing_imports:
                self.get_logger().warn(f'Missing imports in {config_file}: {missing_imports}')
                # This might not be critical depending on the specific launch file

            # Check for generate_launch_description function
            if 'def generate_launch_description()' not in content:
                self.get_logger().error(f'No generate_launch_description function in {config_file}')
                self.validation_results[config_file] = False
                return

            # Check for proper return statement
            if 'return ld' not in content and 'return LaunchDescription' not in content:
                self.get_logger().warn(f'No proper return statement in {config_file} (might be OK in some cases)')

            # Log validation success
            self.get_logger().info(f'Launch config validation passed: {config_file}')
            self.validation_results[config_file] = True

            # Publish validation result
            result_msg = String()
            result_msg.data = f"{config_file}: VALID"
            self.validation_result_publisher.publish(result_msg)

        except SyntaxError as e:
            self.get_logger().error(f'Syntax error in {config_file}: {e}')
            self.validation_results[config_file] = False
        except Exception as e:
            self.get_logger().error(f'Error validating {config_file}: {str(e)}')
            self.validation_results[config_file] = False

    def validate_parameters_yaml(self, yaml_file):
        """Validate parameter YAML files"""
        try:
            with open(yaml_file, 'r') as f:
                params = yaml.safe_load(f)

            # Check for proper parameter structure
            if not isinstance(params, dict):
                self.get_logger().error(f'Invalid parameter structure in {yaml_file}')
                return False

            # Validate parameter names and types
            for param_name, param_value in params.items():
                if not isinstance(param_name, str):
                    self.get_logger().warn(f'Non-string parameter name in {yaml_file}: {param_name}')

                # Validate common parameter types
                if isinstance(param_value, dict) and 'ros__parameters' in param_value:
                    # This is a node-specific parameter structure
                    node_params = param_value['ros__parameters']
                    for node_param_name, node_param_value in node_params.items():
                        self.validate_parameter_value(node_param_name, node_param_value, yaml_file)

            self.get_logger().info(f'Parameter validation passed: {yaml_file}')
            return True

        except yaml.YAMLError as e:
            self.get_logger().error(f'YAML error in {yaml_file}: {e}')
            return False
        except Exception as e:
            self.get_logger().error(f'Error validating parameters in {yaml_file}: {str(e)}')
            return False

    def validate_parameter_value(self, param_name, param_value, yaml_file):
        """Validate individual parameter values"""
        # Check for common issues with parameter values
        if param_name.endswith('_file') or param_name.endswith('_path'):
            # Validate file paths
            if isinstance(param_value, str) and not Path(param_value).exists():
                self.get_logger().warn(f'Parameter {param_name} in {yaml_file} points to non-existent file: {param_value}')


class LaunchMonitor(Node):
    """
    A node that monitors the status of launched processes
    and provides feedback on system health.
    """

    def __init__(self):
        super().__init__('launch_monitor')

        # Publisher for system status
        self.system_status_publisher = self.create_publisher(
            String, 'system_status', 10)

        # Timer for status monitoring
        self.status_timer = self.create_timer(0.5, self.monitor_system_status)

        # Track node status
        self.node_status = {}
        self.system_healthy = True

        self.get_logger().info('Launch Monitor initialized')

    def monitor_system_status(self):
        """Monitor the status of launched processes"""
        # In a real implementation, this would interface with the launch system
        # to check the status of all launched processes
        # For this example, we'll simulate the monitoring

        status_msg = String()
        status_msg.data = f"System Health: {'OK' if self.system_healthy else 'ISSUES DETECTED'}"
        self.system_status_publisher.publish(status_msg)

        self.get_logger().debug(f'System status: {status_msg.data}')


def main(args=None):
    """Main function demonstrating launch system validation"""
    rclpy.init(args=args)

    # Create validation and monitoring nodes
    validator = LaunchValidator()
    monitor = LaunchMonitor()

    # Use MultiThreadedExecutor to handle multiple nodes
    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(validator)
    executor.add_node(monitor)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up
        validator.destroy_node()
        monitor.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Architecture / Flow Explanation (Diagram-Referenced)

The ROS 2 launch system architecture can be visualized as follows:

```
[Launch File (.launch.py)] -----> [Launch Service] -----> [Process Manager]
         |                              |                        |
         |                              |                        |
         v                              v                        v
[Launch Description] -----> [Launch Actions] -----> [Node Processes]
         |                              |                        |
         |                              |                        |
         v                              v                        v
[Parameter Server] -----> [Topic Remapper] -----> [Lifecycle Manager]
         |                              |                        |
         |                              |                        |
         v                              v                        v
[System Configuration] -----> [Event Handler] -----> [Status Monitor]

[Launch Components:]
- Launch Files: Python scripts defining system startup
- Launch Actions: Individual operations (start nodes, set params, etc.)
- Launch Conditions: Conditional execution logic
- Launch Parameters: Configurable values for nodes
- Launch Events: Lifecycle events for process monitoring
```

In this architecture:
1. Launch files define the system startup configuration in Python
2. Launch descriptions specify what processes to start
3. Launch actions perform individual operations during startup
4. Process manager handles the actual process execution
5. Runtime environment provides the operational context

For humanoid robots, this architecture allows for:
- Complex system orchestration with multiple coordinated nodes
- Conditional launching based on environment or configuration
- Parameter management for different robot configurations
- Process monitoring and health checking
- Safe startup and shutdown sequences

## Common Pitfalls & Debugging

When working with ROS 2 launch systems, especially in complex humanoid robotics applications, several common issues can arise:

1. **Node Startup Order**: Nodes starting before their dependencies are ready.

2. **Parameter Configuration**: Incorrect or missing parameter configurations.

3. **Namespace Issues**: Improper namespace handling causing topic conflicts.

4. **Resource Conflicts**: Multiple nodes trying to access the same hardware resources.

5. **Launch File Syntax**: Python syntax errors in launch files.

6. **Conditional Logic**: Complex conditions that don't behave as expected.

To debug launch issues effectively:
- Use `ros2 launch` with verbose output (`-d` flag)
- Check parameter files for correct formatting
- Verify node names and namespaces
- Test nodes individually before including in launch files
- Use launch event handlers for proper process coordination
- Monitor system status after launch

## Summary

The ROS 2 launch system provides a powerful and flexible framework for starting and managing complex robot systems. For humanoid robotics applications, proper launch configuration is essential for coordinating the many nodes that make up a complete robot system. Understanding how to properly structure launch files ensures that robots can be deployed reliably and safely.

## Key Takeaways Checklist

- [ ] Launch files are Python scripts that define system startup
- [ ] Launch descriptions specify processes to start
- [ ] Parameters can be configured at multiple levels
- [ ] Namespaces prevent topic conflicts
- [ ] Conditional launching allows for flexible configurations
- [ ] Event handlers enable process monitoring
- [ ] Safety-critical systems require careful launch ordering
- [ ] Simulation vs. real robot may need different configurations
- [ ] Validation ensures launch files are properly structured
- [ ] Monitoring provides feedback on system health

## References (APA 7th)

Lupus, E., Timmons, E., & Paepcke, A. (2022). Robot Operating System 2: Design, architecture, and uses in the wild. *Journal of Open Source Software*, 7(77), 3001. https://doi.org/10.21105/joss.03001

Quigley, M., Gerkey, B., & Smart, W. D. (2021). *Programming robots with ROS: A practical introduction to the Robot Operating System*. O'Reilly Media.

ROS.org. (2023). *ROS 2 launch system documentation*. Open Robotics. https://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Launch-Main.html

Saldanha, P., Ucieda, J. M., & Morrison, J. (2019). Launch system design patterns for complex robotic systems in ROS 2. *2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 3682-3689. https://doi.org/10.1109/IROS40897.2019.8968283

Macenski, S. (2022). Launch configuration and process management in ROS 2: A practical guide for complex robots. *IEEE Robotics & Automation Magazine*, 29(2), 108-117. https://doi.org/10.1109/MRA.2022.3156795