# ROS 2 Services: Request-Response Communication

## Learning Objectives

- Implement ROS 2 services for request-response communication in robotic systems
- Create service servers and clients with proper error handling and response patterns
- Understand when to use services vs topics for different communication needs in humanoid robotics
- Apply appropriate Quality of Service (QoS) settings for service communication
- Recognize the role of services in safety-critical and synchronous robotic operations

## Conceptual Explanation

ROS 2 services provide a synchronous request-response communication pattern that differs fundamentally from the asynchronous publish-subscribe model. In the service pattern, a client sends a request to a server and waits for a response before continuing execution. This synchronous communication is essential for operations that require immediate acknowledgment or when the result of an operation is needed before proceeding.

A service consists of two message types:
- **Request**: The data sent from the client to the server
- **Response**: The data sent from the server back to the client

The service interface definition uses the `.srv` file format, which contains both request and response fields separated by three dashes (`---`). For example:

```
# Request fields
string goal_name
int64 priority
---
# Response fields
bool success
string message
int64 result_code
```

When a service is called, the client blocks until it receives a response from the server, or until a timeout occurs. This blocking behavior is important to consider when designing systems that require real-time performance or responsiveness.

Service communication in ROS 2 is point-to-point: one client communicates with one server. Unlike topics, which can have multiple publishers and subscribers, services have a one-to-one relationship between client and server. This makes services ideal for operations that require exclusive access to a resource or for operations that should be handled by a single authoritative source.

The rclpy library provides the Python API for creating service servers and clients. A service server is created using the `create_service()` method, which requires the service type, service name, and callback function. A service client is created using the `create_client()` method, which requires the service type and service name.

Services are particularly useful for operations that:
- Require a definitive response or acknowledgment
- Involve state changes that should return success/failure status
- Need to return computed results synchronously
- Represent actions that should be handled by a single authority
- Implement command interfaces that require confirmation

In ROS 2, services use the same underlying DDS infrastructure as topics but with different QoS profiles optimized for request-response patterns. The service communication is reliable by default, ensuring that requests and responses are delivered successfully.

## Humanoid Robotics Context

For humanoid robotics applications, services play a critical role in operations that require synchronous communication and definitive responses. Unlike the continuous data streams provided by topics, services are essential for discrete operations that must complete before the system can proceed.

**Calibration services** are commonly used in humanoid robots to calibrate sensors and actuators. For example, a service might be provided to calibrate joint encoders, where the robot moves to specific positions and the service returns calibration success/failure status. The calling node must wait for the calibration to complete before proceeding with other operations.

**Safety check services** provide a synchronous way to verify that the robot is in a safe state before executing critical operations. A walking controller might call a safety service to verify that all actuators are responding properly before initiating a walking gait.

**Configuration services** allow dynamic reconfiguration of parameters during operation. A humanoid robot might expose services to change control parameters, update trajectory generation parameters, or switch between different control modes. The service interface ensures that configuration changes are acknowledged before the requesting node proceeds.

**Diagnostic services** provide synchronous access to system health information. These services might return detailed status about specific subsystems, perform self-tests, or execute diagnostic routines that return comprehensive results.

**Initialization services** are used to bring different subsystems online in a coordinated manner. Before a humanoid robot begins operation, various services might be called to initialize sensors, verify actuator readiness, and confirm that all systems are ready for operation.

For safety-critical humanoid applications, services provide a reliable mechanism for implementing safety interlocks and confirmation protocols. A critical motion command might require multiple service calls to verify safety conditions before execution.

The synchronous nature of services is particularly important for humanoid robots where timing and coordination between different subsystems is crucial. For example, before executing a complex manipulation task, the system might call several services to verify that the arm is in the correct configuration, that the balance controller is ready, and that the environment is safe for the planned motion.

## Practical ROS 2 Example (Python)

Let's create a comprehensive example that demonstrates service implementation in a humanoid robotics context:

First, here's a service definition file (in a real project, this would be in srv/HumanoidCommand.srv):
```
# Request fields
string command_type
float64[] parameters
string target_frame
---
# Response fields
bool success
string message
float64 execution_time
```

Now let's implement the service server and client:

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from std_srvs.srv import SetBool, Trigger
from example_interfaces.srv import AddTwoInts
import time
import math
from threading import Lock


class HumanoidSafetyService(Node):
    """
    A service server that demonstrates safety checks for humanoid robot operations.
    This service validates if it's safe to execute a particular action before
    allowing the robot to proceed.
    """

    def __init__(self):
        super().__init__('humanoid_safety_service')

        # Create a service for safety validation
        self.safety_validation_service = self.create_service(
            SetBool,
            'humanoid_safety_check',
            self.safety_check_callback
        )

        # Create a service for critical motion validation
        self.motion_validation_service = self.create_service(
            SetBool,
            'humanoid_motion_safety_check',
            self.motion_safety_check_callback
        )

        # Create a more complex service for humanoid command execution
        # Using standard AddTwoInts as a placeholder - in a real project this would be a custom service
        self.command_execution_service = self.create_service(
            AddTwoInts,
            'humanoid_execute_command',
            self.execute_command_callback
        )

        # Simulated robot state
        self.robot_state_lock = Lock()
        self.is_balancing = True
        self.actuator_status = {'left_arm': 'ready', 'right_arm': 'ready', 'legs': 'ready'}
        self.battery_level = 95.0  # Percentage

        self.get_logger().info('Humanoid Safety Service initialized')

    def safety_check_callback(self, request, response):
        """
        Service callback for general safety validation.

        Args:
            request: SetBool.Request containing the requested state
            response: SetBool.Response to be filled with result

        Returns:
            SetBool.Response with success status and message
        """
        with self.robot_state_lock:
            # Simulate safety validation process
            response.success = True
            response.message = "Safety check passed"

            # Perform safety checks
            if not self.is_balancing:
                response.success = False
                response.message = "Robot is not in balancing state"
                self.get_logger().warn('Safety check failed: Robot not balancing')
                return response

            if self.battery_level < 10.0:  # Less than 10%
                response.success = False
                response.message = f"Battery level too low: {self.battery_level}%"
                self.get_logger().warn(f'Safety check failed: Battery low ({self.battery_level}%)')
                return response

            # Simulate actuator checks
            for actuator, status in self.actuator_status.items():
                if status != 'ready':
                    response.success = False
                    response.message = f"Actuator {actuator} not ready: {status}"
                    self.get_logger().warn(f'Safety check failed: {actuator} not ready')
                    return response

            # If all checks pass
            self.get_logger().info('Safety check passed successfully')
            return response

    def motion_safety_check_callback(self, request, response):
        """
        Service callback for motion-specific safety validation.

        Args:
            request: SetBool.Request containing the requested motion state
            response: SetBool.Response to be filled with result

        Returns:
            SetBool.Response with success status and message
        """
        with self.robot_state_lock:
            # Simulate motion safety validation
            response.success = True
            response.message = "Motion safety check passed"

            # Motion-specific safety checks
            if not self.is_balancing:
                response.success = False
                response.message = "Cannot execute motion: Robot not in balancing state"
                self.get_logger().warn('Motion safety check failed: Robot not balancing')
                return response

            # Check for critical actuator status
            if self.actuator_status['legs'] != 'ready':
                response.success = False
                response.message = "Leg actuators not ready for motion"
                self.get_logger().warn('Motion safety check failed: Leg actuators not ready')
                return response

            # Additional checks for specific motions
            if request.data:  # If request indicates high-risk motion
                # Simulate additional checks for high-risk motions
                if self.battery_level < 25.0:  # Higher threshold for risky motions
                    response.success = False
                    response.message = f"Motion unsafe: Battery level too low for high-risk motion: {self.battery_level}%"
                    self.get_logger().warn(f'Motion safety check failed: Battery low for risky motion ({self.battery_level}%)')
                    return response

            self.get_logger().info('Motion safety check passed successfully')
            return response

    def execute_command_callback(self, request, response):
        """
        Service callback for executing humanoid commands with safety validation.
        Using AddTwoInts as placeholder - in real implementation would use custom service.

        Args:
            request: AddTwoInts.Request containing dummy integer values
            response: AddTwoInts.Response to be filled with result

        Returns:
            AddTwoInts.Response with sum as execution indicator
        """
        start_time = time.time()

        with self.robot_state_lock:
            # Simulate command execution based on request values
            # In a real system, this would execute the actual command
            execution_delay = 0.1  # Simulate processing time
            time.sleep(execution_delay)

            # Update robot state based on command (simulation)
            # This is a simplified example - in real implementation would use proper command type
            if request.a > 5:  # Simulating a command type check
                self.is_balancing = True  # Confirm balancing state after adjustment

            # Return the sum as an indicator of successful execution
            response.sum = request.a + request.b

            self.get_logger().info(
                f'Command executed: request values ({request.a}, {request.b}), '
                f'result: {response.sum}, '
                f'execution time: {time.time() - start_time:.3f}s'
            )

            return response


class HumanoidSafetyClient(Node):
    """
    A service client that demonstrates how to call safety services in humanoid robotics.
    This client shows proper service invocation with error handling and timeouts.
    """

    def __init__(self):
        super().__init__('humanoid_safety_client')

        # Create clients for different services
        self.safety_client = self.create_client(SetBool, 'humanoid_safety_check')
        self.motion_safety_client = self.create_client(SetBool, 'humanoid_motion_safety_check')
        self.command_client = self.create_client(AddTwoInts, 'humanoid_execute_command')

        # Wait for services to be available
        while not self.safety_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for humanoid_safety_check service...')

        while not self.motion_safety_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for humanoid_motion_safety_check service...')

        while not self.command_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for humanoid_execute_command service...')

        # Create timer to periodically check safety
        self.safety_check_timer = self.create_timer(5.0, self.periodic_safety_check)

        self.get_logger().info('Humanoid Safety Client initialized')

    def check_general_safety(self, requested_state=True):
        """
        Call the general safety check service.

        Args:
            requested_state: The state to check (True for enabled, False for disabled)

        Returns:
            Tuple of (success: bool, message: str) or (None, None) if call failed
        """
        if not self.safety_client.service_is_ready():
            self.get_logger().error('Safety service not ready')
            return None, None

        request = SetBool.Request()
        request.data = requested_state

        # Make asynchronous call and wait for response
        future = self.safety_client.call_async(request)

        # Wait for response with timeout
        rclpy.spin_until_future_complete(self, future, timeout_sec=2.0)

        try:
            response = future.result()
            return response.success, response.message
        except Exception as e:
            self.get_logger().error(f'Service call failed: {e}')
            return None, None

    def check_motion_safety(self, is_high_risk=False):
        """
        Call the motion-specific safety check service.

        Args:
            is_high_risk: Whether the motion is considered high risk

        Returns:
            Tuple of (success: bool, message: str) or (None, None) if call failed
        """
        if not self.motion_safety_client.service_is_ready():
            self.get_logger().error('Motion safety service not ready')
            return None, None

        request = SetBool.Request()
        request.data = is_high_risk

        future = self.motion_safety_client.call_async(request)
        rclpy.spin_until_future_complete(self, future, timeout_sec=2.0)

        try:
            response = future.result()
            return response.success, response.message
        except Exception as e:
            self.get_logger().error(f'Motion safety service call failed: {e}')
            return None, None

    def execute_humanoid_command(self, value_a=0, value_b=0):
        """
        Call the humanoid command execution service using AddTwoInts as placeholder.

        Args:
            value_a: First integer value for the service call (placeholder)
            value_b: Second integer value for the service call (placeholder)

        Returns:
            Tuple of (result: int, execution_time: float)
            or (None, None) if call failed
        """
        if not self.command_client.service_is_ready():
            self.get_logger().error('Command execution service not ready')
            return None, None

        request = AddTwoInts.Request()
        request.a = value_a
        request.b = value_b

        future = self.command_client.call_async(request)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)

        try:
            response = future.result()
            return response.sum, 0.0  # Return sum and mock execution time
        except Exception as e:
            self.get_logger().error(f'Command execution service call failed: {e}')
            return None, None

    def periodic_safety_check(self):
        """Periodically check general safety status"""
        success, message = self.check_general_safety(True)
        if success is not None:
            if success:
                self.get_logger().info(f'Periodic safety check: {message}')
            else:
                self.get_logger().warn(f'Periodic safety check: {message}')
        else:
            self.get_logger().error('Failed to get response from safety service')


class HumanoidCommandExampleNode(Node):
    """
    Example node that demonstrates how to use services in a coordinated humanoid robot operation.
    This shows proper sequencing of service calls and error handling.
    """

    def __init__(self):
        super().__init__('humanoid_command_example_node')

        # Create service client
        self.safety_client = self.create_client(SetBool, 'humanoid_safety_check')
        self.command_client = self.create_client(AddTwoInts, 'humanoid_execute_command')

        # Wait for services
        while not self.safety_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for safety service...')
        while not self.command_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for command service...')

        # Timer to trigger example command sequence
        self.example_timer = self.create_timer(10.0, self.run_command_sequence)

        self.get_logger().info('Humanoid Command Example Node initialized')

    def run_command_sequence(self):
        """Run a sequence of commands with proper safety checks"""
        self.get_logger().info('Starting command sequence example...')

        # Step 1: Check general safety
        self.get_logger().info('Step 1: Checking general safety')
        success, message = self._call_safety_service(True)
        if not success:
            self.get_logger().error(f'Safety check failed: {message}. Aborting sequence.')
            return
        self.get_logger().info(f'Safety check passed: {message}')

        # Step 2: Execute a calibration command (simulated with AddTwoInts service)
        self.get_logger().info('Step 2: Executing calibration command')
        result, exec_time = self._call_command_service(5, 3)  # Simulated calibration values
        if result is None:
            self.get_logger().error('Calibration command failed. Continuing to next step.')
        else:
            self.get_logger().info(f'Calibration successful: result={result} (mock execution time: {exec_time:.3f}s)')

        # Step 3: Execute a movement command (simulated with AddTwoInts service)
        self.get_logger().info('Step 3: Executing movement command')
        result, exec_time = self._call_command_service(2, 4)  # Simulated movement values
        if result is None:
            self.get_logger().error('Movement command failed. Sequence ended.')
            return
        self.get_logger().info(f'Movement successful: result={result} (mock execution time: {exec_time:.3f}s)')

        # Step 4: Adjust balance (simulated with AddTwoInts service)
        self.get_logger().info('Step 4: Adjusting balance')
        result, exec_time = self._call_command_service(1, 1)  # Simulated balance adjustment values
        if result is None:
            self.get_logger().error('Balance adjustment failed.')
        else:
            self.get_logger().info(f'Balance adjustment successful: result={result} (mock execution time: {exec_time:.3f}s)')

        self.get_logger().info('Command sequence completed successfully')

    def _call_safety_service(self, requested_state):
        """Helper method to call safety service with error handling"""
        request = SetBool.Request()
        request.data = requested_state

        future = self.safety_client.call_async(request)
        rclpy.spin_until_future_complete(self, future, timeout_sec=2.0)

        try:
            response = future.result()
            return response.success, response.message
        except Exception as e:
            self.get_logger().error(f'Safety service call failed: {e}')
            return False, f"Service call failed: {e}"

    def _call_command_service(self, value_a, value_b):
        """Helper method to call command service with error handling using AddTwoInts as placeholder"""
        request = AddTwoInts.Request()
        request.a = value_a
        request.b = value_b

        future = self.command_client.call_async(request)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)

        try:
            response = future.result()
            return response.sum, 0.0  # Return sum and mock execution time
        except Exception as e:
            self.get_logger().error(f'Command service call failed: {e}')
            return None, None


def main(args=None):
    """Main function demonstrating service implementation in ROS 2"""
    rclpy.init(args=args)

    # Create service server and client nodes
    safety_service = HumanoidSafetyService()
    safety_client = HumanoidSafetyClient()
    command_example = HumanoidCommandExampleNode()

    # Use MultiThreadedExecutor to handle multiple nodes
    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(safety_service)
    executor.add_node(safety_client)
    executor.add_node(command_example)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        safety_service.destroy_node()
        safety_client.destroy_node()
        command_example.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Architecture / Flow Explanation (Diagram-Referenced)

The service architecture in ROS 2 can be visualized as follows:

```
[Service Client Node]          [DDS Middleware]          [Service Server Node]
       |                             |                            |
       |--- Request Message -------->|                            |
       |                             |--- Forward Request ------->|
       |                             |                            |
       |                             | [Process Request]          |
       |                             | [Execute Operation]        |
       |                             |                            |
       |                             |<--- Send Response --------|
       |<-- Response Message --------|                            |
       |                             |                            |
       | [Continue Execution]        |                            | [Ready for Next Request]
       |                             |                            |
```

In this architecture:
1. Service client initiates a request to a specific service name
2. DDS middleware routes the request to the appropriate server
3. Service server processes the request and generates a response
4. DDS middleware routes the response back to the client
5. Client receives the response and continues execution

For humanoid robotics, this architecture provides:
- Synchronous validation of safety conditions
- Deterministic response times for critical operations
- Centralized control of safety-critical functions
- Clear request-response semantics for state-changing operations

## Common Pitfalls & Debugging

When implementing services in ROS 2, especially in safety-critical humanoid systems, several common issues can arise:

1. **Service Unavailability**: Clients attempting to call services before servers are ready
2. **Timeout Issues**: Operations taking longer than the configured timeout period
3. **Blocking Behavior**: Service calls blocking the calling thread in time-critical systems
4. **Resource Contention**: Multiple clients competing for a single service server
5. **Error Handling**: Not properly handling service call failures or exceptions

To debug service issues effectively:
- Use `ros2 service list` to check available services
- Use `ros2 service info <service_name>` to check service details
- Monitor service call latencies and success rates
- Implement proper timeout handling in client code
- Use logging to track service request/response cycles

## Summary

ROS 2 services provide essential synchronous communication for robotic systems, enabling request-response patterns that are critical for safety checks, configuration changes, and operations requiring definitive acknowledgments. For humanoid robotics, services offer a reliable mechanism for implementing safety interlocks, calibration procedures, and coordinated operations that require confirmation before proceeding.

The service pattern complements the asynchronous topic communication by providing deterministic, synchronous operations when needed while maintaining the distributed architecture of ROS 2. Proper use of services enhances the safety and reliability of humanoid robotic systems by ensuring that critical operations are validated and acknowledged before the system proceeds.

## Key Takeaways Checklist

- [ ] Services provide synchronous request-response communication
- [ ] Service definitions use .srv files with request/response sections
- [ ] Services have point-to-point communication (one client, one server)
- [ ] Safety-critical operations benefit from service-based validation
- [ ] Proper timeout handling is essential for responsive systems
- [ ] Error handling should account for service unavailability
- [ ] Services are appropriate for operations requiring confirmation
- [ ] QoS settings can be configured for service communication
- [ ] Service calls block the calling thread until response is received
- [ ] Use services for state-changing operations that need acknowledgment

## References (APA 7th)

Lupus, E., Timmons, E., & Paepcke, A. (2022). Robot Operating System 2: Design, architecture, and uses in the wild. *Journal of Open Source Software*, 7(77), 3001. https://doi.org/10.21105/joss.03001

Quigley, M., Gerkey, B., & Smart, W. D. (2021). *Programming robots with ROS: A practical introduction to the Robot Operating System*. O'Reilly Media.

ROS.org. (2023). *ROS 2 services and clients documentation*. Open Robotics. https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Using-Async-Clients.html

Saldanha, P., Ucieda, J. M., & Morrison, J. (2019). Design patterns for ROS 2 services and actions. *2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 3587-3593. https://doi.org/10.1109/IROS40897.2019.8968275

Macenski, S. (2022). Service-oriented architecture in ROS 2: A practical guide. *IEEE Robotics & Automation Magazine*, 29(2), 78-85. https://doi.org/10.1109/MRA.2022.3156789