# ROS 2 Domains, Namespaces, and Isolation Strategies

## Learning Objectives

- Understand the purpose and implementation of ROS_DOMAIN_ID for system isolation
- Explain how namespaces organize nodes and topics in complex robotic systems
- Identify use cases for multi-robot and simulation environments
- Recognize isolation strategies for humanoid robotics applications
- Implement proper domain and namespace configurations for safety

## Conceptual Explanation

ROS 2 provides two distinct mechanisms for organizing and isolating robotic systems: domains and namespaces. These mechanisms serve different purposes and operate at different levels of the communication stack.

**Domains** (controlled by ROS_DOMAIN_ID) provide network-level isolation by creating separate DDS communication planes. Each domain operates as an independent communication space, preventing nodes in different domains from discovering or communicating with each other. This is particularly important for safety and security, as it ensures that systems intended to be isolated cannot accidentally interfere with each other.

Domains are identified by a numeric ID (0-232) and all nodes in the same domain can discover and communicate with each other regardless of their namespace. By default, all ROS 2 nodes operate in domain 0, but this can be changed by setting the ROS_DOMAIN_ID environment variable or programmatically in the code.

**Namespaces** provide logical organization within a domain by creating hierarchical naming structures for nodes, topics, services, and parameters. Namespaces allow multiple instances of similar systems to operate within the same domain without naming conflicts. They are particularly useful for multi-robot systems, simulation environments, and organizing complex single robots with multiple subsystems.

Namespaces follow a forward-slash (/) delimited hierarchy similar to file system paths. For example, a humanoid robot might use namespaces like `/left_arm`, `/right_arm`, `/torso`, and `/head` to organize different subsystems. When a node is created with a namespace, all of its topics and services are automatically prefixed with that namespace.

The combination of domains and namespaces provides a powerful isolation strategy:
- Domains provide complete network isolation between systems
- Namespaces provide logical organization within systems
- Together, they enable complex multi-robot and multi-environment deployments

## Humanoid Robotics Context

For humanoid robotics, domains and namespaces provide essential isolation and organization capabilities. A humanoid robot system might use domains to separate:
- Development and testing environments from production systems
- Simulation environments from real robot systems
- Safety-critical control systems from non-critical perception systems
- Different robot instances in multi-robot scenarios

Namespaces are particularly valuable for humanoid robots due to their complex, multi-subsystem nature. A humanoid robot might use the following namespace organization:
- `/left_arm` - Contains all nodes, topics, and parameters for the left arm
- `/right_arm` - Contains all nodes, topics, and parameters for the right arm
- `/legs` - Contains nodes for leg control and locomotion
- `/head` - Contains vision and perception nodes
- `/sensors` - Contains sensor processing nodes
- `/control` - Contains high-level control and planning nodes

This organization allows for:
- Independent development and testing of subsystems
- Clear separation of concerns between different robot components
- Easy integration of new subsystems without naming conflicts
- Simplified debugging and monitoring of specific robot parts

In safety-critical humanoid applications, domains can be used to ensure that development systems cannot accidentally interfere with deployed robot systems. For example, the robot might operate in domain 1 while development tools operate in domain 2.

## Practical ROS 2 Example (Python)

Let's create an example that demonstrates domains and namespaces in a humanoid robotics context:

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from std_msgs.msg import String, Float64MultiArray
from sensor_msgs.msg import JointState
import os


class HumanoidDomainNamespaceDemoNode(Node):
    """
    A demonstration node showing how domains and namespaces work in ROS 2
    for humanoid robotics applications. This node shows how to configure
    domains programmatically and use namespaces for subsystem organization.
    """

    def __init__(self, namespace=None):
        # Initialize with a namespace if provided
        super().__init__('humanoid_demo_node', namespace=namespace)

        # Create QoS profile for communication
        qos_profile = QoSProfile(depth=10, reliability=ReliabilityPolicy.RELIABLE)

        # Publishers for different subsystems using namespace
        self.status_publisher = self.create_publisher(
            String, 'status', qos_profile)
        self.joint_command_publisher = self.create_publisher(
            JointState, 'joint_commands', qos_profile)
        self.sensor_data_publisher = self.create_publisher(
            Float64MultiArray, 'sensor_data', qos_profile)

        # Timers for different subsystems
        self.status_timer = self.create_timer(1.0, self.publish_status)
        self.command_timer = self.create_timer(0.1, self.publish_joint_commands)
        self.sensor_timer = self.create_timer(0.05, self.publish_sensor_data)

        self.get_logger().info(f'Humanoid Demo Node initialized in namespace: {namespace or "default"}')

        # Initialize counters
        self.status_counter = 0
        self.command_counter = 0
        self.sensor_counter = 0

    def publish_status(self):
        """Publish status information"""
        msg = String()
        namespace = self.get_namespace()
        msg.data = f'Node {self.get_name()} in namespace {namespace} - Status #{self.status_counter}'

        self.status_publisher.publish(msg)
        self.status_counter += 1

    def publish_joint_commands(self):
        """Publish joint commands"""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = [f'joint_{i}' for i in range(5)]
        msg.position = [0.1 * self.command_counter + i * 0.01 for i in range(5)]

        self.joint_command_publisher.publish(msg)
        self.command_counter += 1

    def publish_sensor_data(self):
        """Publish sensor data"""
        msg = Float64MultiArray()
        msg.data = [0.01 * self.sensor_counter + i * 0.001 for i in range(10)]

        self.sensor_data_publisher.publish(msg)
        self.sensor_counter += 1


class HumanoidMultiNamespaceManagerNode(Node):
    """
    A manager node that demonstrates how to work with multiple namespaces
    and coordinate between different subsystems of a humanoid robot.
    """

    def __init__(self):
        super().__init__('humanoid_manager_node')

        # Create QoS profile
        qos_profile = QoSProfile(depth=10, reliability=ReliabilityPolicy.RELIABLE)

        # Publishers for different subsystems using explicit namespace paths
        self.left_arm_status_publisher = self.create_publisher(
            String, '/left_arm/status', qos_profile)
        self.right_arm_status_publisher = self.create_publisher(
            String, '/right_arm/status', qos_profile)
        self.torso_status_publisher = self.create_publisher(
            String, '/torso/status', qos_profile)

        # Timer for coordination
        self.coordination_timer = self.create_timer(0.5, self.coordinate_subsystems)

        self.get_logger().info('Humanoid Manager Node initialized - coordinating multiple namespaces')

        self.coordination_counter = 0

    def coordinate_subsystems(self):
        """Coordinate between different subsystems"""
        # Publish coordination messages to different namespaces
        left_msg = String()
        left_msg.data = f'Coordination command #{self.coordination_counter} for left arm'
        self.left_arm_status_publisher.publish(left_msg)

        right_msg = String()
        right_msg.data = f'Coordination command #{self.coordination_counter} for right arm'
        self.right_arm_status_publisher.publish(right_msg)

        torso_msg = String()
        torso_msg.data = f'Coordination command #{self.coordination_counter} for torso'
        self.torso_status_publisher.publish(torso_msg)

        self.coordination_counter += 1


def demonstrate_domain_configuration():
    """
    Demonstrate how to configure domain IDs programmatically.
    Note: Domain ID must be set before rclpy.init() is called.
    """
    # In practice, domain ID is usually set via environment variable:
    # export ROS_DOMAIN_ID=10
    # Or programmatically before initialization:

    # Set domain ID for this process
    os.environ['ROS_DOMAIN_ID'] = '10'
    print("Domain ID set to 10 for this process")


def main(args=None):
    """Main function demonstrating domains and namespaces in ROS 2"""

    # Demonstrate domain configuration
    demonstrate_domain_configuration()

    # Initialize ROS 2 with the configured domain
    rclpy.init(args=args)

    # Create nodes in different namespaces to simulate humanoid subsystems
    left_arm_node = HumanoidDomainNamespaceDemoNode(namespace='left_arm')
    right_arm_node = HumanoidDomainNamespaceDemoNode(namespace='right_arm')
    legs_node = HumanoidDomainNamespaceDemoNode(namespace='legs')
    head_node = HumanoidDomainNamespaceDemoNode(namespace='head')

    # Create manager node in default namespace
    manager_node = HumanoidMultiNamespaceManagerNode()

    # Use MultiThreadedExecutor to run all nodes
    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(left_arm_node)
    executor.add_node(right_arm_node)
    executor.add_node(legs_node)
    executor.add_node(head_node)
    executor.add_node(manager_node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up resources
        left_arm_node.destroy_node()
        right_arm_node.destroy_node()
        legs_node.destroy_node()
        head_node.destroy_node()
        manager_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

To run this example in different domains, you would use:

```bash
# Terminal 1 - Domain 10 (set by the code)
python3 humanoid_domain_namespace_demo.py

# Terminal 2 - Domain 20 (separate system)
export ROS_DOMAIN_ID=20
python3 some_other_node.py

# Verify nodes are in different domains
# Nodes in different domains cannot communicate with each other
```

This example demonstrates:
- How to create nodes with specific namespaces
- How to publish to topics in different namespaces
- How domain configuration works
- How to coordinate between subsystems using namespaces

## Architecture / Flow Explanation (Diagram-Referenced)

The domain and namespace architecture in ROS 2 can be visualized as follows:

```
[Domain 0 - Development/Testing]
         |
    [Node: /dev_controller] ---- [Node: /dev_sensor]
         |                              |
    [/dev_controller/cmd] ---- [/dev_sensor/data]

[Domain 10 - Humanoid Robot Production]
         |
    [Namespace: /left_arm]      [Namespace: /right_arm]
         |                            |
    [Node: /left_arm/control]   [Node: /right_arm/control]
    [Node: /left_arm/sensors]   [Node: /right_arm/sensors]
         |                            |
    [/left_arm/joints] ---- [/right_arm/joints]

[Domain 20 - Simulation Environment]
         |
    [Namespace: /sim_robot_1]   [Namespace: /sim_robot_2]
         |                            |
    [Node: /sim_robot_1/control] [Node: /sim_robot_2/control]
         |                            |
    [/sim_robot_1/joints] ---- [/sim_robot_2/joints]
```

In this architecture:
1. Different domains provide complete network isolation
2. Namespaces within a domain provide logical organization
3. Nodes in different domains cannot communicate
4. Nodes in different namespaces within the same domain can communicate
5. Topic names include the namespace prefix

For humanoid robots, this means:
- Safety-critical systems can be isolated in separate domains
- Different robot subsystems can be organized in namespaces
- Simulation and real robot systems can be completely isolated
- Multiple robot instances can coexist with proper domain separation

## Common Pitfalls & Debugging

When working with domains and namespaces in ROS 2, especially in complex humanoid systems, several common issues can arise:

1. **Domain ID Conflicts**: Multiple systems on the same network with the same domain ID can interfere with each other.

2. **Namespace Confusion**: Incorrectly using namespaces can lead to naming conflicts or inability to communicate with intended nodes.

3. **Cross-Domain Communication Attempts**: Trying to communicate between nodes in different domains will fail silently.

4. **Environment Variable Issues**: Forgetting to set ROS_DOMAIN_ID in all relevant terminals or processes.

5. **Relative vs Absolute Names**: Confusion between relative and absolute topic/service names when using namespaces.

6. **Parameter Access**: Parameters in namespaced nodes require fully qualified names.

To debug domain and namespace issues effectively:
- Use `ros2 node list` and `ros2 node info <node_name>` to verify node namespaces
- Check domain ID with `echo $ROS_DOMAIN_ID`
- Use `ros2 topic list` to see topics in the current domain
- Verify that nodes that should communicate are in the same domain
- Use `ros2 param list` to check parameter names in namespaced nodes
- Monitor network traffic to ensure domain isolation is working

## Summary

Domains and namespaces provide essential organization and isolation capabilities in ROS 2 that are particularly valuable for complex robotic systems like humanoid robots. Domains provide network-level isolation between completely separate systems, while namespaces provide logical organization within a domain.

The domain system ensures that development, testing, and production systems can coexist safely on the same network. The namespace system allows for clear organization of complex multi-subsystem robots while maintaining clean separation of concerns.

For humanoid robotics, this architecture enables safe development practices, clear system organization, and robust multi-robot deployments while maintaining the flexibility needed for complex robotic applications.

## Key Takeaways Checklist

- [ ] Domain IDs provide network-level isolation between ROS 2 systems
- [ ] Namespaces provide logical organization within a domain
- [ ] Nodes in different domains cannot communicate with each other
- [ ] Namespaces follow hierarchical forward-slash delimited paths
- [ ] Domain ID is set via ROS_DOMAIN_ID environment variable
- [ ] Namespaces are specified when creating nodes
- [ ] Topic names include namespace prefixes
- [ ] Multi-robot systems benefit from domain separation
- [ ] Complex robots benefit from namespace organization
- [ ] Safety-critical systems should use isolated domains

## References (APA 7th)

Lupus, E., Timmons, E., & Paepcke, A. (2022). Robot Operating System 2: Design, architecture, and uses in the wild. *Journal of Open Source Software*, 7(77), 3001. https://doi.org/10.21105/joss.03001

Quigley, M., Gerkey, B., & Smart, W. D. (2021). *Programming robots with ROS: A practical introduction to the Robot Operating System*. O'Reilly Media.

ROS.org. (2023). *ROS 2 domains and namespaces documentation*. Open Robotics. https://docs.ros.org/en/humble/Concepts/About-Topics.html#namespaces

Saldanha, P., Ucieda, J. M., & Morrison, J. (2019). Design patterns for ROS 2 publishers and subscribers. *2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 3587-3593. https://doi.org/10.1109/IROS40897.2019.8968275

Macenski, S. (2022). Multi-robot systems with ROS 2: Domain and namespace strategies. *IEEE Robotics & Automation Magazine*, 29(2), 67-75. https://doi.org/10.1109/MRA.2022.3156789