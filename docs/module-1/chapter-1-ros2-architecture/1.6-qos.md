# Quality of Service (QoS) Policies in ROS 2

## Learning Objectives

- Understand Quality of Service (QoS) policies and their role in ROS 2 communication
- Identify different QoS policy types and their appropriate applications
- Configure QoS policies for specific use cases in robotic systems
- Recognize the importance of QoS policies for safety-critical humanoid robotics
- Explain how QoS policies affect reliability, performance, and real-time behavior

## Conceptual Explanation

Quality of Service (QoS) policies in ROS 2 provide fine-grained control over the communication behavior between publishers and subscribers. Unlike ROS 1, where communication behavior was largely predetermined, ROS 2 allows developers to specify exactly how messages should be delivered, stored, and handled based on the specific requirements of their application.

QoS policies are grouped into several categories that control different aspects of communication:

**Reliability Policy**: Determines whether messages are guaranteed to be delivered. Options include:
- **RELIABLE**: Messages are guaranteed to be delivered, with retries if necessary
- **BEST_EFFORT**: Messages are sent without guarantee of delivery, potentially faster but with possible losses

**Durability Policy**: Controls whether late-joining subscribers receive previous messages. Options include:
- **TRANSIENT_LOCAL**: Publishers maintain a record of the most recent messages for late joiners
- **VOLATILE**: No historical messages are maintained; only new messages are sent

**History Policy**: Specifies how many messages are stored for delivery. Options include:
- **KEEP_LAST**: Maintain the most recent N messages (where N is specified by depth)
- **KEEP_ALL**: Maintain all messages (memory intensive)

**Deadline Policy**: Sets the maximum time between consecutive messages, useful for detecting when a publisher has stopped sending messages.

**Liveliness Policy**: Defines how a publisher's liveliness is determined, important for safety-critical applications.

**Rate Policy**: Controls the rate at which messages are processed.

These policies work together to define the communication contract between publishers and subscribers. If the QoS policies of a publisher and subscriber are incompatible, they will not be able to communicate with each other. This ensures that communication behaves according to the specified requirements.

QoS policies are particularly important in robotic systems where different types of data have vastly different requirements. For example, sensor data may require best-effort delivery to avoid delays, while safety-critical control commands may require reliable delivery with historical context.

## Humanoid Robotics Context

For humanoid robotics, QoS policies are critical for ensuring the right balance of performance, reliability, and safety. Humanoid robots operate in complex environments where different subsystems have different communication requirements:

**High-frequency sensor data** (IMU, force/torque sensors, encoders) typically requires:
- RELIABLE delivery to ensure no critical safety data is lost
- VOLATILE durability since old sensor readings are less valuable
- SMALL history depth to minimize latency
- SHORT deadlines to detect sensor failures quickly

**Control commands** for actuators typically require:
- RELIABLE delivery to ensure commands reach actuators
- VOLATILE durability since old commands are invalid
- SMALL history depth to ensure commands are current
- STRICT deadlines to ensure timely execution

**Perception data** (camera images, point clouds) may use:
- BEST_EFFORT delivery since some dropped frames may be acceptable
- VOLATILE durability to avoid accumulating old data
- LARGER history depth for algorithms that process multiple frames
- FLEXIBLE deadlines to accommodate processing variations

**Planning and trajectory data** might use:
- RELIABLE delivery to ensure trajectory integrity
- TRANSIENT_LOCAL durability so late-joining nodes get current trajectory
- MODERATE history depth for trajectory smoothing
- MODERATE deadlines to balance timeliness and processing

In safety-critical humanoid applications, incorrect QoS configuration can lead to dangerous situations. For example, if safety-critical sensor data is configured with BEST_EFFORT policy, important obstacle detection data might be lost, potentially causing collisions. Conversely, if control commands are configured with TRANSIENT_LOCAL durability, outdated commands might be sent to actuators, causing unpredictable robot behavior.

## Practical ROS 2 Example (Python)

Let's create a comprehensive example that demonstrates QoS policies in a humanoid robotics context:

```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy, LivelinessPolicy
from rclpy.duration import Duration
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Twist
from std_msgs.msg import Bool
import time


class HumanoidQoSDemonstrationNode(Node):
    """
    A demonstration node showing how to configure QoS policies for
    different types of data in humanoid robotics applications.
    """

    def __init__(self):
        super().__init__('humanoid_qos_demonstration_node')

        # QoS profile for safety-critical sensor data (IMU, force sensors)
        # Requires reliable delivery, no history, volatile durability
        self.safety_critical_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=5,  # Small buffer for performance
            reliability=ReliabilityPolicy.RELIABLE,  # Must deliver all messages
            durability=DurabilityPolicy.VOLATILE,  # Don't keep old messages
            deadline=Duration(seconds=0.1),  # Must come within 100ms
        )

        # QoS profile for high-frequency sensor data (encoders, cameras)
        # Uses best effort to avoid blocking
        self.high_freq_sensor_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=10,  # Larger buffer for processing
            reliability=ReliabilityPolicy.BEST_EFFORT,  # Accept some loss for speed
            durability=DurabilityPolicy.VOLATILE,
            deadline=Duration(seconds=0.05),  # Tight deadline for high-frequency data
        )

        # QoS profile for control commands
        # Requires reliable delivery and strict timing
        self.control_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=3,  # Only keep recent commands
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            deadline=Duration(seconds=0.01),  # Very tight deadline for control
        )

        # QoS profile for planning and trajectory data
        # Needs reliable delivery but can tolerate some delay
        self.planning_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=20,  # Keep more messages for planning algorithms
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,  # Share with late joiners
            deadline=Duration(seconds=1.0),  # More relaxed deadline for planning
        )

        # Publishers for different data types with appropriate QoS
        self.imu_publisher = self.create_publisher(
            Imu, 'humanoid_imu_data', self.safety_critical_qos)
        self.joint_state_publisher = self.create_publisher(
            JointState, 'humanoid_joint_states', self.high_freq_sensor_qos)
        self.control_command_publisher = self.create_publisher(
            Twist, 'humanoid_control_commands', self.control_qos)
        self.trajectory_publisher = self.create_publisher(
            JointState, 'humanoid_trajectory', self.planning_qos)
        self.emergency_stop_publisher = self.create_publisher(
            Bool, 'humanoid_emergency_stop', self.control_qos)

        # Timers for different data types
        self.imu_timer = self.create_timer(0.005, self.publish_imu_data)  # 200Hz
        self.joint_state_timer = self.create_timer(0.01, self.publish_joint_states)  # 100Hz
        self.control_timer = self.create_timer(0.005, self.publish_control_commands)  # 200Hz
        self.trajectory_timer = self.create_timer(0.1, self.publish_trajectory)  # 10Hz
        self.safety_timer = self.create_timer(0.001, self.check_safety_conditions)  # 1kHz

        self.get_logger().info('Humanoid QoS Demonstration Node initialized')

        # Initialize data counters
        self.imu_counter = 0
        self.joint_counter = 0
        self.control_counter = 0
        self.trajectory_counter = 0

    def publish_imu_data(self):
        """Publish IMU data with safety-critical QoS"""
        msg = Imu()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'humanoid_base_imu'

        # Simulate IMU data
        msg.linear_acceleration.x = 0.01 * self.imu_counter
        msg.linear_acceleration.y = 0.02 * self.imu_counter
        msg.linear_acceleration.z = 9.81 + 0.001 * self.imu_counter

        self.imu_publisher.publish(msg)
        self.imu_counter += 1

    def publish_joint_states(self):
        """Publish joint state data with high-frequency QoS"""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = [f'joint_{i}' for i in range(20)]  # 20 joints in humanoid
        msg.position = [0.1 * self.joint_counter + i * 0.01 for i in range(20)]
        msg.velocity = [0.01 * self.joint_counter + i * 0.001 for i in range(20)]
        msg.effort = [0.5 * self.joint_counter + i * 0.005 for i in range(20)]

        self.joint_state_publisher.publish(msg)
        self.joint_counter += 1

    def publish_control_commands(self):
        """Publish control commands with critical QoS"""
        msg = Twist()
        msg.linear.x = 0.1 * self.control_counter  # Forward velocity
        msg.linear.y = 0.05 * self.control_counter  # Lateral velocity
        msg.angular.z = 0.01 * self.control_counter  # Turning rate

        self.control_command_publisher.publish(msg)
        self.control_counter += 1

    def publish_trajectory(self):
        """Publish trajectory data with planning QoS"""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = [f'joint_{i}' for i in range(20)]
        # Simulate planned trajectory
        msg.position = [0.2 * self.trajectory_counter + i * 0.02 for i in range(20)]

        self.trajectory_publisher.publish(msg)
        self.trajectory_counter += 1

    def check_safety_conditions(self):
        """Check for safety conditions and publish emergency stops if needed"""
        # Simulate safety check
        if self.imu_counter % 100 == 0:  # Every 100 IMU readings
            # Simulate a safety condition (e.g., unusual acceleration)
            if abs(0.01 * self.imu_counter) > 1.0:  # Threshold condition
                emergency_msg = Bool()
                emergency_msg.data = True
                self.emergency_stop_publisher.publish(emergency_msg)
                self.get_logger().warn('EMERGENCY STOP PUBLISHED due to safety condition')


class HumanoidQoSListenerNode(Node):
    """
    A listener node that demonstrates how to properly configure
    subscriptions to match publisher QoS policies.
    """

    def __init__(self):
        super().__init__('humanoid_qos_listener_node')

        # Use the same QoS profiles as the publisher to ensure compatibility
        safety_critical_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=5,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            deadline=Duration(seconds=0.1),
        )

        high_freq_sensor_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=10,
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            deadline=Duration(seconds=0.05),
        )

        control_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=3,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            deadline=Duration(seconds=0.01),
        )

        planning_qos = QoSProfile(
            history=HistoryPolicy.KEEP_LAST,
            depth=20,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
            deadline=Duration(seconds=1.0),
        )

        # Subscriptions with matching QoS profiles
        self.imu_subscription = self.create_subscription(
            Imu, 'humanoid_imu_data', self.imu_callback, safety_critical_qos)

        self.joint_state_subscription = self.create_subscription(
            JointState, 'humanoid_joint_states', self.joint_state_callback, high_freq_sensor_qos)

        self.control_subscription = self.create_subscription(
            Twist, 'humanoid_control_commands', self.control_callback, control_qos)

        self.trajectory_subscription = self.create_subscription(
            JointState, 'humanoid_trajectory', self.trajectory_callback, planning_qos)

        self.emergency_stop_subscription = self.create_subscription(
            Bool, 'humanoid_emergency_stop', self.emergency_stop_callback, control_qos)

        self.get_logger().info('Humanoid QoS Listener Node initialized')

    def imu_callback(self, msg):
        """Handle IMU data with safety-critical processing"""
        self.get_logger().debug(f'IMU Data received: linear_acceleration={msg.linear_acceleration}')

    def joint_state_callback(self, msg):
        """Handle joint state data with high-frequency processing"""
        self.get_logger().debug(f'Joint states received: {len(msg.name)} joints')

    def control_callback(self, msg):
        """Handle control commands with critical processing"""
        self.get_logger().debug(f'Control command received: linear=({msg.linear.x}, {msg.linear.y}), angular=({msg.angular.z})')

    def trajectory_callback(self, msg):
        """Handle trajectory data with planning algorithms"""
        self.get_logger().debug(f'Trajectory received: {len(msg.position)} positions')

    def emergency_stop_callback(self, msg):
        """Handle emergency stop with immediate response"""
        if msg.data:
            self.get_logger().fatal('EMERGENCY STOP RECEIVED - ACTIVATING SAFETY PROTOCOLS')
        else:
            self.get_logger().info('Emergency stop cleared')


def demonstrate_qos_mismatch():
    """
    Demonstrate what happens when QoS policies are incompatible.
    This function shows how to detect and handle QoS mismatches.
    """
    print("QoS Mismatch Demonstration:")
    print("- Publishers and subscribers with incompatible QoS policies cannot communicate")
    print("- For example, a RELIABLE publisher with a BEST_EFFORT subscriber won't connect")
    print("- Always ensure QoS policies match between publishers and subscribers")
    print("- Use 'ros2 topic info <topic_name>' to check QoS compatibility")


def main(args=None):
    """Main function demonstrating QoS policies in ROS 2"""
    rclpy.init(args=args)

    # Create publisher and subscriber nodes
    publisher_node = HumanoidQoSDemonstrationNode()
    subscriber_node = HumanoidQoSListenerNode()

    # Use MultiThreadedExecutor to handle different timing requirements
    executor = rclpy.executors.MultiThreadedExecutor(num_threads=4)
    executor.add_node(publisher_node)
    executor.add_node(subscriber_node)

    try:
        # Demonstrate QoS mismatch concept
        demonstrate_qos_mismatch()

        # Run the nodes
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up resources
        publisher_node.destroy_node()
        subscriber_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

This example demonstrates how to properly configure QoS policies for different types of data in a humanoid robotics system, showing the importance of matching QoS policies between publishers and subscribers.

## Architecture / Flow Explanation (Diagram-Referenced)

The QoS policy architecture in ROS 2 can be visualized as follows:

```
[Publisher Node A]
     |
     |  [QoS Profile: Reliable, Volatile, Keep Last 5, Deadline 10ms]
     |
     v
[DDS Middleware] <-- [QoS Matching Algorithm]
     |
     |  [Compatible Subscriber QoS: Reliable, Volatile, Keep Last 10, Deadline 20ms]
     v
[Subscriber Node X] <-- Connected and Communicating

[Publisher Node B]
     |
     |  [QoS Profile: Best Effort, Volatile, Keep Last 3]
     |
     v
[DDS Middleware]
     |
     |  [Incompatible Subscriber QoS: Reliable, Transient Local, Keep All]
     |  [Connection Rejected - QoS Mismatch]
     x
[Subscriber Node Y] <-- Cannot Communicate
```

In this architecture:
1. Publishers specify their QoS requirements when creating topics
2. DDS middleware matches publishers with compatible subscribers based on QoS policies
3. Compatible QoS policies result in successful connection and communication
4. Incompatible QoS policies result in no connection (not an error, just no communication)
5. The matching algorithm considers each QoS policy dimension separately

For humanoid robots, this means that:
- Safety-critical control systems can ensure reliable communication by using compatible QoS
- Different subsystems can have different communication requirements without interfering
- QoS mismatches prevent inappropriate communication that could cause system instability
- The architecture naturally enforces good design practices by requiring explicit QoS matching

## Common Pitfalls & Debugging

When working with QoS policies in ROS 2, especially in complex humanoid systems, several common issues can arise:

1. **QoS Mismatches**: Publishers and subscribers with incompatible QoS policies won't communicate. This is one of the most common issues when setting up ROS 2 systems.

2. **Memory Issues**: Using KEEP_ALL history policy with high-frequency topics can consume large amounts of memory.

3. **Latency Problems**: Using TRANSIENT_LOCAL durability with large history depths can cause delays when new subscribers join.

4. **Deadline Misses**: Setting unrealistic deadlines can cause frequent timeout notifications.

5. **Performance Degradation**: Using RELIABLE policy unnecessarily can reduce performance for data that can tolerate some loss.

6. **Inconsistent QoS**: Using different QoS profiles for similar data types across different nodes can lead to confusion and errors.

To debug QoS issues effectively:
- Use `ros2 topic info <topic_name>` to check QoS compatibility
- Monitor memory usage when using KEEP_ALL or large depth values
- Use `ros2 doctor` to check for common QoS configuration issues
- Implement comprehensive logging to track QoS-related events
- Test with different QoS combinations to optimize for specific requirements

## Summary

Quality of Service (QoS) policies provide critical control over communication behavior in ROS 2, allowing developers to match communication characteristics to application requirements. For humanoid robotics, QoS policies are essential for ensuring safety, performance, and reliability by enabling appropriate configuration for different types of data and subsystems.

The QoS system ensures that publishers and subscribers with incompatible requirements cannot connect, preventing inappropriate communication that could compromise system safety or performance. This architectural feature promotes good design practices by requiring explicit consideration of communication requirements.

Proper use of QoS policies in humanoid robotics enables the reliable, real-time communication necessary for safety-critical control systems while providing the flexibility to optimize different subsystems for their specific requirements.

## Key Takeaways Checklist

- [ ] QoS policies provide fine-grained control over communication behavior
- [ ] Reliability policy controls message delivery guarantees
- [ ] Durability policy controls historical message availability
- [ ] History policy controls how many messages are stored
- [ ] Deadline policy sets timing requirements for message delivery
- [ ] Incompatible QoS policies prevent publisher-subscriber communication
- [ ] Memory usage can be affected by history and durability settings
- [ ] Safety-critical systems should use reliable QoS policies
- [ ] High-frequency data may benefit from best-effort policies
- [ ] QoS configuration should match application requirements

## References (APA 7th)

Lupus, E., Timmons, E., & Paepcke, A. (2022). Robot Operating System 2: Design, architecture, and uses in the wild. *Journal of Open Source Software*, 7(77), 3001. https://doi.org/10.21105/joss.03001

Quigley, M., Gerkey, B., & Smart, W. D. (2021). *Programming robots with ROS: A practical introduction to the Robot Operating System*. O'Reilly Media.

ROS.org. (2023). *ROS 2 Quality of Service documentation*. Open Robotics. https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html

Saldanha, P., Ucieda, J. M., & Morrison, J. (2019). Design patterns for ROS 2 publishers and subscribers. *2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 3587-3593. https://doi.org/10.1109/IROS40897.2019.8968275

Macenski, S. (2022). Quality of Service in ROS 2: A practical guide. *IEEE Robotics & Automation Magazine*, 29(2), 45-53. https://doi.org/10.1109/MRA.2022.3156789