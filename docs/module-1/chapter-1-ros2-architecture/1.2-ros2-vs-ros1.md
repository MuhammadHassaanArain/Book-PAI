# ROS 2 vs ROS 1: Design Philosophy and Evolution

## Learning Objectives

- Compare and contrast the fundamental design philosophies of ROS 1 and ROS 2
- Identify the key limitations of ROS 1 that led to the development of ROS 2
- Understand the architectural differences between ROS 1 and ROS 2
- Recognize the benefits of ROS 2 for real-time, safety-critical, and multi-robot applications
- Evaluate the migration considerations when transitioning from ROS 1 to ROS 2

## Conceptual Explanation

The evolution from ROS 1 to ROS 2 represents a fundamental rethinking of robotic middleware architecture to address the growing needs of commercial, industrial, and safety-critical robotic applications. While ROS 1 established the foundational concepts of distributed robotic computing with its master-based architecture, it had inherent limitations that became more apparent as robotics moved from research labs to real-world deployments.

ROS 1 utilized a centralized architecture with a master node that served as the central registry for all nodes in the system. This master-based approach simplified development and debugging in controlled environments but introduced several critical limitations: single point of failure, limited scalability for multi-robot systems, lack of security features, and challenges with real-time performance requirements.

ROS 2 addresses these limitations through a decentralized architecture built on Data Distribution Service (DDS), a vendor-neutral, open standard for real-time, high-performance messaging. This DDS-based approach provides built-in support for discovery, quality of service (QoS) policies, security, and multi-robot coordination without requiring a central master node.

The key philosophical shift from ROS 1 to ROS 2 centers on moving from a research-focused, single-robot development environment to a production-ready, multi-robot, safety-conscious architecture. ROS 1 prioritized ease of use and rapid prototyping, while ROS 2 balances ease of use with the requirements of industrial deployment, including security, real-time performance, and fault tolerance.

## Humanoid Robotics Context

For humanoid robotics, the transition from ROS 1 to ROS 2 is particularly significant. Humanoid robots operating in real-world environments require robust, secure, and reliable communication systems that can handle the complexity of multi-robot coordination, real-time control requirements, and safety considerations.

In ROS 1, the single master node could become a bottleneck in humanoid systems that often require multiple computers for perception, control, and decision-making. If the master failed, the entire robotic system would lose its ability to coordinate between components, potentially leading to unsafe conditions for the robot and its environment.

ROS 2's decentralized architecture provides several advantages for humanoid robotics:

1. **Enhanced Reliability**: Without a single point of failure, humanoid robots can maintain critical functions even if individual components fail, which is crucial for safety during locomotion and manipulation.

2. **Improved Security**: The built-in security features of DDS allow for authentication, access control, and encryption, essential for humanoid robots operating in public spaces or handling sensitive data.

3. **Better Real-time Performance**: QoS policies in ROS 2 allow for fine-grained control over message delivery, ensuring that time-critical control messages for balance and safety take priority over less critical perception data.

4. **Multi-robot Coordination**: Humanoid robots often need to coordinate with other robots, humans, or infrastructure systems. ROS 2's native support for multi-robot systems makes this coordination more robust and efficient.

5. **Scalability**: As humanoid robots become more complex with additional sensors and actuators, ROS 2's architecture scales more effectively without the limitations of a central master.

## Practical ROS 2 Example (Python)

Let's compare a simple publisher-subscriber example between ROS 1 and ROS 2 to highlight the architectural differences. This example demonstrates the improved structure and capabilities of ROS 2:

```python
# ROS 2 Publisher Example - More robust and configurable
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy


class ROS2ComparisonPublisher(Node):
    """
    A publisher node demonstrating ROS 2's improved architecture and QoS capabilities.
    This publisher shows how ROS 2 allows for more sophisticated message handling
    compared to ROS 1, which is particularly important for humanoid robotics where
    different types of data have different requirements.
    """

    def __init__(self):
        super().__init__('ros2_comparison_publisher')

        # Create a QoS profile with specific requirements for different types of data
        # This is a key difference from ROS 1 - fine-grained control over communication
        qos_profile = QoSProfile(
            depth=10,  # Number of messages to queue
            reliability=ReliabilityPolicy.RELIABLE,  # Ensure delivery
            durability=DurabilityPolicy.VOLATILE,  # Don't store for late-joining subscribers
        )

        # Create publisher with specific QoS requirements
        self.publisher_ = self.create_publisher(String, 'robot_comparison_topic', qos_profile)

        # Create timer for publishing messages
        self.timer = self.create_timer(0.5, self.publish_message)
        self.counter = 0

        self.get_logger().info('ROS 2 Comparison Publisher started')

    def publish_message(self):
        """Publish a message with timestamp and counter"""
        msg = String()
        msg.data = f'ROS 2 Message #{self.counter} - Time: {self.get_clock().now().seconds_nanoseconds()}'

        self.publisher_.publish(msg)
        self.get_logger().info(f'Published: {msg.data}')
        self.counter += 1


class ROS2ComparisonSubscriber(Node):
    """
    A subscriber node demonstrating ROS 2's improved subscription capabilities.
    The subscriber can handle different QoS configurations and provides more
    robust error handling compared to ROS 1.
    """

    def __init__(self):
        super().__init__('ros2_comparison_subscriber')

        # Create subscription with matching QoS profile
        qos_profile = QoSProfile(
            depth=10,
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
        )

        self.subscription = self.create_subscription(
            String,
            'robot_comparison_topic',
            self.listener_callback,
            qos_profile
        )

        self.subscription  # Prevent unused variable warning
        self.get_logger().info('ROS 2 Comparison Subscriber started')

    def listener_callback(self, msg):
        """Callback function to handle received messages"""
        self.get_logger().info(f'Received: {msg.data}')


def main(args=None):
    """Main function demonstrating ROS 2's improved architecture"""
    rclpy.init(args=args)

    # Create publisher and subscriber nodes
    publisher_node = ROS2ComparisonPublisher()
    subscriber_node = ROS2ComparisonSubscriber()

    # In ROS 2, we can run multiple nodes in the same process
    # or use different executors for more complex scenarios
    executor = rclpy.executors.MultiThreadedExecutor()
    executor.add_node(publisher_node)
    executor.add_node(subscriber_node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up resources properly
        publisher_node.destroy_node()
        subscriber_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

Key differences demonstrated in this example:
- QoS profiles for fine-grained control over message delivery
- Better resource management and cleanup
- Multi-threaded execution support
- More robust error handling and logging
- Improved clock and timing capabilities

## Architecture / Flow Explanation (Diagram-Referenced)

The architectural comparison between ROS 1 and ROS 2 can be visualized as follows:

```
ROS 1 Architecture:
[Node A] ----+
             |
[Node B] ----+---- [Master] ---- [Node C]
             |                   |
[Node D] ----+              [Node E]

ROS 2 Architecture:
[Node A] ----+
             |
[Node B] ----+---- DDS Middleware ---- [Node C]
             |                           |
[Node F] ----+                      [Node D]
                                        |
                                   [Node E]
```

In the ROS 1 diagram:
- All nodes must register with a central master
- If the master fails, all communication stops
- Limited control over message delivery characteristics
- Single point of failure for the entire system

In the ROS 2 diagram:
- Nodes communicate directly through DDS middleware
- No single point of failure
- QoS policies control message delivery behavior
- Nodes can join/leave without disrupting the system
- Built-in security and encryption capabilities

For humanoid robotics, this means that control systems, perception systems, and decision-making systems can operate more independently and reliably, with better fault tolerance and real-time performance.

## Common Pitfalls & Debugging

When migrating from ROS 1 to ROS 2 or when developing new ROS 2 systems, several common issues can arise:

1. **QoS Policy Conflicts**: Publishers and subscribers with incompatible QoS settings won't communicate. This is a new concept compared to ROS 1 and often causes confusion.

2. **DDS Implementation Differences**: Different DDS vendors (Fast DDS, Cyclone DDS, RTI Connext) may have subtle behavioral differences that affect performance.

3. **Domain ID Conflicts**: Multiple ROS 2 systems on the same network need different domain IDs to avoid interference.

4. **Resource Management**: Proper cleanup of nodes, publishers, and subscribers is more critical in ROS 2 for long-running systems.

5. **Clock and Time Handling**: ROS 2 introduces more sophisticated time handling which can be complex for developers used to ROS 1.

6. **Parameter Management**: Parameter handling is more sophisticated in ROS 2 but requires different patterns than ROS 1.

To debug ROS 2 systems effectively:
- Use `ros2 doctor` to check for common configuration issues
- Monitor domain IDs when running multiple systems
- Use `ros2 topic info` to check QoS compatibility
- Implement comprehensive logging to track node lifecycle
- Use `rqt_graph` to visualize the node graph and communication patterns

## Summary

The transition from ROS 1 to ROS 2 represents a fundamental architectural evolution designed to address the limitations of the original system while maintaining its core strengths for robotic development. ROS 2's DDS-based architecture provides enhanced reliability, security, real-time performance, and multi-robot capabilities essential for modern robotics applications, particularly humanoid robots operating in complex environments.

The key improvements in ROS 2 include decentralized communication eliminating single points of failure, Quality of Service policies for fine-grained control over message delivery, built-in security features for safe operation in real-world environments, and better support for real-time systems critical for humanoid robot control.

While the learning curve for ROS 2 is steeper than ROS 1 due to these additional capabilities, the resulting systems are more robust, secure, and suitable for production deployment in commercial and industrial applications.

## Key Takeaways Checklist

- [ ] ROS 1 used a centralized master-based architecture with single point of failure
- [ ] ROS 2 uses a decentralized DDS-based architecture for improved reliability
- [ ] QoS policies in ROS 2 provide fine-grained control over message delivery
- [ ] Security features are built into ROS 2 through DDS
- [ ] Real-time performance is significantly improved in ROS 2
- [ ] Multi-robot systems are better supported in ROS 2
- [ ] Migration from ROS 1 requires understanding of QoS and domain IDs
- [ ] Resource management is more critical in ROS 2 systems
- [ ] ROS 2 is designed for production deployment, not just research
- [ ] The architecture supports safety-critical applications like humanoid robots

## References (APA 7th)

Macenski, S., & Pham, Q. C. (2022). ROS 2 design: Improvements and trade-offs. *IEEE Robotics & Automation Magazine*, 29(1), 112-124. https://doi.org/10.1109/MRA.2021.3131651

Quigley, M., Gerkey, B., & Smart, W. D. (2021). *Programming robots with ROS: A practical introduction to the Robot Operating System*. O'Reilly Media.

ROS.org. (2023). *ROS 1 vs ROS 2: Migration guide*. Open Robotics. https://docs.ros.org/en/rolling/Releases/Release-Foxy-Fitzroy.html

Saldanha, P., Timmons, E., & Paepcke, A. (2022). Comparative analysis of ROS 1 and ROS 2 for industrial applications. *2022 IEEE International Conference on Robotics and Automation (ICRA)*, 4567-4573. https://doi.org/10.1109/ICRA46639.2022.9811890

Object Management Group. (2015). *Data Distribution Service (DDS) version 1.4*. OMG. https://www.omg.org/spec/DDS/1.4/