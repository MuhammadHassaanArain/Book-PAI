# 4.3 Importing Robots and Environments into Unity

## Introduction

Importing robots and environments into Unity is a critical step in creating realistic simulation and visualization systems for robotics applications. This process involves converting models from various formats (URDF, SDF, CAD, etc.) into Unity's format while preserving physical properties, visual appearance, and kinematic relationships. This chapter covers the complete workflow for importing robotic models and environments, including file format considerations, conversion tools, and best practices for maintaining accuracy and performance.

## File Format Considerations

### Robot Description Formats

Unity does not natively support robotics-specific formats like URDF or SDF, so conversion is necessary:

#### URDF (Unified Robot Description Format)
- **Structure**: XML-based format describing robot kinematics, dynamics, and visual properties
- **Components**: Links, joints, materials, and collision geometry
- **Conversion Requirements**: Transform to Unity GameObject hierarchy with proper physics

#### SDF (Simulation Description Format)
- **Structure**: XML-based format used by Gazebo and Ignition
- **Components**: Models, worlds, physics properties, and plugins
- **Conversion Requirements**: Extract visual and collision geometry for Unity

#### COLLADA (.dae)
- **Structure**: XML-based interchange format for 3D assets
- **Components**: Geometry, materials, animations, and scene hierarchy
- **Unity Support**: Native import support with good material preservation

#### FBX (.fbx)
- **Structure**: Proprietary format with excellent 3D asset support
- **Components**: Geometry, materials, animations, and rigging
- **Unity Support**: Excellent native support, recommended for robotics assets

### Environment Formats

For environments, Unity supports various formats:

#### OBJ (.obj)
- Simple geometry format
- Good for static environments
- Limited material support

#### FBX (.fbx)
- Best for complex environments with animations
- Full material and lighting support
- Animation support

#### GLTF (.gltf/.glb)
- Modern, efficient format
- Good for web-based robotics applications
- Excellent material support

## Robot Model Import Pipeline

### Pre-Import Preparation

Before importing robot models into Unity, several preparation steps ensure optimal results:

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Xml;

public class URDFPreprocessor : MonoBehaviour
{
    [Header("URDF Processing")]
    public TextAsset urdfFile;
    public bool optimizeGeometry = true;
    public bool convertUnitsToMeters = true;
    public float unitScaleFactor = 1.0f; // Default: 1 meter = 1 Unity unit

    [Header("Import Settings")]
    public bool importVisual = true;
    public bool importCollision = true;
    public bool importInertial = true;
    public bool setupPhysics = true;

    public void ProcessURDF()
    {
        if (urdfFile == null)
        {
            Debug.LogError("No URDF file assigned");
            return;
        }

        XmlDocument urdfDoc = new XmlDocument();
        urdfDoc.LoadXml(urdfFile.text);

        ProcessRobotStructure(urdfDoc);
        ValidateModel();
    }

    void ProcessRobotStructure(XmlDocument urdfDoc)
    {
        XmlNode robotNode = urdfDoc.SelectSingleNode("//robot");
        if (robotNode == null)
        {
            Debug.LogError("No robot node found in URDF");
            return;
        }

        string robotName = robotNode.Attributes["name"]?.Value ?? "Robot";
        Debug.Log($"Processing robot: {robotName}");

        // Process links
        XmlNodeList linkNodes = urdfDoc.SelectNodes("//link");
        foreach (XmlNode linkNode in linkNodes)
        {
            ProcessLink(linkNode);
        }

        // Process joints
        XmlNodeList jointNodes = urdfDoc.SelectNodes("//joint");
        foreach (XmlNode jointNode in jointNodes)
        {
            ProcessJoint(jointNode);
        }
    }

    void ProcessLink(XmlNode linkNode)
    {
        string linkName = linkNode.Attributes["name"]?.Value ?? "unnamed_link";
        Debug.Log($"Processing link: {linkName}");

        // Process visual elements
        if (importVisual)
        {
            XmlNode visualNode = linkNode.SelectSingleNode("visual");
            if (visualNode != null)
            {
                ProcessVisual(visualNode, linkName);
            }
        }

        // Process collision elements
        if (importCollision)
        {
            XmlNode collisionNode = linkNode.SelectSingleNode("collision");
            if (collisionNode != null)
            {
                ProcessCollision(collisionNode, linkName);
            }
        }

        // Process inertial elements
        if (importInertial)
        {
            XmlNode inertialNode = linkNode.SelectSingleNode("inertial");
            if (inertialNode != null)
            {
                ProcessInertial(inertialNode, linkName);
            }
        }
    }

    void ProcessJoint(XmlNode jointNode)
    {
        string jointName = jointNode.Attributes["name"]?.Value ?? "unnamed_joint";
        string jointType = jointNode.SelectSingleNode("type")?.InnerText ?? "fixed";

        Debug.Log($"Processing joint: {jointName}, type: {jointType}");

        // Extract joint properties
        XmlNode parentLink = jointNode.SelectSingleNode("parent");
        XmlNode childLink = jointNode.SelectSingleNode("child");
        XmlNode origin = jointNode.SelectSingleNode("origin");

        string parentName = parentLink?.Attributes["link"]?.Value ?? "";
        string childName = childLink?.Attributes["link"]?.Value ?? "";

        if (origin != null)
        {
            string xyzStr = origin.Attributes["xyz"]?.Value ?? "0 0 0";
            string rpyStr = origin.Attributes["rpy"]?.Value ?? "0 0 0";

            string[] xyz = xyzStr.Split(' ');
            string[] rpy = rpyStr.Split(' ');

            Vector3 position = new Vector3(
                float.Parse(xyz[0]),
                float.Parse(xyz[1]),
                float.Parse(xyz[2])
            );

            Vector3 rotation = new Vector3(
                float.Parse(rpy[0]),
                float.Parse(rpy[1]),
                float.Parse(rpy[2])
            );

            // Store joint information for later processing
            StoreJointInfo(jointName, jointType, parentName, childName, position, rotation);
        }
    }

    void ProcessVisual(XmlNode visualNode, string linkName)
    {
        // Extract visual geometry
        XmlNode geometryNode = visualNode.SelectSingleNode("geometry");
        if (geometryNode != null)
        {
            ExtractGeometry(geometryNode, linkName, "visual");
        }

        // Extract material information
        XmlNode materialNode = visualNode.SelectSingleNode("material");
        if (materialNode != null)
        {
            ExtractMaterial(materialNode, linkName);
        }
    }

    void ProcessCollision(XmlNode collisionNode, string linkName)
    {
        // Extract collision geometry
        XmlNode geometryNode = collisionNode.SelectSingleNode("geometry");
        if (geometryNode != null)
        {
            ExtractGeometry(geometryNode, linkName, "collision");
        }
    }

    void ProcessInertial(XmlNode inertialNode, string linkName)
    {
        // Extract mass, inertia, and center of mass
        XmlNode massNode = inertialNode.SelectSingleNode("mass");
        XmlNode inertiaNode = inertialNode.SelectSingleNode("inertia");

        if (massNode != null)
        {
            float mass = float.Parse(massNode.Attributes["value"]?.Value ?? "0");
            Debug.Log($"Link {linkName} mass: {mass}");
        }

        if (inertiaNode != null)
        {
            float ixx = float.Parse(inertiaNode.Attributes["ixx"]?.Value ?? "0");
            float ixy = float.Parse(inertiaNode.Attributes["ixy"]?.Value ?? "0");
            float ixz = float.Parse(inertiaNode.Attributes["ixz"]?.Value ?? "0");
            float iyy = float.Parse(inertiaNode.Attributes["iyy"]?.Value ?? "0");
            float iyz = float.Parse(inertiaNode.Attributes["iyz"]?.Value ?? "0");
            float izz = float.Parse(inertiaNode.Attributes["izz"]?.Value ?? "0");

            Debug.Log($"Link {linkName} inertia: [{ixx}, {ixy}, {ixz}; {ixy}, {iyy}, {iyz}; {ixz}, {iyz}, {izz}]");
        }
    }

    void ExtractGeometry(XmlNode geometryNode, string linkName, string geometryType)
    {
        XmlNode meshNode = geometryNode.SelectSingleNode("mesh");
        XmlNode boxNode = geometryNode.SelectSingleNode("box");
        XmlNode cylinderNode = geometryNode.SelectSingleNode("cylinder");
        XmlNode sphereNode = geometryNode.SelectSingleNode("sphere");

        if (meshNode != null)
        {
            string filename = meshNode.Attributes["filename"]?.Value ?? "";
            float scale = 1.0f;

            XmlNode scaleNode = meshNode.Attributes["scale"];
            if (scaleNode != null)
            {
                string[] scaleValues = scaleNode.Value.Split(' ');
                if (scaleValues.Length >= 3)
                {
                    scale = float.Parse(scaleValues[0]); // Use X scale as uniform scale
                }
            }

            StoreGeometryInfo(linkName, geometryType, "mesh", filename, scale);
        }
        else if (boxNode != null)
        {
            string sizeStr = boxNode.Attributes["size"]?.Value ?? "1 1 1";
            string[] sizeValues = sizeStr.Split(' ');
            Vector3 size = new Vector3(
                float.Parse(sizeValues[0]),
                float.Parse(sizeValues[1]),
                float.Parse(sizeValues[2])
            );

            StoreGeometryInfo(linkName, geometryType, "box", size.ToString(), 1.0f);
        }
        // Similar processing for cylinder and sphere...
    }

    void ExtractMaterial(XmlNode materialNode, string linkName)
    {
        string materialName = materialNode.Attributes["name"]?.Value ?? "";
        XmlNode colorNode = materialNode.SelectSingleNode("color");

        if (colorNode != null)
        {
            string rgbaStr = colorNode.Attributes["rgba"]?.Value ?? "0.5 0.5 0.5 1";
            string[] rgbaValues = rgbaStr.Split(' ');

            Color color = new Color(
                float.Parse(rgbaValues[0]),
                float.Parse(rgbaValues[1]),
                float.Parse(rgbaValues[2]),
                float.Parse(rgbaValues[3])
            );

            StoreMaterialInfo(linkName, materialName, color);
        }
    }

    void StoreJointInfo(string name, string type, string parent, string child, Vector3 position, Vector3 rotation)
    {
        // Store joint information for later Unity scene construction
        Debug.Log($"Storing joint: {name}, type: {type}, parent: {parent}, child: {child}");
    }

    void StoreGeometryInfo(string linkName, string geometryType, string geometrySubtype, string filename, float scale)
    {
        // Store geometry information for Unity import
        Debug.Log($"Storing geometry for {linkName}: {geometryType} {geometrySubtype}");
    }

    void StoreMaterialInfo(string linkName, string materialName, Color color)
    {
        // Store material information for Unity import
        Debug.Log($"Storing material for {linkName}: {materialName}");
    }

    void ValidateModel()
    {
        // Validate that all required elements are present
        Debug.Log("Model validation complete");
    }
}
```

### Unit Conversion and Scaling

Unity uses meters as its default unit system, but models may be in different units:

```csharp
using UnityEngine;

public class UnitConverter : MonoBehaviour
{
    [Header("Unit Conversion")]
    public float sourceUnitScale = 1.0f; // Scale factor from source units to meters
    public string sourceUnit = "meters"; // Source unit system
    public string targetUnit = "unity_units"; // Target unit system (Unity meters)

    // Common conversion factors to meters
    private Dictionary<string, float> unitConversions = new Dictionary<string, float>
    {
        {"meters", 1.0f},
        {"centimeters", 0.01f},
        {"millimeters", 0.001f},
        {"inches", 0.0254f},
        {"feet", 0.3048f},
        {"unity_units", 1.0f} // Unity units are equivalent to meters
    };

    public Vector3 ConvertPosition(Vector3 position, string fromUnit, string toUnit = "meters")
    {
        float fromScale = GetUnitScale(fromUnit);
        float toScale = GetUnitScale(toUnit);

        // Convert to meters first, then to target unit
        Vector3 meters = position * fromScale;
        Vector3 result = meters / toScale;

        return result;
    }

    public float ConvertScale(float scale, string fromUnit, string toUnit = "meters")
    {
        float fromScale = GetUnitScale(fromUnit);
        float toScale = GetUnitScale(toUnit);

        return scale * fromScale / toScale;
    }

    public Vector3 ConvertScaleVector(Vector3 scale, string fromUnit, string toUnit = "meters")
    {
        return new Vector3(
            ConvertScale(scale.x, fromUnit, toUnit),
            ConvertScale(scale.y, fromUnit, toUnit),
            ConvertScale(scale.z, fromUnit, toUnit)
        );
    }

    float GetUnitScale(string unit)
    {
        if (unitConversions.ContainsKey(unit.ToLower()))
        {
            return unitConversions[unit.ToLower()];
        }
        else
        {
            Debug.LogWarning($"Unknown unit '{unit}', using 1.0 scale");
            return 1.0f;
        }
    }

    public void ApplyConversionToGameObject(GameObject obj, string sourceUnit)
    {
        // Apply unit conversion to all transforms in the hierarchy
        ApplyConversionRecursive(obj.transform, sourceUnit);
    }

    void ApplyConversionRecursive(Transform transform, string sourceUnit)
    {
        // Convert position
        transform.position = ConvertPosition(transform.position, sourceUnit);

        // Scale remains the same (relative scaling)
        // Rotation is unit-independent

        // Process children
        foreach (Transform child in transform)
        {
            ApplyConversionRecursive(child, sourceUnit);
        }
    }
}
```

## Import Tools and Workflows

### Automated Import Pipeline

Creating an automated pipeline for importing robot models:

```csharp
using UnityEngine;
using System.Collections;
using System.IO;
using System.Collections.Generic;

public class RobotImportPipeline : MonoBehaviour
{
    [Header("Import Configuration")]
    public string robotModelPath = "Assets/Robots/";
    public string environmentPath = "Assets/Environments/";
    public bool autoImportOnStart = false;

    [Header("Import Settings")]
    public bool optimizeMeshes = true;
    public bool setupPhysics = true;
    public bool createColliders = true;
    public bool setupJoints = true;
    public bool assignMaterials = true;

    [Header("Conversion Settings")]
    public float meshOptimizationThreshold = 0.01f;
    public int maxTriangleCount = 100000;
    public bool useLOD = true;

    private Dictionary<string, GameObject> importedModels = new Dictionary<string, GameObject>();

    void Start()
    {
        if (autoImportOnStart)
        {
            StartCoroutine(AutoImportProcess());
        }
    }

    IEnumerator AutoImportProcess()
    {
        yield return ImportRobotModels();
        yield return ImportEnvironmentModels();
        yield return ProcessImportedModels();
    }

    IEnumerator ImportRobotModels()
    {
        Debug.Log("Starting robot model import...");

        // Get all robot model files
        string[] robotFiles = Directory.GetFiles(robotModelPath, "*.fbx", SearchOption.AllDirectories);

        foreach (string robotFile in robotFiles)
        {
            string modelName = Path.GetFileNameWithoutExtension(robotFile);
            Debug.Log($"Importing robot: {modelName}");

            // Import the model
            GameObject robotModel = ImportModel(robotFile);
            if (robotModel != null)
            {
                importedModels[modelName] = robotModel;
                ProcessRobotModel(robotModel, modelName);
            }

            yield return null; // Allow other processes to run
        }

        Debug.Log($"Imported {importedModels.Count} robot models");
    }

    IEnumerator ImportEnvironmentModels()
    {
        Debug.Log("Starting environment model import...");

        // Get all environment model files
        string[] envFiles = Directory.GetFiles(environmentPath, "*.fbx", SearchOption.AllDirectories);

        foreach (string envFile in envFiles)
        {
            string envName = Path.GetFileNameWithoutExtension(envFile);
            Debug.Log($"Importing environment: {envName}");

            GameObject envModel = ImportModel(envFile);
            if (envModel != null)
            {
                ProcessEnvironmentModel(envModel, envName);
            }

            yield return null; // Allow other processes to run
        }

        Debug.Log("Environment import complete");
    }

    GameObject ImportModel(string filePath)
    {
        // In a real implementation, this would use Unity's AssetDatabase
        // For now, we'll simulate the import process
        TextAsset modelText = Resources.Load<TextAsset>(Path.GetFileNameWithoutExtension(filePath));

        if (modelText != null)
        {
            // Create a simple cube as placeholder
            GameObject model = GameObject.CreatePrimitive(PrimitiveType.Cube);
            model.name = Path.GetFileNameWithoutExtension(filePath);
            return model;
        }

        return null;
    }

    void ProcessRobotModel(GameObject robotModel, string modelName)
    {
        // Apply robot-specific processing
        if (optimizeMeshes)
        {
            OptimizeRobotMeshes(robotModel);
        }

        if (setupPhysics)
        {
            SetupRobotPhysics(robotModel);
        }

        if (createColliders)
        {
            CreateRobotColliders(robotModel);
        }

        if (setupJoints)
        {
            SetupRobotJoints(robotModel);
        }

        if (assignMaterials)
        {
            AssignRobotMaterials(robotModel);
        }

        // Position robot appropriately
        robotModel.transform.position = new Vector3(0, 0, 0);
        robotModel.transform.localScale = Vector3.one;
    }

    void ProcessEnvironmentModel(GameObject envModel, string envName)
    {
        // Apply environment-specific processing
        if (optimizeMeshes)
        {
            OptimizeEnvironmentMeshes(envModel);
        }

        if (createColliders)
        {
            CreateEnvironmentColliders(envModel);
        }

        if (assignMaterials)
        {
            AssignEnvironmentMaterials(envModel);
        }

        // Position environment appropriately
        envModel.transform.position = new Vector3(0, 0, 0);
        envModel.transform.localScale = Vector3.one;
    }

    IEnumerator ProcessImportedModels()
    {
        Debug.Log("Processing imported models...");

        foreach (var kvp in importedModels)
        {
            ProcessFinalModel(kvp.Value, kvp.Key);
            yield return null; // Allow other processes to run
        }

        Debug.Log("Model processing complete");
    }

    void ProcessFinalModel(GameObject model, string modelName)
    {
        // Final processing steps
        if (useLOD)
        {
            SetupLODForModel(model);
        }

        // Add any additional components
        model.AddComponent<RobotComponentManager>();
    }

    void OptimizeRobotMeshes(GameObject robot)
    {
        // Optimize meshes for performance
        MeshFilter[] meshFilters = robot.GetComponentsInChildren<MeshFilter>();

        foreach (MeshFilter filter in meshFilters)
        {
            if (filter.sharedMesh != null)
            {
                Mesh mesh = filter.sharedMesh;

                if (mesh.triangles.Length > maxTriangleCount)
                {
                    Debug.LogWarning($"Mesh {filter.name} has {mesh.triangles.Length} triangles, which exceeds limit of {maxTriangleCount}");
                    // In a real implementation, you might use Unity's mesh simplification tools
                }
            }
        }
    }

    void SetupRobotPhysics(GameObject robot)
    {
        // Add Rigidbody to each link
        Transform[] links = robot.GetComponentsInChildren<Transform>();
        foreach (Transform link in links)
        {
            if (link != robot.transform) // Skip root
            {
                if (link.GetComponent<Rigidbody>() == null)
                {
                    Rigidbody rb = link.gameObject.AddComponent<Rigidbody>();
                    rb.mass = 1.0f; // Default mass, should be set based on URDF
                    rb.useGravity = true;
                    rb.drag = 0.1f;
                    rb.angularDrag = 0.05f;
                }
            }
        }
    }

    void CreateRobotColliders(GameObject robot)
    {
        // Add colliders to each link
        Transform[] links = robot.GetComponentsInChildren<Transform>();
        foreach (Transform link in links)
        {
            if (link != robot.transform) // Skip root
            {
                if (link.GetComponent<Collider>() == null)
                {
                    // Add appropriate collider based on link shape
                    // This would be determined from URDF collision geometry
                    BoxCollider collider = link.gameObject.AddComponent<BoxCollider>();
                    collider.center = Vector3.zero;
                    collider.size = Vector3.one * 0.1f; // Default size
                }
            }
        }
    }

    void SetupRobotJoints(GameObject robot)
    {
        // Setup joints between links
        // This would be based on URDF joint definitions
        ConfigurableJoint[] joints = robot.GetComponentsInChildren<ConfigurableJoint>();
        foreach (ConfigurableJoint joint in joints)
        {
            ConfigureJoint(joint);
        }
    }

    void ConfigureJoint(ConfigurableJoint joint)
    {
        // Configure joint properties
        joint.xMotion = ConfigurableJointMotion.Free;
        joint.yMotion = ConfigurableJointMotion.Free;
        joint.zMotion = ConfigurableJointMotion.Free;
        joint.angularXMotion = ConfigurableJointMotion.Free;
        joint.angularYMotion = ConfigurableJointMotion.Free;
        joint.angularZMotion = ConfigurableJointMotion.Free;
    }

    void AssignRobotMaterials(GameObject robot)
    {
        // Assign appropriate materials to robot parts
        Renderer[] renderers = robot.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            // Assign default robot material
            if (renderer.sharedMaterials.Length == 0)
            {
                Material defaultMaterial = new Material(Shader.Find("Standard"));
                defaultMaterial.color = Color.gray;
                renderer.sharedMaterials = new Material[] { defaultMaterial };
            }
        }
    }

    void OptimizeEnvironmentMeshes(GameObject env)
    {
        // Similar optimization for environment meshes
        MeshFilter[] meshFilters = env.GetComponentsInChildren<MeshFilter>();

        foreach (MeshFilter filter in meshFilters)
        {
            if (filter.sharedMesh != null)
            {
                // Apply environment-specific optimizations
            }
        }
    }

    void CreateEnvironmentColliders(GameObject env)
    {
        // Add colliders for environment objects
        Transform[] objects = env.GetComponentsInChildren<Transform>();
        foreach (Transform obj in objects)
        {
            if (obj != env.transform) // Skip root
            {
                if (obj.GetComponent<Collider>() == null)
                {
                    // Add appropriate collider
                    BoxCollider collider = obj.gameObject.AddComponent<BoxCollider>();
                    collider.isTrigger = false; // Not a trigger
                }
            }
        }
    }

    void AssignEnvironmentMaterials(GameObject env)
    {
        // Assign environment-specific materials
        Renderer[] renderers = env.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            // Assign default environment materials
        }
    }

    void SetupLODForModel(GameObject model)
    {
        // Setup Level of Detail for the model
        LODGroup lodGroup = model.GetComponent<LODGroup>();
        if (lodGroup == null)
        {
            lodGroup = model.AddComponent<LODGroup>();
        }

        // Configure LOD levels
        LOD[] lods = new LOD[3];
        // This would be configured based on the model's complexity
    }

    public GameObject GetImportedModel(string modelName)
    {
        if (importedModels.ContainsKey(modelName))
        {
            return importedModels[modelName];
        }
        return null;
    }
}
```

## Environment Import Process

### Static Environment Assets

Importing static environments requires different considerations than robots:

```csharp
using UnityEngine;
using System.Collections.Generic;

public class EnvironmentImportManager : MonoBehaviour
{
    [Header("Environment Import Settings")]
    public bool optimizeForPerformance = true;
    public bool createOcclusionCulling = true;
    public bool setupLighting = true;
    public bool generateProbes = true;

    [Header("Terrain Import Settings")]
    public bool importTerrain = true;
    public bool optimizeTerrain = true;
    public float terrainDetailDistance = 50f;

    [Header("Prefab Configuration")]
    public GameObject[] staticPrefabs;
    public Material[] environmentMaterials;

    public void ImportEnvironment(string environmentPath)
    {
        // Load environment file
        GameObject environment = LoadEnvironmentFile(environmentPath);
        if (environment != null)
        {
            ProcessEnvironment(environment);
        }
    }

    GameObject LoadEnvironmentFile(string path)
    {
        // In a real implementation, this would load the environment file
        // For now, we'll create a simple environment
        GameObject env = new GameObject("Environment");

        // Create a simple floor
        GameObject floor = GameObject.CreatePrimitive(PrimitiveType.Plane);
        floor.name = "Floor";
        floor.transform.SetParent(env.transform);
        floor.transform.localScale = new Vector3(10, 1, 10); // 10x10 plane

        // Add a few obstacles
        for (int i = 0; i < 5; i++)
        {
            GameObject obstacle = GameObject.CreatePrimitive(PrimitiveType.Cube);
            obstacle.name = $"Obstacle_{i}";
            obstacle.transform.SetParent(env.transform);
            obstacle.transform.position = new Vector3(
                Random.Range(-8f, 8f),
                0.5f,
                Random.Range(-8f, 8f)
            );
            obstacle.transform.localScale = new Vector3(1, 1, 1);
        }

        return env;
    }

    void ProcessEnvironment(GameObject environment)
    {
        if (optimizeForPerformance)
        {
            OptimizeEnvironmentPerformance(environment);
        }

        if (createOcclusionCulling)
        {
            SetupOcclusionCulling(environment);
        }

        if (setupLighting)
        {
            SetupEnvironmentLighting(environment);
        }

        if (generateProbes)
        {
            GenerateLightProbes(environment);
        }

        if (importTerrain)
        {
            ImportTerrainData(environment);
        }

        SetupEnvironmentColliders(environment);
        AssignEnvironmentMaterials(environment);
    }

    void OptimizeEnvironmentPerformance(GameObject environment)
    {
        // Optimize environment for performance
        MeshFilter[] meshFilters = environment.GetComponentsInChildren<MeshFilter>();
        foreach (MeshFilter filter in meshFilters)
        {
            OptimizeMesh(filter.sharedMesh);
        }

        // Combine static meshes where possible
        CombineStaticMeshes(environment);
    }

    void OptimizeMesh(Mesh mesh)
    {
        if (mesh != null)
        {
            // In a real implementation, you might reduce polygon count
            // or optimize vertex layout
        }
    }

    void CombineStaticMeshes(GameObject environment)
    {
        // Combine static meshes to reduce draw calls
        StaticBatchingUtility.Combine(environment);
    }

    void SetupOcclusionCulling(GameObject environment)
    {
        // Setup occlusion culling for the environment
        // This typically involves building occlusion culling data in the editor
        Renderer[] renderers = environment.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            renderer.preserveUVs = false;
            renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
        }
    }

    void SetupEnvironmentLighting(GameObject environment)
    {
        // Setup lighting for the environment
        Light[] lights = environment.GetComponentsInChildren<Light>();
        foreach (Light light in lights)
        {
            ConfigureEnvironmentLight(light);
        }

        // Add default lighting if none exists
        if (lights.Length == 0)
        {
            CreateDefaultEnvironmentLighting(environment);
        }
    }

    void ConfigureEnvironmentLight(Light light)
    {
        // Configure light properties for environment
        light.bounceIntensity = 1f;
        light.shadowBias = 0.05f;
        light.shadowNormalBias = 0.4f;
        light.shadowNearPlane = 0.2f;
    }

    void CreateDefaultEnvironmentLighting(GameObject environment)
    {
        // Create default lighting setup
        GameObject directionalLight = new GameObject("Directional Light");
        directionalLight.transform.SetParent(environment.transform);
        directionalLight.transform.position = new Vector3(0, 10, 0);
        directionalLight.transform.rotation = Quaternion.Euler(50, -30, 0);

        Light lightComponent = directionalLight.AddComponent<Light>();
        lightComponent.type = LightType.Directional;
        lightComponent.color = Color.white;
        lightComponent.intensity = 1f;
        lightComponent.shadows = LightShadows.Soft;
    }

    void GenerateLightProbes(GameObject environment)
    {
        // Generate light probe proxies for dynamic objects
        Renderer[] renderers = environment.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            if (renderer.GetComponent<LightProbeProxyVolume>() == null)
            {
                LightProbeProxyVolume probeVolume = renderer.gameObject.AddComponent<LightProbeProxyVolume>();
                probeVolume.boundingBoxMode = LightProbeProxyVolume.BoundingBoxMode.AutomaticLocal;
            }
        }
    }

    void ImportTerrainData(GameObject environment)
    {
        // Import terrain data if available
        if (optimizeTerrain)
        {
            OptimizeTerrainSettings(environment);
        }
    }

    void OptimizeTerrainSettings(GameObject environment)
    {
        Terrain[] terrains = environment.GetComponentsInChildren<Terrain>();
        foreach (Terrain terrain in terrains)
        {
            terrain.detailObjectDistance = terrainDetailDistance;
            terrain.treeDistance = terrainDetailDistance * 2;
            terrain.heightmapPixelError = 5;
            terrain.basemapDistance = 1000;
        }
    }

    void SetupEnvironmentColliders(GameObject environment)
    {
        // Ensure all static objects have colliders
        Transform[] transforms = environment.GetComponentsInChildren<Transform>();
        foreach (Transform t in transforms)
        {
            if (t != environment.transform && t.GetComponent<Collider>() == null)
            {
                // Add appropriate collider
                if (t.name.ToLower().Contains("floor") || t.name.ToLower().Contains("plane"))
                {
                    t.gameObject.AddComponent<BoxCollider>();
                }
                else
                {
                    t.gameObject.AddComponent<MeshCollider>();
                }
            }
        }
    }

    void AssignEnvironmentMaterials(GameObject environment)
    {
        // Assign appropriate materials to environment objects
        Renderer[] renderers = environment.GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            if (environmentMaterials.Length > 0)
            {
                // Assign materials based on object type or name
                string objName = renderer.name.ToLower();

                if (objName.Contains("floor") || objName.Contains("ground"))
                {
                    renderer.material = environmentMaterials[0]; // Ground material
                }
                else if (objName.Contains("wall"))
                {
                    renderer.material = environmentMaterials.Length > 1 ? environmentMaterials[1] : environmentMaterials[0];
                }
                else
                {
                    renderer.material = environmentMaterials[0]; // Default material
                }
            }
        }
    }
}
```

## Material and Texture Handling

### Material Conversion and Optimization

Proper material handling is crucial for realistic visualization:

```csharp
using UnityEngine;
using System.Collections.Generic;

public class MaterialConverter : MonoBehaviour
{
    [Header("Material Conversion Settings")]
    public Shader defaultRobotShader = null;
    public Shader defaultEnvironmentShader = null;
    public Texture2D defaultNormalMap = null;
    public Texture2D defaultOcclusionMap = null;

    [Header("Material Properties")]
    public float metallicDefault = 0.0f;
    public float smoothnessDefault = 0.5f;
    public float roughnessDefault = 0.5f;

    private Dictionary<string, Material> materialCache = new Dictionary<string, Material>();

    void Start()
    {
        if (defaultRobotShader == null)
            defaultRobotShader = Shader.Find("Standard");
        if (defaultEnvironmentShader == null)
            defaultEnvironmentShader = Shader.Find("Standard");
    }

    public Material CreateRobotMaterial(string materialName, Color baseColor)
    {
        if (materialCache.ContainsKey(materialName))
        {
            return materialCache[materialName];
        }

        Material material = new Material(defaultRobotShader);
        material.name = materialName;

        material.color = baseColor;
        material.SetColor("_Color", baseColor);
        material.SetFloat("_Metallic", metallicDefault);
        material.SetFloat("_Smoothness", smoothnessDefault);

        materialCache[materialName] = material;
        return material;
    }

    public Material CreateEnvironmentMaterial(string materialName, Color baseColor)
    {
        if (materialCache.ContainsKey(materialName))
        {
            return materialCache[materialName];
        }

        Material material = new Material(defaultEnvironmentShader);
        material.name = materialName;

        material.color = baseColor;
        material.SetColor("_Color", baseColor);
        material.SetFloat("_Metallic", metallicDefault * 0.5f); // Less metallic for environment
        material.SetFloat("_Smoothness", smoothnessDefault * 0.7f); // Less smooth for environment

        materialCache[materialName] = material;
        return material;
    }

    public void ApplyMaterialToGameObject(GameObject obj, Material material)
    {
        Renderer renderer = obj.GetComponent<Renderer>();
        if (renderer != null)
        {
            renderer.sharedMaterial = material;
        }
        else
        {
            // Apply to all child renderers
            Renderer[] renderers = obj.GetComponentsInChildren<Renderer>();
            foreach (Renderer r in renderers)
            {
                r.sharedMaterial = material;
            }
        }
    }

    public void ConvertURDFMaterial(XmlNode materialNode, GameObject targetObject)
    {
        if (materialNode == null) return;

        string materialName = materialNode.Attributes["name"]?.Value ?? targetObject.name + "_material";

        XmlNode colorNode = materialNode.SelectSingleNode("color");
        if (colorNode != null)
        {
            string rgbaStr = colorNode.Attributes["rgba"]?.Value ?? "0.5 0.5 0.5 1";
            string[] rgbaValues = rgbaStr.Split(' ');

            Color color = new Color(
                float.Parse(rgbaValues[0]),
                float.Parse(rgbaValues[1]),
                float.Parse(rgbaValues[2]),
                float.Parse(rgbaValues[3])
            );

            Material material = CreateRobotMaterial(materialName, color);
            ApplyMaterialToGameObject(targetObject, material);
        }
    }

    public void OptimizeMaterialsForPerformance()
    {
        // Optimize all materials in the scene for performance
        Material[] allMaterials = Resources.FindObjectsOfTypeAll<Material>();

        foreach (Material mat in allMaterials)
        {
            if (mat.shader.name.Contains("Standard"))
            {
                // Simplify materials where possible
                mat.SetFloat("_Metallic", Mathf.Clamp01(mat.GetFloat("_Metallic")));
                mat.SetFloat("_Smoothness", Mathf.Clamp01(mat.GetFloat("_Smoothness")));

                // Remove unnecessary textures
                if (mat.GetTexture("_BumpMap") == null)
                    mat.SetTexture("_BumpMap", Texture2D.blackTexture);
            }
        }
    }

    public void SetupMaterialProperties(GameObject robot)
    {
        // Setup material properties for all robot parts
        Renderer[] renderers = robot.GetComponentsInChildren<Renderer>();

        foreach (Renderer renderer in renderers)
        {
            Material[] materials = renderer.sharedMaterials;

            for (int i = 0; i < materials.Length; i++)
            {
                Material mat = materials[i];

                // Ensure material has proper properties
                if (!mat.HasProperty("_Metallic"))
                    mat.SetFloat("_Metallic", metallicDefault);
                if (!mat.HasProperty("_Smoothness"))
                    mat.SetFloat("_Smoothness", smoothnessDefault);

                // Set appropriate render queue for transparency
                if (mat.color.a < 1.0f)
                {
                    mat.renderQueue = (int)UnityEngine.Rendering.RenderQueue.Transparent;
                }
            }

            renderer.sharedMaterials = materials;
        }
    }
}
```

## Best Practices for Asset Import

### 1. Pre-Processing Optimization

Optimize models before import to reduce processing time and improve performance:

- Reduce polygon count where possible
- Combine similar materials
- Use appropriate texture resolutions
- Remove unnecessary geometry

### 2. Hierarchical Organization

Maintain proper hierarchy to preserve kinematic relationships:

- Preserve joint parent-child relationships
- Maintain coordinate system conventions
- Use meaningful naming conventions

### 3. Physics Configuration

Ensure physics properties match real-world specifications:

- Set appropriate mass values from URDF
- Configure collision geometry properly
- Apply correct friction and bounciness values

### 4. Performance Considerations

Balance visual fidelity with performance requirements:

- Use LOD systems for complex models
- Optimize draw calls through batching
- Consider occlusion culling for large environments

### 5. Validation and Testing

Validate imported assets thoroughly:

- Check kinematic relationships
- Verify collision detection
- Test physics behavior
- Validate visual appearance

## Common Import Issues and Solutions

### Scale and Unit Problems

- **Issue**: Models appear too large or small
- **Solution**: Verify unit conversion and apply appropriate scaling

### Joint Configuration Issues

- **Issue**: Joints don't behave as expected
- **Solution**: Verify joint limits and types match URDF specifications

### Material and Texture Problems

- **Issue**: Materials don't appear correctly
- **Solution**: Check texture paths and material properties

### Performance Issues

- **Issue**: Low frame rates with complex models
- **Solution**: Optimize geometry and implement LOD systems

## Summary

Importing robots and environments into Unity requires careful attention to file formats, unit conversions, and performance optimization. The process involves converting from robotics-specific formats like URDF to Unity's native format while preserving physical properties and visual appearance. By following proper import workflows, using automated pipelines, and applying best practices for material handling and optimization, developers can create high-quality robotics visualization environments that accurately represent real-world systems. The key is balancing visual fidelity with performance requirements while maintaining the accuracy needed for robotics applications.

## References

1. Unity Technologies. (2023). Unity Manual - Importing Objects. Unity Technologies.
2. ROS-Industrial Consortium. (2023). Robot Model Import Best Practices. https://ros-industrial.github.io/industrial_training/
3. Open Source Robotics Foundation. (2023). Gazebo to Unity Conversion Guide. https://gazebosim.org/tutorials

## Exercises

1. Create an automated pipeline for importing a simple robot model from URDF
2. Implement unit conversion for models in different measurement systems
3. Design a material system that preserves visual properties from CAD models
4. Set up LOD levels for a complex robot model to optimize performance