# 3.7 Streaming Sensor Data to ROS 2

## Introduction

Streaming sensor data to ROS 2 is fundamental for creating realistic simulation environments that integrate seamlessly with robotic applications. This chapter covers the implementation of sensor data streaming in Gazebo, including message formatting, Quality of Service (QoS) settings, timing synchronization, and performance optimization. Proper sensor streaming ensures that simulated data matches the format and timing characteristics of real sensors.

## ROS 2 Sensor Message Types

### Standard Sensor Messages

ROS 2 provides standard message types for different sensor modalities:

- **sensor_msgs/msg/LaserScan**: For LiDAR and range finder data
- **sensor_msgs/msg/Image**: For camera data
- **sensor_msgs/msg/CompressedImage**: For compressed camera data
- **sensor_msgs/msg/Imu**: For Inertial Measurement Unit data
- **sensor_msgs/msg/MagneticField**: For magnetometer data
- **sensor_msgs/msg/JointState**: For joint position/velocity/effort
- **sensor_msgs/msg/PointCloud2**: For 3D point cloud data
- **sensor_msgs/msg/FluidPressure**: For pressure sensors
- **sensor_msgs/msg/Illuminance**: For light sensors
- **sensor_msgs/msg/Temperature**: For temperature sensors

### Message Structure and Fields

Each sensor message type has specific fields that must be populated correctly:

```python
# Example LaserScan message structure
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Header

def create_laser_scan_message():
    scan_msg = LaserScan()
    scan_msg.header = Header()
    scan_msg.header.stamp = Clock().now().to_msg()  # Current time
    scan_msg.header.frame_id = 'laser_frame'  # Coordinate frame

    # LiDAR parameters
    scan_msg.angle_min = -3.14159  # Minimum angle (radians)
    scan_msg.angle_max = 3.14159   # Maximum angle (radians)
    scan_msg.angle_increment = 0.00872665  # Angle resolution (radians)
    scan_msg.time_increment = 0.00025      # Time between measurements (seconds)
    scan_msg.scan_time = 0.1              # Time between scans (seconds)
    scan_msg.range_min = 0.1              # Minimum range (meters)
    scan_msg.range_max = 30.0             # Maximum range (meters)

    # Range and intensity data
    num_ranges = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment) + 1
    scan_msg.ranges = [30.0] * num_ranges  # Initialize with max range
    scan_msg.intensities = [100.0] * num_ranges  # Initialize with default intensity

    return scan_msg

# Example IMU message structure
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Vector3, Quaternion

def create_imu_message():
    imu_msg = Imu()
    imu_msg.header = Header()
    imu_msg.header.stamp = Clock().now().to_msg()
    imu_msg.header.frame_id = 'imu_frame'

    # Orientation (quaternion: x, y, z, w)
    imu_msg.orientation = Quaternion()
    imu_msg.orientation.x = 0.0
    imu_msg.orientation.y = 0.0
    imu_msg.orientation.z = 0.0
    imu_msg.orientation.w = 1.0

    # Angular velocity (vector: x, y, z in rad/s)
    imu_msg.angular_velocity = Vector3()
    imu_msg.angular_velocity.x = 0.0
    imu_msg.angular_velocity.y = 0.0
    imu_msg.angular_velocity.z = 0.0

    # Linear acceleration (vector: x, y, z in m/s²)
    imu_msg.linear_acceleration = Vector3()
    imu_msg.linear_acceleration.x = 0.0
    imu_msg.linear_acceleration.y = 0.0
    imu_msg.linear_acceleration.z = 9.81  # Gravity

    # Covariance matrices (set to zero if unknown)
    imu_msg.orientation_covariance = [0.0] * 9
    imu_msg.angular_velocity_covariance = [0.0] * 9
    imu_msg.linear_acceleration_covariance = [0.0] * 9

    return imu_msg
```

## Quality of Service (QoS) Settings

### QoS Profiles for Different Sensors

Different sensors require different QoS settings based on their criticality and data characteristics:

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy

class SensorQoSProfiles:
    """QoS profiles for different sensor types"""

    # LiDAR sensors - need reliable delivery, real-time performance
    LIDAR_QOS = QoSProfile(
        depth=10,
        reliability=ReliabilityPolicy.RELIABLE,
        durability=DurabilityPolicy.VOLATILE,
        history=HistoryPolicy.KEEP_LAST
    )

    # Camera sensors - can tolerate best-effort, high bandwidth
    CAMERA_QOS = QoSProfile(
        depth=5,
        reliability=ReliabilityPolicy.BEST_EFFORT,
        durability=DurabilityPolicy.VOLATILE,
        history=HistoryPolicy.KEEP_LAST
    )

    # IMU sensors - need reliable delivery for control
    IMU_QOS = QoSProfile(
        depth=10,
        reliability=ReliabilityPolicy.RELIABLE,
        durability=DurabilityPolicy.VOLATILE,
        history=HistoryPolicy.KEEP_LAST
    )

    # Joint state sensors - need reliable delivery for control
    JOINT_STATE_QOS = QoSProfile(
        depth=10,
        reliability=ReliabilityPolicy.RELIABLE,
        durability=DurabilityPolicy.VOLATILE,
        history=HistoryPolicy.KEEP_LAST
    )

    # Odometry sensors - critical for navigation
    ODOMETRY_QOS = QoSProfile(
        depth=10,
        reliability=ReliabilityPolicy.RELIABLE,
        durability=DurabilityPolicy.TRANSIENT_LOCAL,
        history=HistoryPolicy.KEEP_LAST
    )

def get_qos_for_sensor(sensor_type):
    """Get appropriate QoS profile for sensor type"""
    qos_map = {
        'lidar': SensorQoSProfiles.LIDAR_QOS,
        'camera': SensorQoSProfiles.CAMERA_QOS,
        'imu': SensorQoSProfiles.IMU_QOS,
        'joint_state': SensorQoSProfiles.JOINT_STATE_QOS,
        'odometry': SensorQoSProfiles.ODOMETRY_QOS
    }
    return qos_map.get(sensor_type, SensorQoSProfiles.LIDAR_QOS)
```

### Custom QoS Configuration

For specific applications, custom QoS settings may be needed:

```python
def create_custom_qos(depth=10, reliability='reliable', durability='volatile', history='keep_last'):
    """Create custom QoS profile"""
    reliability_map = {
        'reliable': ReliabilityPolicy.RELIABLE,
        'best_effort': ReliabilityPolicy.BEST_EFFORT
    }

    durability_map = {
        'volatile': DurabilityPolicy.VOLATILE,
        'transient_local': DurabilityPolicy.TRANSIENT_LOCAL
    }

    history_map = {
        'keep_last': HistoryPolicy.KEEP_LAST,
        'keep_all': HistoryPolicy.KEEP_ALL
    }

    qos_profile = QoSProfile(
        depth=depth,
        reliability=reliability_map.get(reliability, ReliabilityPolicy.RELIABLE),
        durability=durability_map.get(durability, DurabilityPolicy.VOLATILE),
        history=history_map.get(history, HistoryPolicy.KEEP_LAST)
    )

    return qos_profile

# Example: High-frequency sensor with specific requirements
HIGH_FREQ_SENSOR_QOS = create_custom_qos(
    depth=5,
    reliability='best_effort',  # Can tolerate some message loss
    durability='volatile',      # Don't need to keep old messages
    history='keep_last'         # Only keep most recent
)
```

## Sensor Data Publishers

### Generic Sensor Publisher Framework

A framework for publishing different sensor types:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, Imu, Image, JointState
from std_msgs.msg import Header
from builtin_interfaces.msg import Time
import numpy as np
from cv_bridge import CvBridge

class SensorPublisher(Node):
    def __init__(self):
        super().__init__('sensor_publisher')

        # Initialize publishers for different sensor types
        self.publishers = {}
        self.sensors = {}

        # LiDAR publisher
        self.lidar_publisher = self.create_publisher(
            LaserScan,
            '/robot1/lidar/scan',
            SensorQoSProfiles.LIDAR_QOS
        )

        # IMU publisher
        self.imu_publisher = self.create_publisher(
            Imu,
            '/robot1/imu/data',
            SensorQoSProfiles.IMU_QOS
        )

        # Camera publisher
        self.image_publisher = self.create_publisher(
            Image,
            '/robot1/camera/image_raw',
            SensorQoSProfiles.CAMERA_QOS
        )

        # Joint state publisher
        self.joint_publisher = self.create_publisher(
            JointState,
            '/robot1/joint_states',
            SensorQoSProfiles.JOINT_STATE_QOS
        )

        # Timer for sensor data publishing
        self.lidar_timer = self.create_timer(0.1, self.publish_lidar_data)  # 10Hz
        self.imu_timer = self.create_timer(0.01, self.publish_imu_data)     # 100Hz
        self.camera_timer = self.create_timer(0.033, self.publish_camera_data)  # 30Hz
        self.joint_timer = self.create_timer(0.02, self.publish_joint_data)  # 50Hz

        # Initialize sensor simulators
        self.lidar_simulator = self.initialize_lidar_simulator()
        self.imu_simulator = self.initialize_imu_simulator()
        self.camera_simulator = self.initialize_camera_simulator()
        self.joint_simulator = self.initialize_joint_simulator()

        # CV Bridge for image conversion
        self.cv_bridge = CvBridge()

    def initialize_lidar_simulator(self):
        """Initialize LiDAR simulator parameters"""
        return {
            'angle_min': -np.pi,
            'angle_max': np.pi,
            'angle_increment': 0.00872665,  # 0.5 degrees
            'range_min': 0.1,
            'range_max': 30.0,
            'num_beams': int((2 * np.pi) / 0.00872665)
        }

    def initialize_imu_simulator(self):
        """Initialize IMU simulator parameters"""
        return {
            'noise_std': 0.01,
            'bias_drift': 0.001
        }

    def initialize_camera_simulator(self):
        """Initialize camera simulator parameters"""
        return {
            'width': 640,
            'height': 480,
            'format': 'rgb8'
        }

    def initialize_joint_simulator(self):
        """Initialize joint simulator parameters"""
        return {
            'joint_names': ['joint1', 'joint2', 'joint3'],
            'num_joints': 3
        }

    def publish_lidar_data(self):
        """Generate and publish LiDAR data"""
        # Create LaserScan message
        scan_msg = LaserScan()
        scan_msg.header = Header()
        scan_msg.header.stamp = self.get_clock().now().to_msg()
        scan_msg.header.frame_id = 'robot1/lidar_link'

        # Set LiDAR parameters
        scan_msg.angle_min = self.lidar_simulator['angle_min']
        scan_msg.angle_max = self.lidar_simulator['angle_max']
        scan_msg.angle_increment = self.lidar_simulator['angle_increment']
        scan_msg.time_increment = 0.00025
        scan_msg.scan_time = 0.1
        scan_msg.range_min = self.lidar_simulator['range_min']
        scan_msg.range_max = self.lidar_simulator['range_max']

        # Generate simulated range data (this would come from Gazebo)
        num_ranges = self.lidar_simulator['num_beams']
        ranges = [30.0] * num_ranges  # Initialize with max range

        # Add some simulated obstacles
        for i in range(0, num_ranges, 10):  # Every 10th beam
            if i % 20 == 0:
                ranges[i] = 5.0  # Obstacle at 5m

        # Add noise
        noise = np.random.normal(0, 0.02, num_ranges)
        ranges = [max(0.1, min(30.0, r + n)) for r, n in zip(ranges, noise)]

        scan_msg.ranges = ranges
        scan_msg.intensities = [100.0] * num_ranges

        # Publish message
        self.lidar_publisher.publish(scan_msg)

    def publish_imu_data(self):
        """Generate and publish IMU data"""
        imu_msg = Imu()
        imu_msg.header = Header()
        imu_msg.header.stamp = self.get_clock().now().to_msg()
        imu_msg.header.frame_id = 'robot1/imu_link'

        # Set orientation (simplified)
        imu_msg.orientation.x = 0.0
        imu_msg.orientation.y = 0.0
        imu_msg.orientation.z = 0.0
        imu_msg.orientation.w = 1.0

        # Set angular velocity with noise
        imu_msg.angular_velocity.x = np.random.normal(0, 0.001)
        imu_msg.angular_velocity.y = np.random.normal(0, 0.001)
        imu_msg.angular_velocity.z = np.random.normal(0, 0.001)

        # Set linear acceleration with gravity
        imu_msg.linear_acceleration.x = np.random.normal(0, 0.01)
        imu_msg.linear_acceleration.y = np.random.normal(0, 0.01)
        imu_msg.linear_acceleration.z = 9.81 + np.random.normal(0, 0.01)

        # Set covariance (realistic values for good IMU)
        imu_msg.orientation_covariance = [0.001, 0, 0, 0, 0.001, 0, 0, 0, 0.001]
        imu_msg.angular_velocity_covariance = [0.0001, 0, 0, 0, 0.0001, 0, 0, 0, 0.0001]
        imu_msg.linear_acceleration_covariance = [0.0004, 0, 0, 0, 0.0004, 0, 0, 0, 0.0004]

        self.imu_publisher.publish(imu_msg)

    def publish_camera_data(self):
        """Generate and publish camera data"""
        # Create a simple test image
        image_array = np.zeros((480, 640, 3), dtype=np.uint8)
        # Add some color patterns
        image_array[100:200, 200:400] = [255, 0, 0]  # Red rectangle
        image_array[250:350, 100:300] = [0, 255, 0]  # Green rectangle

        # Add noise
        noise = np.random.normal(0, 10, image_array.shape).astype(np.int16)
        image_array = np.clip(image_array.astype(np.int16) + noise, 0, 255).astype(np.uint8)

        # Convert to ROS Image message
        image_msg = self.cv_bridge.cv2_to_imgmsg(image_array, encoding='rgb8')
        image_msg.header.stamp = self.get_clock().now().to_msg()
        image_msg.header.frame_id = 'robot1/camera_optical_frame'

        self.image_publisher.publish(image_msg)

    def publish_joint_data(self):
        """Generate and publish joint state data"""
        joint_msg = JointState()
        joint_msg.header.stamp = self.get_clock().now().to_msg()
        joint_msg.header.frame_id = 'robot1/base_link'

        joint_msg.name = self.joint_simulator['joint_names']

        # Generate joint positions (simplified - would come from Gazebo)
        positions = []
        velocities = []
        efforts = []

        for i in range(self.joint_simulator['num_joints']):
            # Simulate oscillating joint motion
            t = self.get_clock().now().nanoseconds / 1e9
            pos = 0.5 * np.sin(0.5 * t + i)
            vel = 0.5 * 0.5 * np.cos(0.5 * t + i)
            eff = 0.1 * pos  # Simple effort model

            positions.append(pos)
            velocities.append(vel)
            efforts.append(eff)

        joint_msg.position = positions
        joint_msg.velocity = velocities
        joint_msg.effort = efforts

        self.joint_publisher.publish(joint_msg)
```

## Timing and Synchronization

### Precise Timing for Sensor Data

Accurate timing is crucial for sensor fusion and control applications:

```python
import time
from threading import Lock
from rclpy.time import Time

class PreciseTimingSensorPublisher(Node):
    def __init__(self):
        super().__init__('precise_timing_publisher')

        # Publishers
        self.imu_publisher = self.create_publisher(Imu, '/robot1/imu/data', 10)
        self.lidar_publisher = self.create_publisher(LaserScan, '/robot1/lidar/scan', 10)

        # Timing synchronization
        self.sync_lock = Lock()
        self.last_imu_time = 0
        self.last_lidar_time = 0

        # Create timers with specific periods
        self.imu_timer = self.create_timer(0.01, self.publish_imu_with_timing)  # 100Hz
        self.lidar_timer = self.create_timer(0.1, self.publish_lidar_with_timing)  # 10Hz

    def publish_imu_with_timing(self):
        """Publish IMU data with precise timing"""
        with self.sync_lock:
            # Get precise timestamp
            stamp = self.get_clock().now().to_msg()

            # Ensure minimum time between messages
            current_time = time.time()
            if current_time - self.last_imu_time < 0.009:  # 9ms minimum
                return

            imu_msg = self.create_imu_message()
            imu_msg.header.stamp = stamp
            imu_msg.header.frame_id = 'robot1/imu_link'

            self.imu_publisher.publish(imu_msg)
            self.last_imu_time = current_time

    def publish_lidar_with_timing(self):
        """Publish LiDAR data with precise timing"""
        with self.sync_lock:
            # Get precise timestamp
            stamp = self.get_clock().now().to_msg()

            # Ensure minimum time between messages
            current_time = time.time()
            if current_time - self.last_lidar_time < 0.09:  # 90ms minimum
                return

            lidar_msg = self.create_lidar_message()
            lidar_msg.header.stamp = stamp
            lidar_msg.header.frame_id = 'robot1/lidar_link'

            self.lidar_publisher.publish(lidar_msg)
            self.last_lidar_time = current_time

    def create_imu_message(self):
        """Create IMU message with proper timing fields"""
        imu_msg = Imu()

        # Set orientation (simplified)
        imu_msg.orientation.w = 1.0
        imu_msg.orientation.x = 0.0
        imu_msg.orientation.y = 0.0
        imu_msg.orientation.z = 0.0

        # Set angular velocity and linear acceleration with noise
        imu_msg.angular_velocity.x = np.random.normal(0, 0.001)
        imu_msg.angular_velocity.y = np.random.normal(0, 0.001)
        imu_msg.angular_velocity.z = np.random.normal(0, 0.001)

        imu_msg.linear_acceleration.x = np.random.normal(0, 0.01)
        imu_msg.linear_acceleration.y = np.random.normal(0, 0.01)
        imu_msg.linear_acceleration.z = 9.81 + np.random.normal(0, 0.01)

        return imu_msg

    def create_lidar_message(self):
        """Create LiDAR message with proper timing fields"""
        lidar_msg = LaserScan()
        lidar_msg.angle_min = -np.pi
        lidar_msg.angle_max = np.pi
        lidar_msg.angle_increment = 0.00872665
        lidar_msg.time_increment = 0.00025
        lidar_msg.scan_time = 0.1
        lidar_msg.range_min = 0.1
        lidar_msg.range_max = 30.0

        # Generate ranges
        num_ranges = int((lidar_msg.angle_max - lidar_msg.angle_min) / lidar_msg.angle_increment) + 1
        lidar_msg.ranges = [30.0] * num_ranges
        lidar_msg.intensities = [100.0] * num_ranges

        return lidar_msg
```

### Timestamp Synchronization

Synchronize sensor timestamps for multi-sensor fusion:

```python
class TimestampSynchronizer:
    def __init__(self, max_delay=0.1):
        """
        Synchronize sensor data based on timestamps
        max_delay: maximum allowed time difference between synchronized messages
        """
        self.max_delay = max_delay
        self.buffers = {}  # Buffer for each sensor type
        self.callbacks = {}  # Callbacks for synchronized data

    def add_sensor_buffer(self, sensor_name, max_size=10):
        """Add a buffer for a sensor type"""
        self.buffers[sensor_name] = {
            'data': [],
            'timestamps': [],
            'max_size': max_size
        }

    def add_synchronized_callback(self, sensor_names, callback):
        """Add callback for when all specified sensors have synchronized data"""
        sensor_key = tuple(sorted(sensor_names))
        self.callbacks[sensor_key] = callback

    def add_sensor_data(self, sensor_name, data, timestamp):
        """Add sensor data to buffer"""
        if sensor_name not in self.buffers:
            self.add_sensor_buffer(sensor_name)

        buffer = self.buffers[sensor_name]

        # Add data and timestamp
        buffer['data'].append(data)
        buffer['timestamps'].append(timestamp)

        # Maintain buffer size
        if len(buffer['data']) > buffer['max_size']:
            buffer['data'].pop(0)
            buffer['timestamps'].pop(0)

        # Check for synchronization opportunities
        self._check_synchronization()

    def _check_synchronization(self):
        """Check if we have synchronized data across sensors"""
        for sensor_group, callback in self.callbacks.items():
            if self._has_synchronized_data(sensor_group):
                self._extract_synchronized_data(sensor_group, callback)

    def _has_synchronized_data(self, sensor_names):
        """Check if all sensors in group have data within max_delay"""
        timestamps = []
        for sensor in sensor_names:
            if sensor not in self.buffers or len(self.buffers[sensor]['timestamps']) == 0:
                return False
            timestamps.append(self.buffers[sensor]['timestamps'][-1])

        # Check if timestamps are within max_delay of each other
        min_time = min(timestamps)
        max_time = max(timestamps)
        return (max_time - min_time) <= self.max_delay

    def _extract_synchronized_data(self, sensor_names, callback):
        """Extract and provide synchronized data to callback"""
        synchronized_data = {}
        common_time = max([self.buffers[sensor]['timestamps'][-1] for sensor in sensor_names])

        for sensor in sensor_names:
            # Find closest data to common time
            timestamps = self.buffers[sensor]['timestamps']
            data = self.buffers[sensor]['data']

            closest_idx = min(range(len(timestamps)),
                            key=lambda i: abs(timestamps[i] - common_time))

            synchronized_data[sensor] = {
                'data': data[closest_idx],
                'timestamp': timestamps[closest_idx]
            }

        # Call the synchronized callback
        callback(synchronized_data)
```

## Performance Optimization

### Efficient Message Creation

Optimize sensor message creation for high-frequency publishing:

```python
import array
from collections import deque

class EfficientSensorPublisher(Node):
    def __init__(self):
        super().__init__('efficient_sensor_publisher')

        # Pre-allocate message objects to avoid repeated allocation
        self.lidar_msg_template = self.create_lidar_template()
        self.imu_msg_template = self.create_imu_template()

        # Publishers
        self.lidar_publisher = self.create_publisher(LaserScan, '/robot1/lidar/scan', 10)
        self.imu_publisher = self.create_publisher(Imu, '/robot1/imu/data', 10)

        # Pre-allocate arrays for sensor data
        self.lidar_ranges = array.array('f', [30.0] * 360)  # 360 beams
        self.lidar_intensities = array.array('f', [100.0] * 360)

        # High-frequency timer
        self.high_freq_timer = self.create_timer(0.001, self.publish_efficient_data)  # 1kHz

    def create_lidar_template(self):
        """Create a template LiDAR message to reuse"""
        template = LaserScan()
        template.angle_min = -np.pi
        template.angle_max = np.pi
        template.angle_increment = np.pi / 180  # 1 degree
        template.time_increment = 0.00025
        template.scan_time = 0.1
        template.range_min = 0.1
        template.range_max = 30.0
        return template

    def create_imu_template(self):
        """Create a template IMU message to reuse"""
        template = Imu()
        template.orientation.w = 1.0
        template.orientation.x = 0.0
        template.orientation.y = 0.0
        template.orientation.z = 0.0
        template.orientation_covariance = [0.001, 0, 0, 0, 0.001, 0, 0, 0, 0.001]
        template.angular_velocity_covariance = [0.0001, 0, 0, 0, 0.0001, 0, 0, 0, 0.0001]
        template.linear_acceleration_covariance = [0.0004, 0, 0, 0, 0.0004, 0, 0, 0, 0.0004]
        return template

    def publish_efficient_data(self):
        """Publish sensor data using pre-allocated messages"""
        # Update LiDAR data efficiently
        self.update_lidar_data()
        lidar_msg = self.lidar_msg_template
        lidar_msg.header.stamp = self.get_clock().now().to_msg()
        lidar_msg.header.frame_id = 'robot1/lidar_link'
        lidar_msg.ranges = self.lidar_ranges
        lidar_msg.intensities = self.lidar_intensities
        self.lidar_publisher.publish(lidar_msg)

        # Update IMU data efficiently
        self.update_imu_data()
        imu_msg = self.imu_msg_template
        imu_msg.header.stamp = lidar_msg.header.stamp  # Same timestamp for synchronization
        imu_msg.header.frame_id = 'robot1/imu_link'
        self.imu_publisher.publish(imu_msg)

    def update_lidar_data(self):
        """Update pre-allocated LiDAR data arrays"""
        # Generate new range data efficiently
        for i in range(len(self.lidar_ranges)):
            if i % 50 == 0:  # Add obstacles every 50 beams
                self.lidar_ranges[i] = 5.0 + np.random.normal(0, 0.02)
            else:
                self.lidar_ranges[i] = 30.0 + np.random.normal(0, 0.02)

    def update_imu_data(self):
        """Update pre-allocated IMU message"""
        self.imu_msg_template.angular_velocity.x = np.random.normal(0, 0.001)
        self.imu_msg_template.angular_velocity.y = np.random.normal(0, 0.001)
        self.imu_msg_template.angular_velocity.z = np.random.normal(0, 0.001)

        self.imu_msg_template.linear_acceleration.x = np.random.normal(0, 0.01)
        self.imu_msg_template.linear_acceleration.y = np.random.normal(0, 0.01)
        self.imu_msg_template.linear_acceleration.z = 9.81 + np.random.normal(0, 0.01)
```

### Memory Management

Manage memory efficiently for high-rate sensor streaming:

```python
import gc
from weakref import WeakValueDictionary

class MemoryEfficientSensorManager:
    def __init__(self, max_memory_mb=100):
        self.max_memory_mb = max_memory_mb
        self.message_pool = {}  # Pool of reusable message objects
        self.active_messages = WeakValueDictionary()  # Track active messages
        self.message_counts = {}  # Count of each message type

    def get_message(self, msg_type, reuse=True):
        """Get a message object, potentially reusing from pool"""
        type_name = msg_type.__name__

        if reuse and type_name in self.message_pool and len(self.message_pool[type_name]) > 0:
            # Reuse existing message
            return self.message_pool[type_name].pop()

        # Create new message
        msg = msg_type()
        self.message_counts[type_name] = self.message_counts.get(type_name, 0) + 1
        self.active_messages[id(msg)] = msg

        return msg

    def return_message(self, msg):
        """Return a message to the pool for reuse"""
        type_name = type(msg).__name__
        if type_name not in self.message_pool:
            self.message_pool[type_name] = []

        self.message_pool[type_name].append(msg)

    def cleanup_pool(self):
        """Clean up message pool to prevent memory bloat"""
        for msg_type in self.message_pool:
            if len(self.message_pool[msg_type]) > 100:  # Limit pool size
                # Remove excess messages
                excess = len(self.message_pool[msg_type]) - 50
                self.message_pool[msg_type] = self.message_pool[msg_type][excess:]

    def get_memory_stats(self):
        """Get memory usage statistics"""
        stats = {
            'message_counts': self.message_counts.copy(),
            'pool_sizes': {k: len(v) for k, v in self.message_pool.items()},
            'active_messages': len(self.active_messages)
        }
        return stats
```

## Multi-Robot Sensor Streaming

### Namespaced Sensor Topics

Handle multiple robots with proper namespacing:

```python
class MultiRobotSensorPublisher(Node):
    def __init__(self):
        super().__init__('multi_robot_sensor_publisher')

        # Robot configuration
        self.robots = ['robot1', 'robot2', 'robot3']
        self.publishers = {}
        self.timers = {}

        # Initialize publishers for each robot
        for robot_name in self.robots:
            self._create_robot_publishers(robot_name)

    def _create_robot_publishers(self, robot_name):
        """Create publishers for a specific robot"""
        namespace = f'/{robot_name}'

        # Create publishers with robot-specific topics
        self.publishers[robot_name] = {
            'lidar': self.create_publisher(
                LaserScan,
                f'{namespace}/lidar/scan',
                SensorQoSProfiles.LIDAR_QOS
            ),
            'imu': self.create_publisher(
                Imu,
                f'{namespace}/imu/data',
                SensorQoSProfiles.IMU_QOS
            ),
            'camera': self.create_publisher(
                Image,
                f'{namespace}/camera/image_raw',
                SensorQoSProfiles.CAMERA_QOS
            )
        }

        # Create timers for each robot (potentially different rates)
        self.timers[robot_name] = {
            'lidar': self.create_timer(
                0.1,  # 10Hz
                lambda rn=robot_name: self.publish_robot_lidar(rn)
            ),
            'imu': self.create_timer(
                0.01,  # 100Hz
                lambda rn=robot_name: self.publish_robot_imu(rn)
            ),
            'camera': self.create_timer(
                0.033,  # 30Hz
                lambda rn=robot_name: self.publish_robot_camera(rn)
            )
        }

    def publish_robot_lidar(self, robot_name):
        """Publish LiDAR data for specific robot"""
        lidar_msg = self._create_robot_lidar_message(robot_name)
        self.publishers[robot_name]['lidar'].publish(lidar_msg)

    def publish_robot_imu(self, robot_name):
        """Publish IMU data for specific robot"""
        imu_msg = self._create_robot_imu_message(robot_name)
        self.publishers[robot_name]['imu'].publish(imu_msg)

    def publish_robot_camera(self, robot_name):
        """Publish camera data for specific robot"""
        camera_msg = self._create_robot_camera_message(robot_name)
        self.publishers[robot_name]['camera'].publish(camera_msg)

    def _create_robot_lidar_message(self, robot_name):
        """Create LiDAR message specific to robot"""
        scan_msg = LaserScan()
        scan_msg.header.stamp = self.get_clock().now().to_msg()
        scan_msg.header.frame_id = f'{robot_name}/lidar_link'

        # Set parameters
        scan_msg.angle_min = -np.pi
        scan_msg.angle_max = np.pi
        scan_msg.angle_increment = 0.00872665
        scan_msg.time_increment = 0.00025
        scan_msg.scan_time = 0.1
        scan_msg.range_min = 0.1
        scan_msg.range_max = 30.0

        # Generate robot-specific data (with unique noise/positioning)
        robot_id = int(robot_name[-1])  # robot1 -> 1, robot2 -> 2, etc.
        num_ranges = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment) + 1
        ranges = [30.0] * num_ranges

        # Add robot-specific obstacles
        for i in range(0, num_ranges, 10 + robot_id):  # Vary obstacle spacing by robot
            ranges[i] = 5.0 + np.random.normal(0, 0.02)

        scan_msg.ranges = ranges
        scan_msg.intensities = [100.0] * num_ranges

        return scan_msg

    def _create_robot_imu_message(self, robot_name):
        """Create IMU message specific to robot"""
        imu_msg = Imu()
        imu_msg.header.stamp = self.get_clock().now().to_msg()
        imu_msg.header.frame_id = f'{robot_name}/imu_link'

        # Set robot-specific initial conditions
        robot_id = int(robot_name[-1])

        # Add small variations per robot
        imu_msg.angular_velocity.x = np.random.normal(0, 0.001 + robot_id * 0.0001)
        imu_msg.angular_velocity.y = np.random.normal(0, 0.001 + robot_id * 0.0001)
        imu_msg.angular_velocity.z = np.random.normal(0, 0.001 + robot_id * 0.0001)

        imu_msg.linear_acceleration.x = np.random.normal(0, 0.01 + robot_id * 0.001)
        imu_msg.linear_acceleration.y = np.random.normal(0, 0.01 + robot_id * 0.001)
        imu_msg.linear_acceleration.z = 9.81 + np.random.normal(0, 0.01 + robot_id * 0.001)

        return imu_msg

    def _create_robot_camera_message(self, robot_name):
        """Create camera message specific to robot"""
        # Create robot-specific image (with unique patterns)
        robot_id = int(robot_name[-1])
        image_array = np.zeros((480, 640, 3), dtype=np.uint8)

        # Add robot-unique color pattern
        color_offset = robot_id * 50
        image_array[100:200, 200:400] = [(255 + color_offset) % 256, 0, 0]  # Red with offset
        image_array[250:350, 100:300] = [0, (150 + color_offset) % 256, 0]  # Green with offset

        # Convert to ROS Image message
        image_msg = self.cv_bridge.cv2_to_imgmsg(image_array, encoding='rgb8')
        image_msg.header.stamp = self.get_clock().now().to_msg()
        image_msg.header.frame_id = f'{robot_name}/camera_optical_frame'

        return image_msg
```

## Network and Bandwidth Considerations

### Bandwidth Optimization

Optimize sensor data for network transmission:

```python
import zlib
import struct

class BandwidthOptimizedSensorPublisher(Node):
    def __init__(self):
        super().__init__('bandwidth_optimized_publisher')

        # Publishers for optimized data
        self.optimized_lidar_publisher = self.create_publisher(
            LaserScan,
            '/robot1/lidar/scan_optimized',
            create_custom_qos(depth=5, reliability='best_effort')
        )

        self.compressed_camera_publisher = self.create_publisher(
            Image,
            '/robot1/camera/image_compressed',
            create_custom_qos(depth=2, reliability='best_effort')
        )

        # Timers
        self.lidar_timer = self.create_timer(0.1, self.publish_optimized_lidar)
        self.camera_timer = self.create_timer(0.033, self.publish_compressed_camera)

    def publish_optimized_lidar(self):
        """Publish optimized LiDAR data with reduced bandwidth"""
        # Instead of publishing all ranges, only publish non-max ranges
        # This assumes most ranges are at max distance (no obstacles)

        scan_msg = LaserScan()
        scan_msg.header.stamp = self.get_clock().now().to_msg()
        scan_msg.header.frame_id = 'robot1/lidar_link'

        # Set parameters
        scan_msg.angle_min = -np.pi
        scan_msg.angle_max = np.pi
        scan_msg.angle_increment = 0.00872665
        scan_msg.time_increment = 0.00025
        scan_msg.scan_time = 0.1
        scan_msg.range_min = 0.1
        scan_msg.range_max = 30.0

        # Generate ranges with mostly max values
        num_ranges = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment) + 1
        ranges = [30.0] * num_ranges

        # Add sparse obstacles
        for i in range(0, num_ranges, 20):  # Only every 20th beam has obstacle
            ranges[i] = 5.0 + np.random.normal(0, 0.02)

        # Apply compression by only including non-max ranges
        # In practice, you might use a sparse representation
        scan_msg.ranges = ranges
        scan_msg.intensities = [100.0] * num_ranges

        self.optimized_lidar_publisher.publish(scan_msg)

    def publish_compressed_camera(self):
        """Publish compressed camera data"""
        # Generate uncompressed image
        image_array = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)

        # In practice, use proper image compression (JPEG, PNG)
        # For this example, we'll simulate compression using zlib
        image_bytes = image_array.tobytes()
        compressed_bytes = zlib.compress(image_bytes)

        # Create compressed image message
        compressed_msg = Image()
        compressed_msg.header.stamp = self.get_clock().now().to_msg()
        compressed_msg.header.frame_id = 'robot1/camera_optical_frame'
        compressed_msg.height = 480
        compressed_msg.width = 640
        compressed_msg.encoding = 'compressed'  # Custom encoding for compressed data
        compressed_msg.is_bigendian = 0
        compressed_msg.step = 640 * 3  # Original step
        compressed_msg.data = compressed_bytes

        self.compressed_camera_publisher.publish(compressed_msg)

    def adaptive_publishing_rate(self, network_load):
        """Adjust publishing rate based on network conditions"""
        base_rate = 10.0  # Base rate in Hz

        if network_load > 0.8:  # High network load
            rate = base_rate * 0.5  # Reduce to 50%
        elif network_load > 0.5:  # Medium load
            rate = base_rate * 0.75  # Reduce to 75%
        else:  # Low load
            rate = base_rate  # Full rate

        # Adjust timer period
        new_period = 1.0 / rate
        # In practice, you'd need to recreate the timer with the new period
        return new_period
```

## Validation and Testing

### Sensor Data Validation

Validate that sensor data meets requirements:

```python
class SensorDataValidator:
    def __init__(self):
        self.validation_results = {}

    def validate_lidar_data(self, scan_msg):
        """Validate LiDAR message meets specifications"""
        results = {
            'valid_header': scan_msg.header.stamp.sec != 0 or scan_msg.header.stamp.nanosec != 0,
            'valid_ranges': len(scan_msg.ranges) > 0,
            'range_values_valid': all(
                scan_msg.range_min <= r <= scan_msg.range_max or r == float('inf')
                for r in scan_msg.ranges if r != float('inf')
            ),
            'angle_parameters_valid': (
                scan_msg.angle_max > scan_msg.angle_min and
                scan_msg.angle_increment > 0
            ),
            'timing_consistency': (
                scan_msg.scan_time > 0 and
                scan_msg.time_increment >= 0
            )
        }

        results['overall_valid'] = all(results.values())
        return results

    def validate_imu_data(self, imu_msg):
        """Validate IMU message meets specifications"""
        # Check quaternion normalization
        quat_norm = np.sqrt(
            imu_msg.orientation.w**2 +
            imu_msg.orientation.x**2 +
            imu_msg.orientation.y**2 +
            imu_msg.orientation.z**2
        )

        results = {
            'valid_header': imu_msg.header.stamp.sec != 0 or imu_msg.header.stamp.nanosec != 0,
            'quaternion_normalized': abs(quat_norm - 1.0) < 0.001,
            'covariance_valid': len(imu_msg.orientation_covariance) == 9,
            'angular_velocity_reasonable': np.linalg.norm([
                imu_msg.angular_velocity.x,
                imu_msg.angular_velocity.y,
                imu_msg.angular_velocity.z
            ]) < 10.0,  # Max 10 rad/s
            'linear_acceleration_reasonable': np.linalg.norm([
                imu_msg.linear_acceleration.x,
                imu_msg.linear_acceleration.y,
                imu_msg.linear_acceleration.z
            ]) < 50.0  # Max 50 m/s²
        }

        results['overall_valid'] = all(results.values())
        return results

    def validate_camera_data(self, image_msg):
        """Validate camera image message"""
        results = {
            'valid_header': image_msg.header.stamp.sec != 0 or image_msg.header.stamp.nanosec != 0,
            'valid_dimensions': image_msg.height > 0 and image_msg.width > 0,
            'valid_encoding': image_msg.encoding in ['rgb8', 'bgr8', 'mono8', 'rgba8'],
            'valid_data_size': len(image_msg.data) == image_msg.height * image_msg.step,
            'step_consistency': image_msg.step == image_msg.width * (3 if 'rgb' in image_msg.encoding else 1)
        }

        results['overall_valid'] = all(results.values())
        return results

    def validate_timing_consistency(self, messages, expected_rate_hz):
        """Validate that messages are published at expected rate"""
        if len(messages) < 2:
            return {'valid': False, 'reason': 'Insufficient messages for timing validation'}

        # Calculate actual rate
        timestamps = [msg.header.stamp.sec + msg.header.stamp.nanosec / 1e9 for msg in messages]
        time_deltas = np.diff(timestamps)
        actual_rate = 1.0 / np.mean(time_deltas)

        rate_tolerance = 0.1  # 10% tolerance
        rate_valid = abs(actual_rate - expected_rate_hz) / expected_rate_hz < rate_tolerance

        return {
            'valid': rate_valid,
            'expected_rate': expected_rate_hz,
            'actual_rate': actual_rate,
            'tolerance': rate_tolerance
        }

def run_sensor_validation_tests():
    """Run comprehensive sensor validation tests"""
    validator = SensorDataValidator()

    # Test LiDAR validation
    test_scan = LaserScan()
    test_scan.header.stamp = Time()
    test_scan.angle_min = -np.pi
    test_scan.angle_max = np.pi
    test_scan.angle_increment = 0.01
    test_scan.range_min = 0.1
    test_scan.range_max = 30.0
    test_scan.ranges = [5.0] * 628  # ~2pi / 0.01 beams

    lidar_results = validator.validate_lidar_data(test_scan)
    print(f"LiDAR Validation: {lidar_results['overall_valid']}")

    # Test IMU validation
    test_imu = Imu()
    test_imu.header.stamp = Time()
    test_imu.orientation.w = 1.0
    test_imu.angular_velocity.x = 0.1
    test_imu.linear_acceleration.z = 9.81

    imu_results = validator.validate_imu_data(test_imu)
    print(f"IMU Validation: {imu_results['overall_valid']}")

    return {
        'lidar': lidar_results,
        'imu': imu_results
    }
```

## Common Issues and Troubleshooting

### Performance Issues

- **High CPU Usage**: Use efficient data structures and minimize message allocation
- **Memory Leaks**: Properly manage message lifecycle and use object pooling
- **Network Congestion**: Implement adaptive publishing rates and compression

### Data Quality Issues

- **Timestamp Problems**: Ensure proper clock synchronization
- **Message Loss**: Adjust QoS settings and network configuration
- **Data Corruption**: Validate message integrity and implement checksums

### Integration Issues

- **Topic Mismatches**: Verify topic names and message types
- **Frame ID Issues**: Ensure proper TF frame conventions
- **Synchronization Problems**: Implement proper timing synchronization

## Best Practices

### 1. Use Appropriate QoS Settings

Match QoS settings to sensor requirements and application needs.

### 2. Optimize for Performance

Use efficient data structures and minimize allocation in high-frequency loops.

### 3. Validate Data Integrity

Implement validation checks to ensure sensor data quality.

### 4. Handle Network Constraints

Consider bandwidth and latency when designing sensor streaming systems.

### 5. Maintain Timing Accuracy

Ensure proper timestamping for sensor fusion and control applications.

## Summary

Streaming sensor data to ROS 2 requires careful attention to message formatting, Quality of Service settings, timing synchronization, and performance optimization. By following best practices for each sensor type and implementing proper validation, you can create robust sensor streaming systems that support real-time robotic applications. The key is balancing data quality with performance requirements while maintaining compatibility with existing ROS 2 tools and algorithms.

## References

1. ROS 2 Documentation. (2023). Quality of Service Settings. https://docs.ros.org/en/rolling/Concepts/About-Quality-of-Service-Settings.html
2. Open Source Robotics Foundation. (2023). Gazebo to ROS 2 Integration. https://gazebosim.org/docs/fortress/ros_integration/
3. ROS-Industrial Consortium. (2023). Sensor Integration Best Practices. https://ros-industrial.github.io/industrial_training/

## Exercises

1. Implement a sensor data validator for multiple sensor types
2. Create an adaptive publishing system that adjusts to network conditions
3. Develop a multi-robot sensor streaming architecture with proper namespacing
4. Design a bandwidth-optimized sensor compression system