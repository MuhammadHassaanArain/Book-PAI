# 3.6 Sensor Noise, Drift, and Calibration Models

## Introduction

Realistic sensor noise modeling is crucial for creating accurate simulation environments that properly test robotic algorithms. This chapter covers the mathematical models for sensor noise, drift, and calibration procedures, including statistical analysis, noise parameter estimation, and validation techniques. Proper noise modeling ensures that robots trained in simulation can successfully transfer to real-world applications.

## Types of Sensor Noise

### White Noise

White noise has constant power spectral density across all frequencies:

```
n(t) ~ N(0, σ²)
```

Where σ² is the variance of the noise. White noise is characterized by:
- Zero mean
- Constant variance
- Uncorrelated samples

### Pink Noise (1/f Noise)

Pink noise has power spectral density inversely proportional to frequency:

```
S(f) ∝ 1/f
```

Common in electronic systems and sensors with 1/f characteristics.

### Brownian Noise (Random Walk)

Brownian noise (integrated white noise) has power spectral density proportional to 1/f²:

```
S(f) ∝ 1/f²
```

### Quantization Noise

Digital sensors introduce quantization noise due to finite resolution:

```
Q = V_ref / 2^N
```

Where V_ref is the reference voltage and N is the number of bits.

## Noise Modeling Techniques

### Statistical Noise Models

#### Gaussian Noise Model

The most common noise model assumes Gaussian distribution:

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def gaussian_noise(mean=0, std_dev=1, size=1):
    """Generate Gaussian noise samples"""
    return np.random.normal(mean, std_dev, size)

def visualize_noise_distribution(noise_samples, title="Noise Distribution"):
    """Visualize noise distribution and statistics"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

    # Histogram
    ax1.hist(noise_samples, bins=50, density=True, alpha=0.7)
    ax1.set_title(f'{title} - Histogram')
    ax1.set_xlabel('Value')
    ax1.set_ylabel('Density')

    # Q-Q plot
    stats.probplot(noise_samples, dist="norm", plot=ax2)
    ax2.set_title(f'{title} - Q-Q Plot')

    plt.tight_layout()
    plt.show()

    # Statistics
    mean = np.mean(noise_samples)
    std = np.std(noise_samples)
    print(f"Mean: {mean:.6f}, Std: {std:.6f}")

    return mean, std
```

#### Non-Gaussian Noise Models

For sensors with non-Gaussian characteristics:

```python
def generate_noise_with_distribution(distribution_type, size, **params):
    """Generate noise with different statistical distributions"""
    if distribution_type == 'gaussian':
        return np.random.normal(params.get('mean', 0), params.get('std', 1), size)

    elif distribution_type == 'uniform':
        low = params.get('low', -1)
        high = params.get('high', 1)
        return np.random.uniform(low, high, size)

    elif distribution_type == 'laplace':
        loc = params.get('loc', 0)
        scale = params.get('scale', 1)
        return np.random.laplace(loc, scale, size)

    elif distribution_type == 'exponential':
        scale = params.get('scale', 1)
        return np.random.exponential(scale, size)

    elif distribution_type == 'cauchy':
        loc = params.get('loc', 0)
        scale = params.get('scale', 1)
        return np.random.standard_cauchy(size) * scale + loc

    else:
        raise ValueError(f"Unknown distribution: {distribution_type}")
```

### Temporal Noise Correlations

#### First-Order Gauss-Markov Process

Models slowly varying bias with exponential correlation:

```python
class GaussMarkovNoise:
    def __init__(self, noise_density, bias_correlation_time, initial_bias=0):
        """
        First-order Gauss-Markov process for modeling sensor bias
        dx/dt = -βx + w
        where β = 1/τ (τ is correlation time) and w is white noise
        """
        self.beta = 1.0 / bias_correlation_time  # Correlation coefficient
        self.noise_density = noise_density
        self.state = initial_bias
        self.dt = 0.01  # Default time step

    def update(self, dt=None):
        """Update the Gauss-Markov process"""
        if dt is not None:
            self.dt = dt

        # Discrete-time approximation of continuous process
        # x[k+1] = x[k] * exp(-β*dt) + w[k] * sqrt(Qc * (1 - exp(-2*β*dt)) / (2*β))
        # where Qc = 2 * β * σ² (continuous noise intensity)

        process_noise = self.noise_density * np.sqrt(2 * self.beta)
        discrete_noise = process_noise * np.sqrt((1 - np.exp(-2 * self.beta * self.dt)) / (2 * self.beta))

        self.state = self.state * np.exp(-self.beta * self.dt) + \
                    np.random.normal(0, discrete_noise)

        return self.state

    def get_state(self):
        """Get current bias state"""
        return self.state
```

#### Random Walk Process

Models slowly varying parameters:

```python
class RandomWalkNoise:
    def __init__(self, random_walk_coefficient, initial_state=0):
        """
        Random walk process: x[k+1] = x[k] + w[k]
        where w[k] is white noise
        """
        self.random_walk_coefficient = random_walk_coefficient
        self.state = initial_state

    def update(self, dt=1.0):
        """Update the random walk process"""
        increment = np.random.normal(0, self.random_walk_coefficient * np.sqrt(dt))
        self.state += increment
        return self.state

    def get_state(self):
        """Get current state"""
        return self.state
```

## Accelerometer Noise Modeling

### Accelerometer Noise Components

Accelerometers have several noise sources:

1. **Velocity Random Walk (VRW)**: White noise on acceleration
2. **Bias Instability**: Slowly varying bias (1/f noise)
3. **Rate Random Walk**: Random walk on velocity
4. **Quantization Noise**: Digital conversion artifacts

```python
class AccelerometerNoiseModel:
    def __init__(self, parameters):
        """
        Initialize accelerometer noise model based on Allan variance parameters

        Parameters:
        - vrw_density: Velocity Random Walk density (m/s²/√Hz)
        - bias_instability: Bias instability (m/s²)
        - bias_correlation_time: Correlation time for bias (s)
        - rate_random_walk: Rate Random Walk coefficient (m/s³/√Hz)
        - quantization: Quantization step (m/s²)
        """
        self.vrw_density = parameters.vrw_density
        self.bias_instability = parameters.bias_instability
        self.bias_correlation_time = parameters.bias_correlation_time
        self.rate_random_walk = parameters.rate_random_walk
        self.quantization = parameters.quantization

        # Initialize noise processes
        self.vrw_process = np.zeros(3)  # Velocity Random Walk
        self.bias_process = GaussMarkovNoise(
            self.bias_instability,
            self.bias_correlation_time
        )
        self.rate_walk_process = RandomWalkNoise(self.rate_random_walk)
        self.bias_state = np.zeros(3)  # 3-axis bias

    def generate_noise(self, dt):
        """Generate accelerometer noise for time step dt"""
        noise = np.zeros(3)

        # Velocity Random Walk (white noise on acceleration)
        vrw_std = self.vrw_density * np.sqrt(1.0 / (2 * dt))
        self.vrw_process = np.random.normal(0, vrw_std, 3)
        noise += self.vrw_process

        # Bias instability (Gauss-Markov process)
        bias = np.array([self.bias_process.update(dt) for _ in range(3)])
        self.bias_state += bias
        noise += self.bias_state

        # Rate Random Walk (integrated random walk)
        rate_walk = np.array([self.rate_walk_process.update(dt) for _ in range(3)])
        noise += rate_walk

        # Quantization noise
        if self.quantization > 0:
            quant_noise = np.random.uniform(-self.quantization/2, self.quantization/2, 3)
            noise += quant_noise

        return noise

    def get_all_noise_components(self, dt):
        """Get individual noise components for analysis"""
        components = {}

        # Velocity Random Walk
        vrw_std = self.vrw_density * np.sqrt(1.0 / (2 * dt))
        components['vrw'] = np.random.normal(0, vrw_std, 3)

        # Bias instability
        components['bias'] = np.array([self.bias_process.get_state() for _ in range(3)])

        # Rate Random Walk
        components['rate_walk'] = np.array([self.rate_walk_process.get_state() for _ in range(3)])

        # Quantization
        if self.quantization > 0:
            components['quantization'] = np.random.uniform(-self.quantization/2, self.quantization/2, 3)
        else:
            components['quantization'] = np.zeros(3)

        return components
```

## Gyroscope Noise Modeling

### Gyroscope Noise Components

Gyroscopes have specific noise sources:

1. **Angle Random Walk (ARW)**: White noise on angular velocity
2. **Rate Random Walk (RRW)**: Random walk on angular velocity
3. **Bias Instability**: Slowly varying bias
4. **Rate Ramp**: Linear drift in angular velocity

```python
class GyroscopeNoiseModel:
    def __init__(self, parameters):
        """
        Initialize gyroscope noise model based on Allan variance parameters

        Parameters:
        - arw_density: Angle Random Walk density (rad/s/√Hz)
        - rrw_density: Rate Random Walk density (rad/s²/√Hz)
        - bias_instability: Bias instability (rad/s)
        - bias_correlation_time: Correlation time for bias (s)
        - rate_ramp: Rate ramp coefficient (rad/s²)
        - quantization: Quantization step (rad/s)
        """
        self.arw_density = parameters.arw_density
        self.rrw_density = parameters.rrw_density
        self.bias_instability = parameters.bias_instability
        self.bias_correlation_time = parameters.bias_correlation_time
        self.rate_ramp = parameters.rate_ramp
        self.quantization = parameters.quantization

        # Initialize noise processes
        self.arw_process = np.zeros(3)  # Angle Random Walk
        self.rrw_process = np.zeros(3)  # Rate Random Walk
        self.bias_process = GaussMarkovNoise(
            self.bias_instability,
            self.bias_correlation_time
        )
        self.ramp_state = np.zeros(3)  # Rate ramp state
        self.bias_state = np.zeros(3)  # 3-axis bias

    def generate_noise(self, dt):
        """Generate gyroscope noise for time step dt"""
        noise = np.zeros(3)

        # Angle Random Walk (white noise on angular velocity)
        arw_std = self.arw_density * np.sqrt(1.0 / (2 * dt))
        self.arw_process = np.random.normal(0, arw_std, 3)
        noise += self.arw_process

        # Rate Random Walk
        rrw_std = self.rrw_density * np.sqrt(dt)
        self.rrw_process += np.random.normal(0, rrw_std, 3)
        noise += self.rrw_process

        # Bias instability (Gauss-Markov process)
        bias = np.array([self.bias_process.update(dt) for _ in range(3)])
        self.bias_state += bias
        noise += self.bias_state

        # Rate ramp (linear drift)
        self.ramp_state += self.rate_ramp * dt
        noise += self.ramp_state

        # Quantization noise
        if self.quantization > 0:
            quant_noise = np.random.uniform(-self.quantization/2, self.quantization/2, 3)
            noise += quant_noise

        return noise
```

## Magnetometer Noise Modeling

### Magnetometer Noise Sources

Magnetometers have unique noise characteristics:

1. **White Noise**: Electronic noise in the sensor
2. **Hard Iron Effects**: Permanent magnetization
3. **Soft Iron Effects**: Induced magnetization
4. **Environmental Disturbances**: Magnetic anomalies

```python
class MagnetometerNoiseModel:
    def __init__(self, parameters):
        """
        Initialize magnetometer noise model

        Parameters:
        - noise_density: Noise density (T/√Hz)
        - bias_instability: Bias instability (T)
        - hard_iron_std: Standard deviation of hard iron effects (T)
        - soft_iron_std: Standard deviation of soft iron effects
        - update_rate: Sensor update rate (Hz)
        """
        self.noise_density = parameters.noise_density
        self.bias_instability = parameters.bias_instability
        self.hard_iron_std = parameters.hard_iron_std
        self.soft_iron_std = parameters.soft_iron_std
        self.update_rate = parameters.update_rate

        # Initialize bias random walk
        self.bias_rw = np.random.normal(0, self.bias_instability, 3)

        # Initialize hard iron effects (fixed offset)
        self.hard_iron_offset = np.random.normal(0, self.hard_iron_std, 3)

        # Initialize soft iron matrix (3x3 transformation matrix)
        self.soft_iron_matrix = self.generate_soft_iron_matrix()

    def generate_soft_iron_matrix(self):
        """Generate soft iron transformation matrix"""
        # Start with identity matrix and add small perturbations
        matrix = np.eye(3)
        perturbation = np.random.normal(0, self.soft_iron_std, (3, 3))
        matrix += perturbation
        return matrix

    def generate_noise(self, true_field, dt):
        """Generate magnetometer measurement with noise and effects"""
        # Add white noise
        noise_std = self.noise_density * np.sqrt(self.update_rate / 2)
        white_noise = np.random.normal(0, noise_std, 3)

        # Add bias random walk
        bias_rw_std = self.bias_instability * np.sqrt(dt)
        self.bias_rw += np.random.normal(0, bias_rw_std, 3)

        # Apply soft iron effects
        distorted_field = np.dot(self.soft_iron_matrix, true_field)

        # Add hard iron offset
        measurement = distorted_field + self.hard_iron_offset + white_noise + self.bias_rw

        return measurement
```

## Allan Variance Analysis

### Allan Variance Calculation

Allan variance is the standard method for characterizing sensor noise:

```python
def calculate_allan_variance(data, rate, taus=None):
    """
    Calculate Allan variance for sensor data

    Parameters:
    - data: 1D array of sensor measurements
    - rate: Sampling rate (Hz)
    - taus: Array of cluster times (tau values) to analyze

    Returns:
    - tau: Array of cluster times
    - adev: Array of Allan deviations
    """
    if taus is None:
        # Generate logarithmically spaced tau values
        max_tau = len(data) / (2 * rate)  # Maximum meaningful tau
        log_tau_min = np.log10(1.0 / rate)  # Minimum tau (one sample period)
        log_tau_max = np.log10(max_tau)
        taus = np.logspace(log_tau_min, log_tau_max, num=50)

    tau_values = []
    allan_dev = []

    for tau in taus:
        # Number of samples per cluster
        n = int(tau * rate)
        if n < 2:
            continue

        # Number of clusters
        num_clusters = len(data) // n
        if num_clusters < 2:
            continue

        # Calculate cluster averages
        cluster_averages = []
        for i in range(num_clusters):
            start_idx = i * n
            end_idx = start_idx + n
            cluster_avg = np.mean(data[start_idx:end_idx])
            cluster_averages.append(cluster_avg)

        cluster_averages = np.array(cluster_averages)

        # Calculate Allan variance
        diffs = np.diff(cluster_averages)
        allan_var = 0.5 * np.mean(diffs**2)
        allan_dev_val = np.sqrt(allan_var)

        tau_values.append(tau)
        allan_dev.append(allan_dev_val)

    return np.array(tau_values), np.array(allan_dev)

def identify_noise_sources(tau, adev):
    """
    Identify dominant noise sources from Allan variance plot
    Based on the slopes of different regions in log-log plot
    """
    slopes = []
    for i in range(1, len(adev)):
        if tau[i] > tau[i-1] and adev[i] > 0 and adev[i-1] > 0:
            slope = (np.log(adev[i]) - np.log(adev[i-1])) / (np.log(tau[i]) - np.log(tau[i-1]))
            slopes.append(slope)
        else:
            slopes.append(0)

    # Identify noise types based on slopes in log-log plot
    noise_types = []
    for i, slope in enumerate(slopes):
        if -0.6 <= slope <= -0.4:  # Quantization noise
            noise_types.append('quantization')
        elif -0.1 <= slope <= 0.1:  # White noise
            noise_types.append('white_noise')
        elif 0.4 <= slope <= 0.6:  # Flicker noise (1/f)
            noise_types.append('flicker_noise')
        elif 0.9 <= slope <= 1.1:  # Rate ramp
            noise_types.append('rate_ramp')
        elif 1.4 <= slope <= 1.6:  # Rate random walk
            noise_types.append('rate_random_walk')
        else:
            noise_types.append('unknown')

    return slopes, noise_types

def fit_allan_variance_model(tau, adev, sensor_type='accelerometer'):
    """
    Fit theoretical Allan variance model to experimental data
    to extract noise parameters
    """
    from scipy.optimize import curve_fit

    def allan_variance_model(tau, Q, N, B, K, R):
        """
        Combined Allan variance model with multiple noise sources
        Q: Quantization noise coefficient
        N: White noise coefficient
        B: Bias instability coefficient
        K: Rate random walk coefficient
        R: Rate ramp coefficient
        """
        # Quantization noise: Q^2 / tau
        quantization = Q**2 / tau

        # White noise: N^2
        white = N**2 * np.ones_like(tau)

        # Bias instability: 2*ln(2)*B^2 (for tau < correlation time)
        bias = 2 * np.log(2) * B**2 * np.ones_like(tau)

        # Rate random walk: K^2 * tau
        rate_walk = K**2 * tau

        # Rate ramp: R^2 * tau^2
        ramp = R**2 * tau**2

        return quantization + white + bias + rate_walk + ramp

    # Initial guess for parameters
    N_guess = np.min(adev)  # White noise floor
    B_guess = np.max(adev) * 0.1  # Bias instability
    K_guess = np.max(adev) / np.max(tau)  # Rate random walk
    Q_guess = N_guess * np.sqrt(np.min(tau))  # Quantization
    R_guess = B_guess / np.max(tau)  # Rate ramp

    initial_guess = [Q_guess, N_guess, B_guess, K_guess, R_guess]

    try:
        popt, pcov = curve_fit(allan_variance_model, tau, adev**2, p0=initial_guess)
        return popt, pcov
    except:
        return initial_guess, np.eye(5)  # Return initial guess if fitting fails
```

## Sensor Calibration Models

### Intrinsic Calibration Parameters

Sensors have intrinsic parameters that need calibration:

```python
class SensorCalibrationModel:
    def __init__(self, sensor_type='accelerometer'):
        """
        Generic sensor calibration model

        Calibration parameters include:
        - Scale factor errors
        - Misalignment errors
        - Bias errors
        - Non-orthogonality errors
        """
        self.sensor_type = sensor_type
        self.calibration_matrix = np.eye(3)  # 3x3 calibration matrix
        self.bias_vector = np.zeros(3)       # 3x1 bias vector
        self.scale_factors = np.ones(3)      # 3x1 scale factors
        self.misalignment_matrix = np.eye(3) # 3x3 misalignment matrix

        # Initialize with realistic values based on sensor type
        self.initialize_calibration_parameters()

    def initialize_calibration_parameters(self):
        """Initialize calibration parameters based on sensor type"""
        if self.sensor_type == 'accelerometer':
            # Typical accelerometer calibration parameters
            self.scale_factors = np.array([1.002, 0.998, 1.001])  # ~0.1-0.2% scale error
            # Small misalignment
            self.misalignment_matrix = np.array([
                [1.0, 0.001, 0.002],   # X axis has small Y, Z components
                [0.0015, 1.0, 0.001],  # Y axis has small X, Z components
                [0.002, 0.0015, 1.0]   # Z axis has small X, Y components
            ])
            # Small bias
            self.bias_vector = np.array([0.01, -0.02, 0.05])  # ~mg bias

        elif self.sensor_type == 'gyroscope':
            # Typical gyroscope calibration parameters
            self.scale_factors = np.array([1.001, 0.999, 1.002])  # ~0.1% scale error
            # Small misalignment
            self.misalignment_matrix = np.array([
                [1.0, 0.002, 0.001],
                [0.001, 1.0, 0.002],
                [0.002, 0.001, 1.0]
            ])
            # Small bias (in rad/s)
            self.bias_vector = np.array([0.0001, -0.0002, 0.00015])  # ~0.005-0.01 deg/s bias

        elif self.sensor_type == 'magnetometer':
            # Typical magnetometer calibration parameters
            self.scale_factors = np.array([1.02, 0.98, 1.01])  # ~1-2% scale error
            # Larger misalignment for magnetometers
            self.misalignment_matrix = np.array([
                [1.0, 0.01, 0.02],
                [0.015, 1.0, 0.01],
                [0.02, 0.015, 1.0]
            ])
            # Larger bias
            self.bias_vector = np.array([5e-6, -3e-6, 7e-6])  # ~5-10 nT bias

        # Combine scale factors and misalignment into calibration matrix
        scale_matrix = np.diag(self.scale_factors)
        self.calibration_matrix = np.dot(scale_matrix, self.misalignment_matrix)

    def calibrate_measurement(self, raw_measurement):
        """Apply calibration to raw sensor measurement"""
        # Apply calibration matrix
        calibrated = np.dot(self.calibration_matrix, raw_measurement)

        # Add bias
        calibrated += self.bias_vector

        return calibrated

    def add_calibration_uncertainty(self, measurement, uncertainty_factor=0.1):
        """Add uncertainty to calibrated measurement"""
        # Add small uncertainty to account for calibration imperfections
        uncertainty = np.random.normal(0, uncertainty_factor, measurement.shape)
        return measurement + uncertainty
```

### Temperature Compensation Models

Temperature affects sensor performance:

```python
class TemperatureCompensationModel:
    def __init__(self, sensor_type='accelerometer'):
        """
        Temperature compensation model for sensors

        Parameters vary with temperature according to:
        P(T) = P_ref + k * (T - T_ref)
        where k is the temperature coefficient
        """
        self.sensor_type = sensor_type
        self.reference_temperature = 25.0  # Reference temperature in Celsius

        # Temperature coefficients based on sensor type
        self.initialize_temperature_coefficients()

    def initialize_temperature_coefficients(self):
        """Initialize temperature coefficients for different sensors"""
        if self.sensor_type == 'accelerometer':
            # Temperature coefficients in units per °C
            self.bias_temp_coeff = np.array([1e-5, 1e-5, 1e-5])  # Bias drift per °C
            self.scale_temp_coeff = np.array([1e-5, 1e-5, 1e-5])  # Scale factor drift per °C
            self.nonlinearity_temp_coeff = 1e-7  # Nonlinearity change per °C

        elif self.sensor_type == 'gyroscope':
            # Gyroscope temperature coefficients
            self.bias_temp_coeff = np.array([1e-6, 1e-6, 1e-6])  # ~0.0036 deg/s/°C
            self.scale_temp_coeff = np.array([1e-6, 1e-6, 1e-6])
            self.nonlinearity_temp_coeff = 1e-8

        elif self.sensor_type == 'magnetometer':
            # Magnetometer temperature coefficients
            self.bias_temp_coeff = np.array([1e-8, 1e-8, 1e-8])  # ~1 nT/°C
            self.scale_temp_coeff = np.array([1e-7, 1e-7, 1e-7])  # ~0.1%/°C
            self.nonlinearity_temp_coeff = 1e-9

    def compensate_temperature(self, measurement, temperature):
        """Apply temperature compensation to measurement"""
        temp_diff = temperature - self.reference_temperature

        # Apply bias compensation
        bias_correction = self.bias_temp_coeff * temp_diff
        compensated = measurement - bias_correction

        # Apply scale factor compensation
        scale_correction = 1.0 + self.scale_temp_coeff * temp_diff
        compensated = compensated / scale_correction

        return compensated
```

## Real-Time Noise Simulation

### Efficient Noise Generation

For real-time simulation, efficient noise generation is crucial:

```python
import numba
from numba import jit
import numpy as np

@jit(nopython=True)
def fast_gaussian_noise(mean, std_dev, size):
    """Fast Gaussian noise generation using Numba JIT"""
    result = np.empty(size, dtype=np.float64)
    for i in range(size):
        # Box-Muller transform for Gaussian generation
        u1 = np.random.random()
        u2 = np.random.random()
        z = np.sqrt(-2 * np.log(u1)) * np.cos(2 * np.pi * u2)
        result[i] = mean + std_dev * z
    return result

@jit(nopython=True)
def fast_gauss_markov_update(current_state, beta, noise_std, dt):
    """Fast Gauss-Markov process update"""
    exp_term = np.exp(-beta * dt)
    noise_term = noise_std * np.sqrt((1 - exp_term**2) / (2 * beta))
    return current_state * exp_term + np.random.normal(0, noise_term)

class EfficientNoiseGenerator:
    def __init__(self):
        """Efficient noise generator for real-time applications"""
        self.gauss_markov_states = np.zeros(3)  # For 3-axis sensors
        self.random_walk_states = np.zeros(3)

    def generate_all_noise(self, dt, noise_params):
        """
        Generate all noise components efficiently

        noise_params: dict with noise parameters
        """
        total_noise = np.zeros(3)

        # White noise component
        if 'white_std' in noise_params:
            white_noise = fast_gaussian_noise(0, noise_params['white_std'], 3)
            total_noise += white_noise

        # Gauss-Markov bias component
        if 'bias_std' in noise_params and 'bias_tc' in noise_params:
            beta = 1.0 / noise_params['bias_tc']
            for i in range(3):
                self.gauss_markov_states[i] = fast_gauss_markov_update(
                    self.gauss_markov_states[i],
                    beta,
                    noise_params['bias_std'],
                    dt
                )
            total_noise += self.gauss_markov_states

        # Random walk component
        if 'walk_coeff' in noise_params:
            walk_increments = fast_gaussian_noise(
                0,
                noise_params['walk_coeff'] * np.sqrt(dt),
                3
            )
            self.random_walk_states += walk_increments
            total_noise += self.random_walk_states

        return total_noise
```

## Sensor Fusion with Noise Models

### Extended Kalman Filter for IMU

Integrate noise models into sensor fusion:

```python
class IMUKalmanFilter:
    def __init__(self, accel_params, gyro_params):
        """
        Extended Kalman Filter for IMU sensor fusion

        Incorporates noise models for state estimation
        """
        # State: [q_w, q_x, q_y, q_z, b_x, b_y, b_z] (orientation + gyro bias)
        self.state = np.array([1, 0, 0, 0, 0, 0, 0], dtype=np.float64)  # [qw, qx, qy, qz, bx, by, bz]

        # Covariance matrix
        self.P = np.eye(7) * 0.1  # Initial uncertainty

        # Process noise (from IMU noise models)
        self.Q = self.initialize_process_noise(accel_params, gyro_params)

        # Measurement noise
        self.R = np.eye(6) * 0.01  # [accel, mag] measurements

        # Previous time step
        self.prev_time = None

    def initialize_process_noise(self, accel_params, gyro_params):
        """Initialize process noise matrix based on sensor parameters"""
        Q = np.zeros((7, 7))

        # Orientation process noise (from gyroscope noise)
        q_angular = gyro_params.arw_density**2  # Angular velocity noise
        Q[0:4, 0:4] = np.eye(4) * q_angular * 0.1  # Orientation uncertainty

        # Bias process noise (from bias instability)
        q_bias = gyro_params.bias_instability**2
        Q[4:7, 4:7] = np.eye(3) * q_bias * 0.01  # Bias uncertainty

        return Q

    def predict(self, gyro_measurement, dt):
        """Prediction step using gyroscope measurement"""
        if self.prev_time is not None:
            # Extract orientation quaternion and bias
            q = self.state[0:4]
            bias = self.state[4:7]

            # Corrected angular velocity
            omega = gyro_measurement - bias

            # Quaternion derivative
            omega_skew = np.array([
                [0, -omega[0], -omega[1], -omega[2]],
                [omega[0], 0, omega[2], -omega[1]],
                [omega[1], -omega[2], 0, omega[0]],
                [omega[2], omega[1], -omega[0], 0]
            ])

            # Update quaternion (integration)
            q_dot = 0.5 * np.dot(omega_skew, q)
            q_new = q + q_dot * dt

            # Normalize quaternion
            q_new = q_new / np.linalg.norm(q_new)

            # Update state
            self.state[0:4] = q_new
            # Bias remains the same in prediction (random walk)

            # State transition Jacobian
            F = self.compute_jacobian(omega, dt)

            # Predict covariance
            self.P = np.dot(F, np.dot(self.P, F.T)) + self.Q

    def compute_jacobian(self, omega, dt):
        """Compute state transition Jacobian"""
        F = np.eye(7)

        # Linearize quaternion propagation
        omega_norm = np.linalg.norm(omega)
        if omega_norm > 1e-6:
            axis = omega / omega_norm
            angle = omega_norm * dt

            # Quaternion propagation Jacobian
            # This is a simplified version - full derivation is more complex
            F[0:4, 0:4] = self.quaternion_jacobian(omega, dt)

        return F

    def quaternion_jacobian(self, omega, dt):
        """Compute quaternion propagation Jacobian"""
        # Simplified Jacobian computation
        # In practice, this would be derived from quaternion kinematics
        norm = np.linalg.norm(omega)
        if norm < 1e-6:
            return np.eye(4)

        axis = omega / norm
        angle = norm * dt

        # Jacobian computation (simplified)
        J = np.eye(4)  # Placeholder for actual Jacobian
        return J

    def update(self, accel_measurement, mag_measurement):
        """Update step using accelerometer and magnetometer measurements"""
        # Measurement model: extract expected measurements from state
        # This is a simplified example - full implementation would be more complex

        # Compute innovation
        # In a real implementation, this would compare predicted vs actual measurements

        # Compute Kalman gain and update state
        # This is where measurement noise (R) affects the filter
        pass
```

## Validation and Testing

### Noise Parameter Estimation

Validate noise models against real data:

```python
def estimate_noise_parameters_from_data(measurement_data, sample_rate):
    """
    Estimate noise parameters from measured sensor data
    using Allan variance analysis
    """
    # Calculate Allan variance for each axis
    allan_results = {}

    for axis in range(3):  # For 3-axis sensors
        axis_data = measurement_data[:, axis]
        tau, adev = calculate_allan_variance(axis_data, sample_rate)

        # Fit theoretical model to extract parameters
        params, cov = fit_allan_variance_model(tau, adev)

        allan_results[f'axis_{axis}'] = {
            'tau': tau,
            'adev': adev,
            'fitted_params': params,
            'covariance': cov
        }

    return allan_results

def validate_noise_model(true_signal, noisy_signal, expected_noise_params):
    """
    Validate that the generated noise matches expected characteristics
    """
    results = {}

    # Calculate statistics
    noise_samples = noisy_signal - true_signal
    mean_noise = np.mean(noise_samples, axis=0)
    std_noise = np.std(noise_samples, axis=0)

    results['mean_error'] = np.mean(np.abs(mean_noise))
    results['std_match'] = np.mean(np.abs(std_noise - expected_noise_params.std_dev))

    # Perform statistical tests
    from scipy import stats

    # Kolmogorov-Smirnov test for distribution match
    for i in range(3):
        ks_stat, ks_p = stats.kstest(
            noise_samples[:, i],
            lambda x: stats.norm.cdf(x, loc=0, scale=expected_noise_params.std_dev[i])
        )
        results[f'ks_test_axis_{i}'] = {'statistic': ks_stat, 'p_value': ks_p}

    # Validate correlation properties
    autocorr = np.array([np.corrcoef(noise_samples[:-1, i], noise_samples[1:, i])[0, 1]
                        for i in range(3)])
    results['autocorrelation'] = autocorr

    return results
```

### Calibration Validation

Validate calibration procedures:

```python
def validate_calibration(calibrated_measurements, reference_values, tolerance=0.01):
    """
    Validate sensor calibration against reference values
    """
    errors = np.abs(calibrated_measurements - reference_values)
    mean_error = np.mean(errors)
    max_error = np.max(errors)

    # Check if calibration is within tolerance
    within_tolerance = np.mean(errors < tolerance) > 0.95  # 95% of samples within tolerance

    return {
        'mean_error': mean_error,
        'max_error': max_error,
        'within_tolerance': within_tolerance,
        'error_distribution': errors
    }

def simulate_calibration_procedure(sensor_data, gravity_vector=[0, 0, 9.81]):
    """
    Simulate accelerometer calibration using multiple orientations
    """
    # Collect data in different orientations
    orientations = [
        [0, 0, 9.81],    # Z-up
        [0, 0, -9.81],   # Z-down
        [0, 9.81, 0],    # Y-up
        [0, -9.81, 0],   # Y-down
        [9.81, 0, 0],    # X-up
        [-9.81, 0, 0]    # X-down
    ]

    calibration_data = []
    reference_data = []

    for i, ref_vec in enumerate(orientations):
        # Simulate sensor readings in this orientation
        # Add noise and bias to simulate real measurements
        measured = np.array(ref_vec) + np.random.normal(0, 0.01, 3) + [0.02, -0.01, 0.03]

        calibration_data.append(measured)
        reference_data.append(ref_vec)

    calibration_data = np.array(calibration_data)
    reference_data = np.array(reference_data)

    # Perform least squares calibration
    # Model: measured = A * true + b, solve for A and b
    # Rearrange: measured - b = A * true, or Y = A * X + b

    # This is a simplified calibration - real calibration is more complex
    # and involves solving for scale factors, misalignments, and biases simultaneously

    # For now, just return the data collected
    return calibration_data, reference_data
```

## Common Issues and Troubleshooting

### Noise Model Issues

- **Incorrect Noise Parameters**: Ensure parameters match actual sensor specifications
- **Temporal Correlation**: Verify that noise processes have correct correlation properties
- **Distribution Mismatch**: Check that generated noise follows expected distribution

### Calibration Issues

- **Insufficient Data**: Collect data from multiple orientations and conditions
- **Outliers**: Remove outliers before calibration to avoid bias
- **Temperature Effects**: Account for temperature variations in calibration

### Performance Issues

- **Real-time Constraints**: Use efficient algorithms and approximations
- **Memory Usage**: Process data in batches to manage memory
- **Computational Load**: Optimize for the target platform

## Best Practices

### 1. Use Realistic Parameters

Base noise parameters on actual sensor datasheets and specifications rather than arbitrary values.

### 2. Validate Against Real Data

Compare simulated noise characteristics to real sensor data when available.

### 3. Include Environmental Effects

Model temperature, humidity, and other environmental factors that affect sensor performance.

### 4. Regular Calibration Updates

Implement procedures for periodic calibration parameter updates during operation.

### 5. Comprehensive Testing

Test noise models under various operating conditions and environments.

## Summary

Sensor noise, drift, and calibration modeling are essential for realistic simulation environments. By understanding the different types of noise, implementing proper statistical models, and validating against real data, you can create simulation systems that accurately represent real-world sensor behavior. Proper noise modeling ensures that algorithms developed in simulation will perform reliably when deployed on physical systems.

## References

1. IEEE Std 952-1997. (1997). IEEE Standard Specification Format Guide and Test Procedure for Single-Axis Laser Gyros.
2. IEEE Std 1293-1998. (1998). IEEE Standard Specification Format Guide and Test Procedure for Linear, Single-Axis, Non-Gyroscopic Accelerometers.
3. El-Sheimy, N., et al. (2004). Analysis and Modeling of Inertial Sensors Using Allan Variance. IEEE Transactions on Instrumentation and Measurement.

## Exercises

1. Implement Allan variance analysis for a real IMU dataset
2. Create a temperature-compensated sensor model
3. Develop a real-time noise generation system for multiple sensors
4. Design a calibration procedure for a multi-sensor system