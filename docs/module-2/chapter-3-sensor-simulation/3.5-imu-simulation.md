# 3.5 IMU Simulation (Accelerometer & Gyroscope)

## Introduction

Inertial Measurement Unit (IMU) simulation is critical for robotics applications requiring motion estimation, attitude control, and sensor fusion. This chapter covers the implementation of realistic IMU sensors in Gazebo, including accelerometer and gyroscope simulation, magnetometer modeling, noise characteristics, and integration with ROS 2. IMU sensors provide essential information about robot orientation, acceleration, and angular velocity for navigation and control systems.

## IMU Fundamentals and Physics

### IMU Sensor Components

An IMU typically consists of three sensor types:

1. **Accelerometer**: Measures linear acceleration along three axes
2. **Gyroscope**: Measures angular velocity around three axes
3. **Magnetometer**: Measures magnetic field strength along three axes

### Accelerometer Physics

Accelerometers measure proper acceleration (acceleration relative to freefall):

```
a_measured = a_true + g*sin(θ) + noise
```

Where:
- a_measured: Measured acceleration
- a_true: True linear acceleration
- g: Gravitational acceleration (9.81 m/s²)
- θ: Tilt angle relative to gravity

### Gyroscope Physics

Gyroscopes measure angular velocity:

```
ω_measured = ω_true + bias + drift + noise
```

Where:
- ω_measured: Measured angular velocity
- ω_true: True angular velocity
- bias: Systematic offset
- drift: Time-varying bias changes
- noise: Random measurement noise

### Coordinate System Conventions

IMU sensors typically use the right-handed coordinate system:
- X: Forward direction
- Y: Left direction
- Z: Up direction (opposite to gravity for ground vehicles)

## Gazebo IMU Implementation

### SDF Configuration

IMU sensors in Gazebo are configured using the `imu` sensor type:

```xml
<sensor name="imu_sensor" type="imu">
  <pose>0.0 0.0 0.0 0 0 0</pose>  <!-- Position relative to parent link -->
  <visualize>false</visualize>    <!-- IMU doesn't have visual representation -->
  <update_rate>100</update_rate>  <!-- High update rate for IMU -->

  <imu>
    <!-- Accelerometer parameters -->
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>  <!-- 1 mrad/s standard deviation -->
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.001</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>
        </noise>
      </z>
    </angular_velocity>

    <!-- Gyroscope parameters -->
    <linear_acceleration>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>  <!-- ~1.7 mg standard deviation -->
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.01</bias_stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.01</bias_stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.017</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.01</bias_stddev>
        </noise>
      </z>
    </linear_acceleration>

    <!-- Magnetometer parameters (optional) -->
    <orientation>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.00174</stddev>  <!-- ~0.1 degree standard deviation -->
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.00174</stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.00174</stddev>
        </noise>
      </z>
    </orientation>
  </imu>

  <plugin name="imu_controller" filename="libgazebo_ros_imu.so">
    <ros>
      <namespace>robot1</namespace>
      <remapping>~/out:=imu/data</remapping>
    </ros>
    <frame_name>robot1/imu_link</frame_name>
    <body_name>base_link</body_name>
    <update_rate>100</update_rate>
    <gaussian_noise>0.0017</gaussian_noise>
    <topic_name>imu/data</topic_name>
    <serviceName>imu_service</serviceName>
  </plugin>
</sensor>
```

### Advanced IMU Configuration

For more sophisticated IMU simulation with realistic sensor characteristics:

```xml
<sensor name="advanced_imu" type="imu">
  <pose>0.0 0.0 0.0 0 0 0</pose>
  <update_rate>200</update_rate>  <!-- Higher update rate -->

  <imu>
    <!-- Advanced accelerometer with temperature effects -->
    <linear_acceleration>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.015</stddev>  <!-- Lower noise for high-quality IMU -->
          <bias_mean>0.001</bias_mean>  <!-- Small bias -->
          <bias_stddev>0.005</bias_stddev>  <!-- Bias instability -->
          <dynamic_bias_stddev>0.001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>100</dynamic_bias_correlation_time>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.015</stddev>
          <bias_mean>0.001</bias_mean>
          <bias_stddev>0.005</bias_stddev>
          <dynamic_bias_stddev>0.001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>100</dynamic_bias_correlation_time>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.015</stddev>
          <bias_mean>0.001</bias_mean>
          <bias_stddev>0.005</bias_stddev>
          <dynamic_bias_stddev>0.001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>100</dynamic_bias_correlation_time>
        </noise>
      </z>
    </linear_acceleration>

    <!-- Advanced gyroscope with realistic drift -->
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.0005</stddev>  <!-- ~0.03 deg/s for high-quality gyro -->
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>  <!-- ~0.06 deg/s bias instability -->
          <dynamic_bias_stddev>0.0001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>300</dynamic_bias_correlation_time>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.0005</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>
          <dynamic_bias_stddev>0.0001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>300</dynamic_bias_correlation_time>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>0.0005</stddev>
          <bias_mean>0.0</bias_mean>
          <bias_stddev>0.001</bias_stddev>
          <dynamic_bias_stddev>0.0001</dynamic_bias_stddev>
          <dynamic_bias_correlation_time>300</dynamic_bias_correlation_time>
        </noise>
      </z>
    </angular_velocity>

    <!-- Magnetometer for heading reference -->
    <magnetic_field>
      <x>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>6e-07</stddev>  <!-- ~600 nT noise for magnetometer -->
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>6e-07</stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0.0</mean>
          <stddev>6e-07</stddev>
        </noise>
      </z>
    </magnetic_field>

    <!-- Gravity vector (for reference) -->
    <gravity_dir>
      <x>0</x>
      <y>0</y>
      <z>1</z>
    </gravity_dir>
  </imu>

  <plugin name="advanced_imu_controller" filename="libgazebo_ros_imu.so">
    <ros>
      <namespace>robot1</namespace>
      <remapping>~/out:=imu/data_raw</remapping>
    </ros>
    <frame_name>robot1/imu_link</frame_name>
    <body_name>base_link</body_name>
    <update_rate>200</update_rate>
    <gaussian_noise>0.001</gaussian_noise>
    <topic_name>imu/data_raw</topic_name>
  </plugin>
</sensor>
```

## IMU Noise Modeling

### Accelerometer Noise Model

Realistic accelerometer noise includes multiple components:

```python
import numpy as np
from scipy import integrate
import math

class AccelerometerNoiseModel:
    def __init__(self, parameters):
        # Noise parameters based on sensor specifications
        self.accel_noise_density = parameters.accel_noise_density  # m/s²/√Hz
        self.accel_bias_instability = parameters.accel_bias_instability  # m/s²
        self.accel_random_walk = parameters.accel_random_walk  # m/s²/√s
        self.accel_rate = parameters.update_rate  # Hz

        # Initialize bias random walk
        self.accel_bias_rw = np.zeros(3)
        self.accel_bias = np.random.normal(0, self.accel_bias_instability, 3)

    def generate_noise(self, dt):
        """Generate accelerometer noise for time step dt"""
        # White noise component (velocity random walk)
        white_noise_std = self.accel_noise_density * math.sqrt(self.accel_rate / 2)
        white_noise = np.random.normal(0, white_noise_std, 3)

        # Bias random walk (correlated over time)
        bias_rw_std = self.accel_random_walk * math.sqrt(dt)
        self.accel_bias_rw += np.random.normal(0, bias_rw_std, 3)

        # Combine all noise components
        total_noise = white_noise + self.accel_bias + self.accel_bias_rw

        return total_noise

    def update_bias(self, dt):
        """Update bias using first-order Gauss-Markov process"""
        # First-order Gauss-Markov model for bias instability
        time_constant = 100.0  # Correlation time in seconds
        bias_drift_std = self.accel_bias_instability * math.sqrt(1 - math.exp(-2 * dt / time_constant))

        # Update bias with correlation
        self.accel_bias = self.accel_bias * math.exp(-dt / time_constant) + \
                         np.random.normal(0, bias_drift_std, 3)

class GyroscopeNoiseModel:
    def __init__(self, parameters):
        # Noise parameters based on sensor specifications
        self.gyro_noise_density = parameters.gyro_noise_density  # rad/s/√Hz
        self.gyro_bias_instability = parameters.gyro_bias_instability  # rad/s
        self.gyro_random_walk = parameters.gyro_random_walk  # rad/s/√s
        self.gyro_rate = parameters.update_rate  # Hz

        # Initialize bias random walk
        self.gyro_bias_rw = np.zeros(3)
        self.gyro_bias = np.random.normal(0, self.gyro_bias_instability, 3)

    def generate_noise(self, dt):
        """Generate gyroscope noise for time step dt"""
        # White noise component (angular velocity random walk)
        white_noise_std = self.gyro_noise_density * math.sqrt(self.gyro_rate / 2)
        white_noise = np.random.normal(0, white_noise_std, 3)

        # Bias random walk (correlated over time)
        bias_rw_std = self.gyro_random_walk * math.sqrt(dt)
        self.gyro_bias_rw += np.random.normal(0, bias_rw_std, 3)

        # Combine all noise components
        total_noise = white_noise + self.gyro_bias + self.gyro_bias_rw

        return total_noise

    def update_bias(self, dt):
        """Update bias using first-order Gauss-Markov process"""
        # First-order Gauss-Markov model for bias instability
        time_constant = 300.0  # Correlation time in seconds for gyro bias
        bias_drift_std = self.gyro_bias_instability * math.sqrt(1 - math.exp(-2 * dt / time_constant))

        # Update bias with correlation
        self.gyro_bias = self.gyro_bias * math.exp(-dt / time_constant) + \
                        np.random.normal(0, bias_drift_std, 3)
```

### Allan Variance Analysis

Allan variance is used to characterize IMU noise:

```python
def calculate_allan_variance(data, rate):
    """Calculate Allan variance for IMU data analysis"""
    tau = []  # Cluster times
    adev = []  # Allan deviation

    # Different cluster times
    cluster_times = [1, 2, 4, 8, 16, 32, 64, 128]

    for n in cluster_times:
        dt = n / rate  # Time interval for clusters
        tau.append(dt)

        # Number of clusters
        num_clusters = len(data) // n

        if num_clusters < 2:
            break

        # Calculate cluster averages
        cluster_averages = []
        for i in range(num_clusters):
            start_idx = i * n
            end_idx = start_idx + n
            cluster_avg = np.mean(data[start_idx:end_idx])
            cluster_averages.append(cluster_avg)

        # Calculate Allan variance
        cluster_avgs = np.array(cluster_averages)
        diffs = np.diff(cluster_avgs)
        allan_var = 0.5 * np.mean(diffs**2)
        allan_dev = np.sqrt(allan_var)

        adev.append(allan_dev)

    return np.array(tau), np.array(adev)

def analyze_imu_noise(accel_data, gyro_data, rate):
    """Analyze IMU noise characteristics using Allan variance"""
    results = {}

    # Analyze each axis
    for axis in range(3):
        # Accelerometer analysis
        tau_acc, adev_acc = calculate_allan_variance(accel_data[:, axis], rate)
        results[f'acc_axis_{axis}'] = {'tau': tau_acc, 'adev': adev_acc}

        # Gyroscope analysis
        tau_gyro, adev_gyro = calculate_allan_variance(gyro_data[:, axis], rate)
        results[f'gyro_axis_{axis}'] = {'tau': tau_gyro, 'adev': adev_gyro}

    return results
```

## Magnetometer Simulation

### Magnetic Field Modeling

Magnetometer simulation includes Earth's magnetic field and disturbances:

```python
class MagnetometerSimulator:
    def __init__(self, parameters):
        # Magnetic field parameters
        self.reference_field = parameters.reference_field  # Earth's magnetic field
        self.noise_density = parameters.magnetometer_noise_density  # T/√Hz
        self.bias_instability = parameters.magnetometer_bias_instability  # T
        self.update_rate = parameters.update_rate

        # Initialize bias
        self.bias = np.random.normal(0, self.bias_instability, 3)

    def generate_earth_field(self, latitude, longitude, altitude):
        """Generate Earth's magnetic field at given location"""
        # Simplified model - in practice, use IGRF (International Geomagnetic Reference Field)
        # Typical values for mid-latitudes
        field_strength = 50e-6  # 50 μT
        inclination = 60 * np.pi / 180  # 60 degrees in radians

        # Magnetic field components
        field = np.array([
            field_strength * np.cos(inclination),  # Horizontal component
            0.0,  # East component (simplified)
            field_strength * np.sin(inclination)   # Vertical component
        ])

        return field

    def add_disturbances(self, field, environment):
        """Add magnetic disturbances based on environment"""
        disturbed_field = field.copy()

        # Ferromagnetic disturbances (permanent magnets nearby)
        if environment.contains_ferromagnetic:
            ferro_disturbance = np.random.normal(0, 5e-6, 3)  # 5 μT disturbance
            disturbed_field += ferro_disturbance

        # Hard iron effects (permanent magnetization of platform)
        hard_iron = np.random.normal(0, 2e-6, 3)  # 2 μT hard iron effect
        disturbed_field += hard_iron

        # Soft iron effects (induced magnetization)
        soft_iron_matrix = np.eye(3) + np.random.normal(0, 0.01, (3, 3))
        disturbed_field = np.dot(soft_iron_matrix, disturbed_field)

        return disturbed_field

    def generate_measurement(self, true_field, dt):
        """Generate magnetometer measurement with noise"""
        # Add noise
        noise_std = self.noise_density * np.sqrt(self.update_rate / 2)
        noise = np.random.normal(0, noise_std, 3)

        # Add bias (with random walk)
        self.bias += np.random.normal(0, self.bias_instability * np.sqrt(dt), 3)

        # Generate measurement
        measurement = true_field + noise + self.bias

        return measurement
```

## ROS 2 Integration

### IMU Publishers and Message Types

IMU data is published using sensor_msgs/Imu messages:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu, MagneticField
from geometry_msgs.msg import Vector3, Quaternion
from std_msgs.msg import Header
import numpy as np
import math

class IMUSimulator(Node):
    def __init__(self):
        super().__init__('imu_simulator')

        # Publisher for IMU data
        self.imu_publisher = self.create_publisher(
            Imu,
            '/robot1/imu/data',
            10
        )

        # Publisher for magnetic field data (if magnetometer available)
        self.mag_publisher = self.create_publisher(
            MagneticField,
            '/robot1/imu/magnetic_field',
            10
        )

        # Timer for publishing at IMU rate
        self.timer = self.create_timer(0.01, self.publish_imu_data)  # 100Hz

        # Initialize IMU noise models
        self.accel_noise_model = self.initialize_accelerometer_model()
        self.gyro_noise_model = self.initialize_gyroscope_model()
        self.mag_simulator = self.initialize_magnetometer()

        # State variables
        self.last_time = self.get_clock().now()
        self.linear_acceleration = Vector3()
        self.angular_velocity = Vector3()
        self.orientation = Quaternion()

    def initialize_accelerometer_model(self):
        """Initialize accelerometer noise model"""
        class AccelParams:
            accel_noise_density = 0.08  # m/s²/√Hz (for ADIS16448)
            accel_bias_instability = 0.002  # m/s²
            accel_random_walk = 0.0004  # m/s²/√s
            update_rate = 100  # Hz

        return AccelerometerNoiseModel(AccelParams())

    def initialize_gyroscope_model(self):
        """Initialize gyroscope noise model"""
        class GyroParams:
            gyro_noise_density = 0.004  # rad/s/√Hz (for ADIS16448)
            gyro_bias_instability = 0.0087  # rad/s (5 deg/s)
            gyro_random_walk = 0.000004847  # rad/s/√s
            update_rate = 100  # Hz

        return GyroscopeNoiseModel(GyroParams())

    def initialize_magnetometer(self):
        """Initialize magnetometer simulator"""
        class MagParams:
            reference_field = np.array([25e-6, 0, 42e-6])  # Earth's field (T)
            magnetometer_noise_density = 600e-9  # T/√Hz
            magnetometer_bias_instability = 1e-6  # T
            update_rate = 100  # Hz

        return MagnetometerSimulator(MagParams())

    def publish_imu_data(self):
        """Generate and publish IMU data"""
        current_time = self.get_clock().now()
        dt = (current_time.nanoseconds - self.last_time.nanoseconds) / 1e9
        self.last_time = current_time

        # Simulate true motion (this would come from Gazebo physics)
        true_linear_acceleration = self.get_true_acceleration()
        true_angular_velocity = self.get_true_angular_velocity()

        # Add noise to measurements
        accel_noise = self.accel_noise_model.generate_noise(dt)
        gyro_noise = self.gyro_noise_model.generate_noise(dt)

        # Update biases
        self.accel_noise_model.update_bias(dt)
        self.gyro_noise_model.update_bias(dt)

        # Create IMU message
        imu_msg = Imu()
        imu_msg.header = Header()
        imu_msg.header.stamp = current_time.to_msg()
        imu_msg.header.frame_id = 'robot1/imu_link'

        # Linear acceleration (with gravity)
        imu_msg.linear_acceleration.x = true_linear_acceleration[0] + accel_noise[0]
        imu_msg.linear_acceleration.y = true_linear_acceleration[1] + accel_noise[1]
        imu_msg.linear_acceleration.z = true_linear_acceleration[2] + accel_noise[2] + 9.81  # Add gravity

        # Angular velocity
        imu_msg.angular_velocity.x = true_angular_velocity[0] + gyro_noise[0]
        imu_msg.angular_velocity.y = true_angular_velocity[1] + gyro_noise[1]
        imu_msg.angular_velocity.z = true_angular_velocity[2] + gyro_noise[2]

        # Orientation (integrate angular velocity to get orientation)
        # In practice, this would be computed using proper integration
        # or obtained from Gazebo's state
        imu_msg.orientation = self.integrate_orientation(
            true_angular_velocity, dt
        )

        # Covariance matrices (set based on sensor specifications)
        # Acceleration covariance
        imu_msg.linear_acceleration_covariance = [
            0.0001, 0, 0,
            0, 0.0001, 0,
            0, 0, 0.0001
        ]

        # Angular velocity covariance
        imu_msg.angular_velocity_covariance = [
            0.0001, 0, 0,
            0, 0.0001, 0,
            0, 0, 0.0001
        ]

        # Orientation covariance
        imu_msg.orientation_covariance = [
            0.01, 0, 0,
            0, 0.01, 0,
            0, 0, 0.01
        ]

        # Publish IMU message
        self.imu_publisher.publish(imu_msg)

        # Publish magnetic field data if available
        self.publish_magnetic_field(current_time)

    def get_true_acceleration(self):
        """Get true acceleration from simulation (simplified)"""
        # This would interface with Gazebo physics
        # For now, return a simple simulation
        t = self.get_clock().now().nanoseconds / 1e9
        return np.array([
            0.1 * math.sin(0.5 * t),  # Small oscillating acceleration
            0.05 * math.cos(0.3 * t),
            0.0  # No vertical acceleration in this simple model
        ])

    def get_true_angular_velocity(self):
        """Get true angular velocity from simulation (simplified)"""
        # This would interface with Gazebo physics
        # For now, return a simple simulation
        t = self.get_clock().now().nanoseconds / 1e9
        return np.array([
            0.01 * math.sin(0.2 * t),  # Small angular velocity
            0.005 * math.cos(0.1 * t),
            0.02 * math.sin(0.3 * t)
        ])

    def integrate_orientation(self, angular_velocity, dt):
        """Integrate angular velocity to get orientation"""
        # Convert angular velocity to quaternion derivative
        # This is a simplified integration - in practice, use proper quaternion integration
        w = angular_velocity
        norm = np.linalg.norm(w)

        if norm > 1e-6:  # Avoid division by zero
            axis = w / norm
            angle = norm * dt

            # Convert axis-angle to quaternion
            s = math.sin(angle / 2)
            c = math.cos(angle / 2)

            q = Quaternion()
            q.x = axis[0] * s
            q.y = axis[1] * s
            q.z = axis[2] * s
            q.w = c
        else:
            # No rotation
            q = Quaternion()
            q.w = 1.0
            q.x = 0.0
            q.y = 0.0
            q.z = 0.0

        return q

    def publish_magnetic_field(self, timestamp):
        """Publish magnetic field data"""
        # Generate Earth's magnetic field
        earth_field = self.mag_simulator.generate_earth_field(45, -75, 0)  # Example location
        disturbed_field = self.mag_simulator.add_disturbances(earth_field, type('obj', (object,),
            {'contains_ferromagnetic': False})())

        # Add noise
        dt = 0.01  # 100Hz
        measurement = self.mag_simulator.generate_measurement(disturbed_field, dt)

        # Create magnetic field message
        mag_msg = MagneticField()
        mag_msg.header.stamp = timestamp.to_msg()
        mag_msg.header.frame_id = 'robot1/imu_link'

        mag_msg.magnetic_field.x = measurement[0]
        mag_msg.magnetic_field.y = measurement[1]
        mag_msg.magnetic_field.z = measurement[2]

        # Magnetic field covariance
        mag_msg.magnetic_field_covariance = [1e-10, 0, 0, 0, 1e-10, 0, 0, 0, 1e-10]

        self.mag_publisher.publish(mag_msg)
```

### TF Integration for IMU

Proper coordinate frame management for IMU:

```python
import tf2_ros
from geometry_msgs.msg import TransformStamped

class IMUTFPublisher(Node):
    def __init__(self):
        super().__init__('imu_tf_publisher')

        # Create transform broadcaster
        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)

        # Timer for publishing transforms
        self.tf_timer = self.create_timer(0.01, self.publish_transforms)  # 100Hz

    def publish_transforms(self):
        """Publish IMU transform"""
        t = TransformStamped()

        t.header.stamp = self.get_clock().now().to_msg()
        t.header.frame_id = 'robot1/base_link'
        t.child_frame_id = 'robot1/imu_link'

        # Set translation (position of IMU relative to base)
        t.transform.translation.x = 0.0  # Usually at center of robot
        t.transform.translation.y = 0.0
        t.transform.translation.z = 0.0

        # Set rotation (orientation of IMU relative to base)
        # IMU should be aligned with robot coordinate frame
        t.transform.rotation.x = 0.0
        t.transform.rotation.y = 0.0
        t.transform.rotation.z = 0.0
        t.transform.rotation.w = 1.0

        self.tf_broadcaster.sendTransform(t)
```

## Sensor Fusion Integration

### Complementary Filter Example

Basic sensor fusion using IMU data:

```python
class ComplementaryFilter:
    def __init__(self, alpha=0.98):
        self.alpha = alpha  # Filter parameter (typically 0.95-0.99)
        self.orientation = np.array([0, 0, 0, 1])  # [x, y, z, w] quaternion
        self.gravity_vector = np.array([0, 0, 1])  # Gravity in IMU frame

    def update(self, accel, gyro, dt):
        """Update filter with accelerometer and gyroscope data"""
        # Normalize accelerometer data
        accel_norm = np.linalg.norm(accel)
        if accel_norm > 0:
            accel_unit = accel / accel_norm
        else:
            accel_unit = np.array([0, 0, 1])  # Default to gravity direction

        # Get gravity estimate from accelerometer
        gravity_estimate = self.estimate_gravity_from_accel(accel_unit)

        # Integrate gyroscope data for orientation
        gyro_orientation = self.integrate_gyro(gyro, dt)

        # Combine estimates using complementary filter
        # High frequency: gyroscope (good for fast changes)
        # Low frequency: accelerometer (good for stable reference)

        # Convert current orientation to rotation matrix
        R = self.quaternion_to_rotation_matrix(self.orientation)

        # Apply gyroscope update
        self.orientation = self.multiply_quaternions(
            self.orientation,
            self.angular_velocity_to_quaternion(gyro, dt)
        )

        # Apply accelerometer correction (low-frequency correction)
        current_gravity = R.T @ np.array([0, 0, 1])  # Current estimate of gravity direction
        error = np.cross(current_gravity, gravity_estimate)

        # Apply correction
        correction = self.alpha * error
        correction_quat = self.vector_to_quaternion(correction * dt)
        self.orientation = self.multiply_quaternions(self.orientation, correction_quat)

        # Normalize quaternion
        self.orientation = self.orientation / np.linalg.norm(self.orientation)

        return self.orientation

    def estimate_gravity_from_accel(self, accel_unit):
        """Estimate gravity direction from accelerometer"""
        # For stationary robot, accelerometer measures gravity
        # For moving robot, we need to separate gravity from linear acceleration
        # This is a simplified approach
        return -accel_unit  # Gravity is opposite to measured acceleration

    def integrate_gyro(self, gyro, dt):
        """Integrate gyroscope data"""
        angle = np.linalg.norm(gyro) * dt
        if angle > 1e-6:
            axis = gyro / np.linalg.norm(gyro)
            s = np.sin(angle / 2)
            c = np.cos(angle / 2)
            return np.array([axis[0] * s, axis[1] * s, axis[2] * s, c])
        else:
            return np.array([0, 0, 0, 1])

    def quaternion_to_rotation_matrix(self, q):
        """Convert quaternion to rotation matrix"""
        x, y, z, w = q
        return np.array([
            [1 - 2*(y**2 + z**2), 2*(x*y - w*z), 2*(x*z + w*y)],
            [2*(x*y + w*z), 1 - 2*(x**2 + z**2), 2*(y*z - w*x)],
            [2*(x*z - w*y), 2*(y*z + w*x), 1 - 2*(x**2 + y**2)]
        ])

    def multiply_quaternions(self, q1, q2):
        """Multiply two quaternions"""
        w1, x1, y1, z1 = q1
        w2, x2, y2, z2 = q2
        w = w1*w2 - x1*x2 - y1*y2 - z1*z2
        x = w1*x2 + x1*w2 + y1*z2 - z1*y2
        y = w1*y2 - x1*z2 + y1*w2 + z1*x2
        z = w1*z2 + x1*y2 - y1*x2 + z1*w2
        return np.array([w, x, y, z])

    def angular_velocity_to_quaternion(self, omega, dt):
        """Convert angular velocity to quaternion increment"""
        angle = np.linalg.norm(omega) * dt
        if angle > 1e-6:
            axis = omega / np.linalg.norm(omega)
            s = np.sin(angle / 2)
            c = np.cos(angle / 2)
            return np.array([c, axis[0] * s, axis[1] * s, axis[2] * s])
        else:
            return np.array([1, 0, 0, 0])
```

## Performance Optimization

### Efficient IMU Processing

Optimize IMU simulation for high-frequency operation:

```python
import numba
import numpy as np

@numba.jit(nopython=True)
def fast_imu_integration(angular_velocity, dt, orientation):
    """Fast IMU integration using Numba JIT"""
    # Convert angular velocity to quaternion derivative
    norm = np.sqrt(angular_velocity[0]**2 + angular_velocity[1]**2 + angular_velocity[2]**2)

    if norm > 1e-6:
        axis_x = angular_velocity[0] / norm
        axis_y = angular_velocity[1] / norm
        axis_z = angular_velocity[2] / norm
        angle = norm * dt

        s = np.sin(angle / 2)
        c = np.cos(angle / 2)

        # Create rotation quaternion
        dq_w = c
        dq_x = axis_x * s
        dq_y = axis_y * s
        dq_z = axis_z * s

        # Multiply quaternions: orientation = orientation * dq
        w_out = orientation[3] * dq_w - orientation[0] * dq_x - orientation[1] * dq_y - orientation[2] * dq_z
        x_out = orientation[3] * dq_x + orientation[0] * dq_w + orientation[1] * dq_z - orientation[2] * dq_y
        y_out = orientation[3] * dq_y - orientation[0] * dq_z + orientation[1] * dq_w + orientation[2] * dq_x
        z_out = orientation[3] * dq_z + orientation[0] * dq_y - orientation[1] * dq_x + orientation[2] * dq_w

        # Normalize
        norm_out = np.sqrt(w_out**2 + x_out**2 + y_out**2 + z_out**2)
        if norm_out > 0:
            return np.array([x_out/norm_out, y_out/norm_out, z_out/norm_out, w_out/norm_out])

    return orientation

class OptimizedIMUSimulator:
    def __init__(self):
        self.orientation = np.array([0.0, 0.0, 0.0, 1.0])  # [x, y, z, w]
        self.angular_velocity_bias = np.zeros(3)
        self.acceleration_bias = np.zeros(3)

    def process_imu_data(self, angular_velocity, linear_acceleration, dt):
        """Process IMU data with optimized functions"""
        # Add biases (these would be simulated separately)
        corrected_gyro = angular_velocity + self.angular_velocity_bias
        corrected_accel = linear_acceleration + self.acceleration_bias

        # Fast orientation integration
        self.orientation = fast_imu_integration(
            corrected_gyro, dt, self.orientation
        )

        return {
            'orientation': self.orientation,
            'angular_velocity': corrected_gyro,
            'linear_acceleration': corrected_accel
        }
```

## Validation and Testing

### IMU Accuracy Validation

```python
def validate_imu_performance(simulated_data, ground_truth_data, sample_rate=100):
    """Validate simulated IMU against ground truth"""
    results = {}

    # Extract components
    sim_accel = simulated_data['linear_acceleration']
    gt_accel = ground_truth_data['linear_acceleration']

    sim_gyro = simulated_data['angular_velocity']
    gt_gyro = ground_truth_data['angular_velocity']

    # Calculate statistics for accelerometer
    accel_errors = np.linalg.norm(sim_accel - gt_accel, axis=1)
    results['accel_mean_error'] = np.mean(accel_errors)
    results['accel_std_error'] = np.std(accel_errors)
    results['accel_max_error'] = np.max(accel_errors)

    # Calculate statistics for gyroscope
    gyro_errors = np.linalg.norm(sim_gyro - gt_gyro, axis=1)
    results['gyro_mean_error'] = np.mean(gyro_errors)
    results['gyro_std_error'] = np.std(gyro_errors)
    results['gyro_max_error'] = np.max(gyro_errors)

    # Allan variance analysis
    allan_results = analyze_imu_noise(sim_accel, sim_gyro, sample_rate)
    results['allan_variance'] = allan_results

    print(f"IMU Validation Results:")
    print(f"  Accelerometer:")
    print(f"    Mean Error: {results['accel_mean_error']:.6f} m/s²")
    print(f"    Std Dev: {results['accel_std_error']:.6f} m/s²")
    print(f"    Max Error: {results['accel_max_error']:.6f} m/s²")
    print(f"  Gyroscope:")
    print(f"    Mean Error: {results['gyro_mean_error']:.6f} rad/s")
    print(f"    Std Dev: {results['gyro_std_error']:.6f} rad/s")
    print(f"    Max Error: {results['gyro_max_error']:.6f} rad/s")

    # Check if within acceptable bounds
    results['pass'] = (results['accel_mean_error'] < 0.05 and  # < 50 mg
                      results['gyro_mean_error'] < 0.001)       # < 0.06 deg/s

    return results
```

### Bias Estimation and Calibration

```python
def estimate_imu_bias(data, stationary_periods):
    """Estimate IMU bias during stationary periods"""
    # For accelerometer: bias = average reading - expected gravity
    # For gyroscope: bias = average reading (should be zero when stationary)

    accel_bias = np.zeros(3)
    gyro_bias = np.zeros(3)

    valid_samples = 0

    for start_idx, end_idx in stationary_periods:
        # Extract stationary data
        accel_stationary = data['acceleration'][start_idx:end_idx]
        gyro_stationary = data['angular_velocity'][start_idx:end_idx]

        # Estimate accelerometer bias (average - gravity)
        accel_avg = np.mean(accel_stationary, axis=0)
        # Assume robot is stationary and oriented with z-axis up
        gravity = np.array([0, 0, 9.81])
        accel_bias += accel_avg - gravity

        # Estimate gyroscope bias (should average to zero)
        gyro_bias += np.mean(gyro_stationary, axis=0)

        valid_samples += 1

    if valid_samples > 0:
        accel_bias = accel_bias / valid_samples
        gyro_bias = gyro_bias / valid_samples

    return {
        'accelerometer_bias': accel_bias,
        'gyroscope_bias': gyro_bias
    }
```

## Common Issues and Troubleshooting

### Performance Issues

- **High CPU Usage**: IMU runs at high frequency (100-1000Hz), optimize algorithms
- **Timing Issues**: Ensure proper time synchronization between measurements
- **Integration Drift**: Implement proper bias estimation and correction

### Accuracy Issues

- **Wrong Gravity Sign**: Ensure gravity is added/subtracted correctly
- **Coordinate Frame Mismatch**: Verify IMU frame aligns with robot frame
- **Bias Drift**: Implement bias estimation and correction algorithms

### Integration Issues

- **TF Problems**: Ensure IMU frame is properly defined in robot model
- **Message Format**: Verify sensor_msgs/Imu format compliance
- **Covariance Values**: Set realistic covariance values based on sensor specs

## Best Practices

### 1. Use Realistic Noise Models

Base IMU noise parameters on actual sensor specifications rather than arbitrary values.

### 2. Include Temperature Effects

Model temperature-dependent drift and bias changes for realistic long-term behavior.

### 3. Validate Against Real Data

Compare simulated IMU outputs to real IMU data when possible.

### 4. Implement Proper Integration

Use appropriate numerical integration methods for orientation estimation.

### 5. Monitor Performance

Track IMU performance over time to detect drift and bias changes.

## Summary

IMU simulation in Gazebo provides essential motion and orientation sensing capabilities for robotics applications. By understanding the physics of inertial sensors, implementing proper noise models, and optimizing for performance, you can create realistic IMU simulations suitable for navigation, control, and sensor fusion applications. The integration with ROS 2 enables seamless use of simulated IMU data in state estimation pipelines.

## References

1. Open Source Robotics Foundation. (2023). Gazebo IMU Sensors. https://gazebosim.org/tutorials?tut=ros_gzplugins_sensors
2. Titterton, D., & Weston, J. (2004). Strapdown Inertial Navigation Technology. Institution of Engineering and Technology.
3. IEEE. (2015). IEEE Standard Specification Format Guide and Test Procedure for Single-Axis Interferometric Fiber Optic Gyros.

## Exercises

1. Implement an IMU simulation with realistic Allan variance characteristics
2. Create a sensor fusion algorithm combining IMU and other sensors
3. Develop bias estimation and calibration procedures for simulated IMU
4. Validate IMU performance under various motion profiles and conditions