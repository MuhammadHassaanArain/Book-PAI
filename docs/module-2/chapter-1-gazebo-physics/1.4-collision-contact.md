# Collision Detection & Contact Physics

## Overview

Collision detection and contact physics are fundamental to creating realistic physics-based digital twins in Gazebo. These systems determine how objects interact when they come into contact, which is crucial for simulating robot behavior in environments with obstacles, other robots, or objects. Properly configured collision detection and contact physics enable realistic robot locomotion, manipulation, and interaction with the environment.

## Collision Detection Fundamentals

### What is Collision Detection?

Collision detection is the computational problem of detecting when two or more bodies in a physical space intersect. In robotics simulation, this is critical for:
- Preventing objects from passing through each other
- Computing contact forces and reactions
- Triggering event-based behaviors
- Maintaining physical realism

### Types of Collisions

#### Pairwise Collision Detection
Detects collisions between pairs of objects. This is the most common approach in Gazebo, where each pair of potentially colliding objects is checked individually.

#### Broad Phase vs. Narrow Phase

**Broad Phase**:
- Quickly eliminates pairs of objects that are definitely not colliding
- Uses bounding volumes (boxes, spheres) for fast rejection
- Reduces the number of expensive narrow-phase tests

**Narrow Phase**:
- Performs detailed geometric tests on potentially colliding pairs
- Computes exact contact points and normals
- More computationally expensive but precise

## Collision Geometry in Gazebo

### Supported Collision Shapes

Gazebo supports several primitive collision shapes that can be used to approximate complex geometries:

#### Box
- **Use case**: Rectangular objects, simple approximations
- **Parameters**: Length, width, height
- **Advantages**: Fast, simple, good for structural elements

```xml
<collision name="box_collision">
  <geometry>
    <box>
      <size>1.0 0.5 0.2</size>
    </box>
  </geometry>
</collision>
```

#### Sphere
- **Use case**: Spherical objects, ball joints
- **Parameters**: Radius
- **Advantages**: Very fast, perfect for spherical objects

```xml
<collision name="sphere_collision">
  <geometry>
    <sphere>
      <radius>0.1</radius>
    </sphere>
  </geometry>
</collision>
```

#### Cylinder
- **Use case**: Wheels, limbs, cylindrical objects
- **Parameters**: Radius, length
- **Advantages**: Good for rotationally symmetric objects

```xml
<collision name="cylinder_collision">
  <geometry>
    <cylinder>
      <radius>0.05</radius>
      <length>0.2</length>
    </cylinder>
  </geometry>
</collision>
```

#### Capsule
- **Use case**: Limbs, rounded objects
- **Parameters**: Radius, length
- **Advantages**: Better than cylinders for contact stability

```xml
<collision name="capsule_collision">
  <geometry>
    <capsule>
      <radius>0.05</radius>
      <length>0.1</length>
    </capsule>
  </geometry>
</collision>
```

#### Mesh
- **Use case**: Complex geometries, accurate representations
- **Parameters**: Mesh file reference
- **Trade-offs**: Accurate but computationally expensive

```xml
<collision name="mesh_collision">
  <geometry>
    <mesh>
      <uri>model://my_robot/meshes/complex_part.dae</uri>
    </mesh>
  </geometry>
</collision>
```

### Collision Geometry Optimization

#### Hierarchical Approximation
For complex objects, use a hierarchy of collision geometries:
1. **Outer bounding shape**: Simple shape for broad-phase detection
2. **Detailed inner shapes**: More complex shapes for accurate contact

#### Convex Decomposition
Break complex concave meshes into convex parts:
- Convex shapes are easier to process
- More stable contact computation
- Better performance characteristics

#### Simplification Strategies
- Use simpler shapes for objects that don't require precision
- Combine multiple simple shapes for complex objects
- Use primitive shapes for internal components that rarely contact

## Contact Physics

### Contact Models

#### Point Contact Model
- **Approach**: Contacts computed at discrete points
- **Use case**: Most general-purpose applications
- **Characteristics**: Computationally efficient

#### Patch Contact Model
- **Approach**: Contacts computed over small surface patches
- **Use case**: Objects that need stable resting contact
- **Characteristics**: More stable but more expensive

### Contact Parameters

#### Contact Stiffness and Damping
These parameters control how contact forces are computed:

```xml
<surface>
  <contact>
    <ode>
      <soft_cfm>0.000001</soft_cfm>
      <soft_erp>0.8</soft_erp>
      <kp>1000000000000.0</kp>
      <kd>1000000000000.0</kd>
      <max_vel>100.0</max_vel>
      <min_depth>0.001</min_depth>
    </ode>
  </contact>
</surface>
```

- **kp (Spring stiffness)**: How stiff the contact is (higher = stiffer)
- **kd (Damping coefficient)**: How much energy is absorbed (higher = more damping)
- **max_vel**: Maximum correcting velocity
- **min_depth**: Minimum contact penetration depth

#### Friction Models

##### ODE Friction Model
```xml
<surface>
  <friction>
    <ode>
      <mu>1.0</mu>
      <mu2>1.0</mu2>
      <fdir1>0 0 0</fdir1>
      <slip1>0.0</slip1>
      <slip2>0.0</slip2>
    </ode>
  </friction>
</surface>
```

- **mu, mu2**: Friction coefficients in primary and secondary directions
- **fdir1**: Primary friction direction (if not aligned with contact)
- **slip1, slip2**: Slip coefficients for velocity-dependent friction

##### Bullet Friction Model
```xml
<surface>
  <friction>
    <bullet>
      <friction>1.0</friction>
      <friction2>1.0</friction2>
      <fdir1>0 0 0</fdir1>
      <rolling_friction>0.0</rolling_friction>
    </bullet>
  </friction>
</surface>
```

### Contact Information

#### Contact Detection
Gazebo provides detailed information about contacts:

- **Contact points**: Specific locations where objects touch
- **Contact normals**: Directions of contact forces
- **Contact depths**: Amount of penetration
- **Contact forces**: Magnitudes of forces applied

#### Contact Messages
Contact information can be accessed via ROS messages:
- `gazebo_msgs/ContactsState`: Current contact state
- `gazebo_msgs/ContactState`: Individual contact information

## Collision Detection Performance

### Performance Factors

#### Complexity of Collision Shapes
- **Simple shapes** (box, sphere): Fastest
- **Meshes**: Slowest, but most accurate
- **Trimeshes**: Moderate performance with high accuracy

#### Number of Objects
- More objects = more pairwise tests
- Use spatial partitioning when possible
- Consider object grouping for optimization

#### Contact Frequency
- More frequent contacts = higher computational load
- Balance accuracy with performance requirements

### Optimization Strategies

#### Spatial Hashing
- Divide space into grid cells
- Only check objects in the same or adjacent cells
- Significantly reduces broad-phase complexity

#### Temporal Coherence
- Use previous frame's contact information
- Avoid recomputing stable contacts
- Exploit temporal patterns in motion

#### Level of Detail (LOD)
- Use detailed collision for close objects
- Use simplified collision for distant objects
- Switch based on distance thresholds

## Humanoid Robot Considerations

### Foot Contact Modeling

For humanoid robots, foot contact is critical for stable locomotion:

#### Contact Points
- Distribute contact points across the foot sole
- Use multiple contact points for stability
- Consider heel-to-toe contact sequence

#### Contact Areas
- Model contact patches rather than points
- Account for foot flexibility and deformation
- Consider shoe/footwear effects

### Joint Contact Limitations

#### Self-Collision Prevention
- Define self-collision masks to prevent impossible contacts
- Use joint limits to prevent self-intersection
- Consider computational cost of self-collision detection

#### Intentional Contacts
- Allow intentional contacts (hands, feet) while preventing others
- Use collision groups to control contact behavior
- Implement contact filtering for specific scenarios

## Common Contact Issues and Solutions

### Object Penetration

**Symptoms**: Objects passing through each other or sinking into surfaces

**Causes and Solutions**:
1. **Time step too large**: Decrease `max_step_size`
2. **Soft contact parameters**: Increase stiffness (`kp`) or decrease damping (`kd`)
3. **Insufficient solver iterations**: Increase solver iterations
4. **Low min_depth**: Increase minimum contact depth

### Contact Instability

**Symptoms**: Objects jittering, vibrating, or bouncing unrealistically

**Causes and Solutions**:
1. **Aggressive ERP/CFM**: Reduce ERP values, increase CFM slightly
2. **High stiffness**: Lower spring stiffness parameters
3. **Insufficient damping**: Increase damping coefficients
4. **Fast-moving objects**: Decrease time step or add velocity limits

### Performance Bottlenecks

**Symptoms**: Low simulation speed, high CPU usage

**Causes and Solutions**:
1. **Too many complex collisions**: Simplify collision geometries
2. **Excessive contact points**: Reduce contact point density
3. **Unnecessary self-collisions**: Disable self-collision where appropriate
4. **High solver iterations**: Reduce iterations while maintaining stability

## Advanced Contact Techniques

### Custom Contact Sensors

Create custom contact sensors for specific applications:

```xml
<sensor name="custom_contact" type="contact">
  <always_on>true</always_on>
  <update_rate>30</update_rate>
  <contact>
    <collision>collision_name</collision>
  </contact>
</sensor>
```

### Contact-Based Event Handling

Trigger behaviors based on contact events:
- Stop motion when contact threshold exceeded
- Change behavior on contact detection
- Implement tactile feedback systems

### Soft Contact Modeling

For applications requiring soft body behavior:
- Use compliant contact parameters
- Implement custom contact force laws
- Consider using soft body physics extensions

## Validation and Testing

### Contact Validation Tests

#### Static Contact Test
- Place objects in contact and verify they remain stable
- Test different orientations and configurations
- Verify no sinking or penetration over time

#### Dynamic Contact Test
- Drop objects from various heights
- Test sliding and rolling behaviors
- Validate energy conservation properties

#### Edge Case Testing
- Test with very fast-moving objects
- Validate behavior with very light/heavy objects
- Test extreme friction conditions

### Performance Benchmarking

#### Contact Rate Monitoring
- Track contact detection frequency
- Monitor CPU usage during contact-intensive scenarios
- Measure real-time factor under contact stress

#### Stability Assessment
- Long-duration contact stability tests
- Stress testing with multiple simultaneous contacts
- Validation of contact force magnitudes

## Integration with Control Systems

### Feedback for Controllers

Contact information is crucial for:
- Balance controllers (feedback from foot contacts)
- Manipulation controllers (grasp detection)
- Navigation systems (obstacle detection)

### Sensor Fusion

Combine contact information with:
- Force/torque sensors
- IMU data for contact state estimation
- Vision-based contact detection

## Summary

Collision detection and contact physics form the foundation of realistic interaction in physics-based digital twins. Proper configuration of collision geometries, contact parameters, and performance optimizations is essential for achieving stable, accurate simulation results. For humanoid robots, special attention must be paid to foot contact modeling and self-collision prevention. The key is finding the right balance between accuracy and performance, starting with simple geometries and gradually increasing complexity as needed. Regular validation and testing ensure that contact behavior remains stable and realistic under various operating conditions.

---

## References

1. Ericson, C. (2004). *Real-time collision detection*. Morgan Kaufmann. https://doi.org/10.1016/B978-1-55860-732-3.X5000-7

2. Baraff, D. (1994). Fast contact force computation for nonpenetrating rigid bodies. *SIGGRAPH Computer Graphics*, *28*(4), 23-34. https://doi.org/10.1145/192161.192168

3. Guendelman, E., Bridson, R., & Fedkiw, R. (2003). Nonconvex rigid bodies with stacking. *ACM Transactions on Graphics*, *22*(3), 871-878. https://doi.org/10.1145/882262.882358

4. Gazebo Tutorials. (2021). Contact manager. *Open Robotics*. http://gazebosim.org/tutorials?tut=contact_manager

5. Kanehiro, F., Morisawa, M., Miura, H., Nakaoka, S., & Hirukawa, H. (2014). The open dynamics engine. *Journal of the Robotics Society of Japan*, *22*(7), 874-879. https://doi.org/10.7210/jrsj.22.874

6. Open Robotics. (2021). *Gazebo robotics simulator*. https://gazebosim.org/

7. Feitoza, B., et al. (2019). Efficient collision detection for multi-robot simulation. *IEEE Transactions on Robotics*, *35*(3), 678-689. https://doi.org/10.1109/TRO.2019.2899802

8. Smith, C., & Reiners, D. (2015). Performance optimization for physics-based animation. *ACM Transactions on Graphics*, *34*(4), 1-10. https://doi.org/10.1145/2766988

9. Kuffner, J. (2004). Effective sampling and distance metrics for 3D rigid body path planning. *IEEE International Conference on Robotics and Automation*, 3993-3998. https://doi.org/10.1109/ICRA.2004.1307284

10. Tedrake Lab. (2021). *Underactuated robotics: Algorithms for walking, running, swimming, flying, and manipulation*. MIT Press. http://underactuated.mit.edu/