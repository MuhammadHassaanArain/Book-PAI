# Gravity, Rigid Body Dynamics, and Constraints

## Overview

Understanding gravity, rigid body dynamics, and constraints is fundamental to creating realistic physics-based digital twins in Gazebo. These concepts form the foundation of how objects move, interact, and behave in the simulated environment. Properly configuring these elements is essential for achieving sim-to-real transfer, especially for humanoid robots where balance and contact dynamics are critical.

## Gravity Configuration

### Understanding Gravity in Gazebo

Gravity is a fundamental force in Gazebo that affects all objects in the simulation. By default, Gazebo uses Earth's gravitational acceleration of 9.8 m/s² in the negative Z direction, but this can be customized for different scenarios.

### Setting Global Gravity

Global gravity is defined in the world file:

```xml
<sdf version="1.7">
  <world name="my_world">
    <physics type="ode">
      <gravity>0 0 -9.8</gravity>
    </physics>

    <!-- Rest of world definition -->
  </world>
</sdf>
```

The gravity vector is specified as `<x> <y> <z>` in units of m/s². Common configurations include:

- **Earth gravity**: `0 0 -9.8` (standard)
- **Moon gravity**: `0 0 -1.62` (approximately 1/6 of Earth)
- **Zero gravity**: `0 0 0` (for space simulation)
- **Custom gravity**: Any vector for specialized scenarios

### Custom Gravity Scenarios

For robotics research involving different planetary bodies or specialized applications, gravity can be adjusted:

```xml
<!-- Mars gravity -->
<gravity>0 0 -3.71</gravity>

<!-- Variable gravity for experimental purposes -->
<gravity>0.1 -0.2 -8.5</gravity>
```

## Rigid Body Dynamics

### Rigid Body Properties

In Gazebo, objects are modeled as rigid bodies with specific physical properties:

![Rigid Body Properties](/assets/images/module-2/rigid-body-properties.png)

*Figure 1.4: Key rigid body properties including mass, center of mass, and moments of inertia.*

#### Mass
Mass determines how objects respond to forces. It should be set realistically:
- Humanoid torso: 10-20 kg
- Humanoid limb: 1-5 kg
- Small mobile robot: 1-10 kg
- Large industrial robot: 50-500 kg

#### Center of Mass
The center of mass affects how objects rotate when forces are applied. For symmetric objects, it's typically at the geometric center. For complex shapes, it should be calculated or estimated accurately.

#### Moments of Inertia
Moments of inertia describe how mass is distributed in an object. They significantly affect rotational dynamics:

- `ixx`, `iyy`, `izz`: Principal moments of inertia
- `ixy`, `ixz`, `iyz`: Products of inertia (often negligible for symmetric objects)

For a solid sphere of mass `m` and radius `r`:
```
ixx = iyy = izz = (2/5) * m * r²
```

For a solid cylinder of mass `m`, radius `r`, and height `h`:
```
ixx = iyy = (1/12) * m * (3*r² + h²)
izz = (1/2) * m * r²
```

### Inertial Properties in URDF/SDF

In URDF format:
```xml
<link name="link_name">
  <inertial>
    <mass value="1.0"/>
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
  </inertial>
</link>
```

In SDF format:
```xml
<link name="link_name">
  <inertial>
    <mass>1.0</mass>
    <inertia>
      <ixx>0.01</ixx>
      <ixy>0</ixy>
      <ixz>0</ixz>
      <iyy>0.01</iyy>
      <iyz>0</iyz>
      <izz>0.01</izz>
    </inertia>
  </inertial>
</link>
```

## Constraints and Joints

### Joint Types

Gazebo supports several joint types for connecting rigid bodies:

![Joint Types in Gazebo](/assets/images/module-2/joint-types.png)

*Figure 1.5: Different joint types available in Gazebo showing degrees of freedom and use cases.*

#### Fixed Joint
- **DOF**: 0 (no movement)
- **Use case**: Connecting two links that should move as one
```xml
<joint name="fixed_joint" type="fixed">
  <parent>parent_link</parent>
  <child>child_link</child>
</joint>
```

#### Revolute Joint
- **DOF**: 1 (rotation around axis)
- **Use case**: Rotating joints like elbow, knee, shoulder
```xml
<joint name="revolute_joint" type="revolute">
  <parent>upper_arm</parent>
  <child>lower_arm</child>
  <axis>
    <xyz>0 1 0</xyz>
    <limit>
      <lower>-1.57</lower>
      <upper>1.57</upper>
      <effort>100</effort>
      <velocity>1</velocity>
    </limit>
  </axis>
</joint>
```

#### Continuous Joint
- **DOF**: 1 (continuous rotation)
- **Use case**: Wheels, rotating sensors
```xml
<joint name="continuous_joint" type="continuous">
  <parent>base</parent>
  <child>wheel</child>
  <axis>
    <xyz>0 1 0</xyz>
  </axis>
</joint>
```

#### Prismatic Joint
- **DOF**: 1 (linear motion)
- **Use case**: Sliding mechanisms
```xml
<joint name="prismatic_joint" type="prismatic">
  <parent>base</parent>
  <child>slider</child>
  <axis>
    <xyz>1 0 0</xyz>
    <limit>
      <lower>0</lower>
      <upper>0.5</upper>
      <effort>100</effort>
      <velocity>0.5</velocity>
    </limit>
  </axis>
</joint>
```

#### Floating Joint
- **DOF**: 6 (free movement in all directions)
- **Use case**: Objects that are not constrained
```xml
<joint name="floating_joint" type="floating">
  <parent>world</parent>
  <child>floating_object</child>
</joint>
```

### Joint Limits and Dynamics

#### Joint Limits
Joint limits prevent damage to physical robots and ensure realistic motion:

```xml
<limit>
  <lower>-1.57</lower>  <!-- Lower limit in radians -->
  <upper>1.57</upper>   <!-- Upper limit in radians -->
  <effort>100</effort>  <!-- Maximum torque (N-m) -->
  <velocity>1</velocity> <!-- Maximum velocity (rad/s) -->
</limit>
```

#### Joint Dynamics
Damping and friction affect joint behavior:

```xml
<dynamics>
  <damping>0.1</damping>     <!-- Viscous damping -->
  <friction>0.0</friction>   <!-- Coulomb friction -->
  <spring_reference>0</spring_reference>
  <spring_stiffness>0</spring_stiffness>
</dynamics>
```

## Physics Parameters for Stability

### Solver Parameters

The physics solver parameters affect simulation stability:

![Physics Solver Parameters](/assets/images/module-2/physics-solver-parameters.png)

*Figure 1.6: Visualization of how physics solver parameters affect simulation stability and performance.*

#### Solver Iterations
Higher iterations provide better stability but slower performance:
- Default: 100-200 for humanoid robots
- Higher values: Better stability, slower performance
- Lower values: Faster performance, potential instability

#### Successive Over-Relaxation (SOR)
Controls convergence of iterative solver:
- Typical range: 1.0-1.3
- Higher values: Faster convergence, potential instability

#### Constraint Force Mixing (CFM)
Makes constraints softer (more compliant):
- 0: Hard constraints (default)
- Positive values: Softer constraints, more stable

#### Error Reduction Parameter (ERP)
Controls how strongly errors are corrected:
- 0: No error correction
- 1: Full error correction (hard constraints)
- Typical range: 0.1-0.8

### Recommended Values for Humanoid Robots

For humanoid robots, which require stable contact dynamics:

```xml
<physics type="bullet">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000.0</real_time_update_rate>
  <ode>
    <solver>
      <type>quick</type>
      <iters>200</iters>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>1e-6</cfm>
      <erp>0.8</erp>
      <contact_surface_layer>0.001</contact_surface_layer>
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
    </constraints>
  </ode>
</physics>
```

## Contact Physics

### Contact Parameters

Contacts between objects are governed by several parameters:

![Contact Physics Parameters](/assets/images/module-2/contact-physics-parameters.png)

*Figure 1.7: Visualization of contact physics parameters including friction and restitution coefficients.*

#### Friction Coefficients
- **Static friction**: Prevents initial sliding
- **Dynamic friction**: Governs sliding motion
- Typical values: 0.3-0.8 for rubber on dry surfaces

#### Restitution (Bounciness)
- 0: Perfectly inelastic (no bounce)
- 1: Perfectly elastic (full bounce)
- Typical values: 0.0-0.5 for most materials

### Contact Materials

Material properties can be defined in SDF:

```xml
<collision name="collision">
  <geometry>
    <sphere>
      <radius>0.1</radius>
    </sphere>
  </geometry>
  <surface>
    <friction>
      <ode>
        <mu>0.5</mu>
        <mu2>0.5</mu2>
      </ode>
    </friction>
    <bounce>
      <restitution_coefficient>0.1</restitution_coefficient>
      <threshold>100000</threshold>
    </bounce>
  </surface>
</collision>
```

## Practical Implementation Tips

### Balancing Accuracy and Performance

1. **Start Conservative**: Begin with stable parameters and optimize for performance
2. **Iterative Testing**: Test with increasingly aggressive motions
3. **Monitor Metrics**: Track simulation accuracy and real-time factor
4. **Hardware Considerations**: Adjust parameters based on available computational resources

### Validating Physics Models

1. **Static Tests**: Verify objects remain stable when stationary
2. **Dynamic Tests**: Test with expected range of motions
3. **Contact Tests**: Validate behavior during collisions and contacts
4. **Long Duration Tests**: Ensure stability over extended simulation periods

### Common Issues and Solutions

#### Object Penetration
- **Cause**: Insufficient solver iterations or large time steps
- **Solution**: Increase iterations or decrease time step

#### Instability/Bouncing
- **Cause**: Aggressive ERP/CFM values or unrealistic inertials
- **Solution**: Adjust ERP/CFM values, verify inertial properties

#### Performance Issues
- **Cause**: Excessive solver iterations or complex collision geometries
- **Solution**: Optimize collision geometry, adjust solver parameters

## Advanced Topics

### Custom Dynamics Plugins

For specialized behavior, custom dynamics plugins can be created:

- Modify physics behavior programmatically
- Implement custom controllers
- Add external forces or constraints

### Multi-Body Dynamics

For complex systems with many interconnected parts:

- Consider hierarchical control strategies
- Use appropriate joint types for each connection
- Balance model complexity with simulation performance

## Summary

Proper configuration of gravity, rigid body dynamics, and constraints is essential for creating accurate digital twins in Gazebo. The parameters chosen directly affect simulation stability, performance, and sim-to-real transfer capability. For humanoid robots, special attention must be paid to contact dynamics, joint limits, and solver parameters to ensure stable and realistic behavior. The key is finding the right balance between accuracy and performance for your specific application, starting with conservative parameters and iteratively optimizing based on testing results.

---

## References

1. Featherstone, R. (2008). *Rigid body dynamics algorithms*. Springer Science & Business Media. https://doi.org/10.1007/978-1-4899-7986-1

2. Murray, R. M., Li, Z., & Sastry, S. S. (1994). *A mathematical introduction to robotic manipulation*. CRC Press. https://www.crcpress.com/A-Mathematical-Introduction-to-Robotic-Manipulation-Murray/p/book/9780849340303

3. Craig, J. J. (2005). *Introduction to robotics: Mechanics and control* (3rd ed.). Pearson Prentice Hall.

4. Siciliano, B., & Khatib, O. (Eds.). (2016). *Springer handbook of robotics* (2nd ed.). Springer. https://doi.org/10.1007/978-3-319-32552-1

5. Gazebo Tutorials. (2021). Physics. *Open Robotics*. http://gazebosim.org/tutorials?tut=physics

6. Tedrake Lab. (2021). *Underactuated robotics: Algorithms for walking, running, swimming, flying, and manipulation*. MIT Press. http://underactuated.mit.edu/

7. Open Robotics. (2021). *Gazebo robotics simulator*. https://gazebosim.org/

8. Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. *Proceedings 2004 IEEE/RSJ International Conference on Intelligent Robots and Systems*, *3*, 2149-2154. https://doi.org/10.1109/IROS.2004.1389865

9. Featherstone, R. (2014). *Rigid body dynamics*. In *Springer handbook of robotics* (pp. 17-38). Springer. https://doi.org/10.1007/978-3-319-32552-1_2