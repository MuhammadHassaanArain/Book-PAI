# 2.5 Spawning Objects via ROS 2

## Introduction

Dynamic object spawning in Gazebo through ROS 2 enables runtime creation of simulation elements, allowing for adaptive environments, scenario testing, and interactive applications. This chapter covers the ROS 2 interfaces for spawning and managing objects in Gazebo, including both static and dynamic models, and demonstrates how to integrate spawning functionality into robotic applications for digital twin systems.

## ROS 2 Spawning Services

### Spawn Entity Service

The primary interface for spawning objects in Gazebo is the `/spawn_entity` service, which uses the `gazebo_msgs/srv/SpawnEntity` message type.

#### Service Definition

```python
# gazebo_msgs/srv/SpawnEntity
string name                    # Name of the entity to spawn
string xml                     # XML description of the entity (SDF/URDF)
string robot_namespace         # Robot namespace
geometry_msgs/Pose initial_pose # Initial pose of the entity
string reference_frame         # Frame in which initial_pose is specified
```

#### Example Service Call

```python
import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SpawnEntity
from geometry_msgs.msg import Pose
from std_msgs.msg import String

class ObjectSpawner(Node):
    def __init__(self):
        super().__init__('object_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')

    def spawn_object(self, name, xml, x=0.0, y=0.0, z=0.0):
        req = SpawnEntity.Request()
        req.name = name
        req.xml = xml
        req.initial_pose.position.x = x
        req.initial_pose.position.y = y
        req.initial_pose.position.z = z
        req.initial_pose.orientation.w = 1.0

        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Successfully spawned {name}')
            else:
                self.get_logger().error(f'Failed to spawn {name}: {response.status_message}')
        else:
            self.get_logger().error(f'Exception while spawning {name}: {future.exception()}')
```

### Delete Entity Service

For removing objects during simulation:

```python
from gazebo_msgs.srv import DeleteEntity

class ObjectDeleter(Node):
    def __init__(self):
        super().__init__('object_deleter')
        self.cli = self.create_client(DeleteEntity, '/delete_entity')

    def delete_object(self, name):
        req = DeleteEntity.Request()
        req.name = name

        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Successfully deleted {name}')
            else:
                self.get_logger().error(f'Failed to delete {name}: {response.status_message}')
```

## Spawning Different Object Types

### Static Models

Static models don't move during simulation and are efficient for environment elements:

```python
def spawn_static_box(self, name, x, y, z, size_x=1.0, size_y=1.0, size_z=1.0):
    # SDF description of a static box
    static_box_sdf = f"""
    <?xml version="1.0" ?>
    <sdf version="1.7">
      <model name="{name}">
        <static>true</static>
        <link name="link">
          <inertial>
            <mass>1.0</mass>
            <inertia>
              <ixx>0.166667</ixx>
              <ixy>0</ixy>
              <ixz>0</ixz>
              <iyy>0.166667</iyy>
              <iyz>0</iyz>
              <izz>0.166667</izz>
            </inertia>
          </inertial>
          <collision name="collision">
            <geometry>
              <box>
                <size>{size_x} {size_y} {size_z}</size>
              </box>
            </geometry>
          </collision>
          <visual name="visual">
            <geometry>
              <box>
                <size>{size_x} {size_y} {size_z}</size>
              </box>
            </geometry>
            <material>
              <ambient>0.5 0.5 0.5 1</ambient>
              <diffuse>0.8 0.8 0.8 1</diffuse>
              <specular>0.2 0.2 0.2 1</specular>
            </material>
          </visual>
        </link>
      </model>
    </sdf>
    """

    req = SpawnEntity.Request()
    req.name = name
    req.xml = static_box_sdf
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = z
    req.initial_pose.orientation.w = 1.0

    future = self.cli.call_async(req)
    rclpy.spin_until_future_complete(self, future)
```

### Dynamic Models

Dynamic models respond to physics and can be manipulated:

```python
def spawn_dynamic_sphere(self, name, x, y, z, radius=0.1, mass=0.5):
    dynamic_sphere_sdf = f"""
    <?xml version="1.0" ?>
    <sdf version="1.7">
      <model name="{name}">
        <link name="link">
          <inertial>
            <mass>{mass}</mass>
            <inertia>
              <ixx>{0.4 * mass * radius * radius}</ixx>
              <ixy>0</ixy>
              <ixz>0</ixz>
              <iyy>{0.4 * mass * radius * radius}</iyy>
              <iyz>0</iyz>
              <izz>{0.4 * mass * radius * radius}</izz>
            </inertia>
          </inertial>
          <collision name="collision">
            <geometry>
              <sphere>
                <radius>{radius}</radius>
              </sphere>
            </geometry>
          </collision>
          <visual name="visual">
            <geometry>
              <sphere>
                <radius>{radius}</radius>
              </sphere>
            </geometry>
            <material>
              <ambient>0.1 0.1 0.8 1</ambient>
              <diffuse>0.1 0.1 1.0 1</diffuse>
              <specular>0.5 0.5 0.5 1</specular>
            </material>
          </visual>
        </link>
      </model>
    </sdf>
    """

    req = SpawnEntity.Request()
    req.name = name
    req.xml = dynamic_sphere_sdf
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = z
    req.initial_pose.orientation.w = 1.0

    future = self.cli.call_async(req)
    rclpy.spin_until_future_complete(self, future)
```

### URDF Models

You can also spawn URDF models directly:

```python
def spawn_urdf_robot(self, name, x, y, z, urdf_path):
    # Read URDF from file
    with open(urdf_path, 'r') as urdf_file:
        urdf_xml = urdf_file.read()

    # Wrap URDF in SDF for spawning
    sdf_wrapper = f"""
    <?xml version="1.0" ?>
    <sdf version="1.7">
      <model name="{name}">
        {urdf_xml}
      </model>
    </sdf>
    """

    req = SpawnEntity.Request()
    req.name = name
    req.xml = sdf_wrapper
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = z
    req.initial_pose.orientation.w = 1.0

    future = self.cli.call_async(req)
    rclpy.spin_until_future_complete(self, future)
```

## Advanced Spawning Techniques

### Spawning with Custom Plugins

Add custom plugins to spawned objects for specific behaviors:

```python
def spawn_object_with_plugin(self, name, x, y, z):
    object_with_plugin_sdf = f"""
    <?xml version="1.0" ?>
    <sdf version="1.7">
      <model name="{name}">
        <link name="link">
          <inertial>
            <mass>1.0</mass>
            <inertia>
              <ixx>0.166667</ixx>
              <ixy>0</ixy>
              <ixz>0</ixz>
              <iyy>0.166667</iyy>
              <iyz>0</iyz>
              <izz>0.166667</izz>
            </inertia>
          </inertial>
          <collision name="collision">
            <geometry>
              <box><size>0.5 0.5 0.5</size></box>
            </geometry>
          </collision>
          <visual name="visual">
            <geometry>
              <box><size>0.5 0.5 0.5</size></box>
            </geometry>
          </visual>
        </link>
        <plugin name="object_controller" filename="libObjectController.so">
          <frequency>10</frequency>
          <amplitude>0.1</amplitude>
          <period>2.0</period>
        </plugin>
      </model>
    </sdf>
    """

    req = SpawnEntity.Request()
    req.name = name
    req.xml = object_with_plugin_sdf
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = z
    req.initial_pose.orientation.w = 1.0

    future = self.cli.call_async(req)
    rclpy.spin_until_future_complete(self, future)
```

### Batch Spawning

Spawn multiple objects efficiently:

```python
class BatchSpawner(Node):
    def __init__(self):
        super().__init__('batch_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')

    def spawn_grid(self, base_name, rows, cols, spacing_x=1.0, spacing_y=1.0, start_x=0.0, start_y=0.0):
        futures = []

        for i in range(rows):
            for j in range(cols):
                name = f"{base_name}_{i}_{j}"
                x = start_x + j * spacing_x
                y = start_y + i * spacing_y
                z = 0.5  # Place on ground

                # Create simple box SDF
                box_sdf = f"""
                <?xml version="1.0" ?>
                <sdf version="1.7">
                  <model name="{name}">
                    <link name="link">
                      <inertial>
                        <mass>0.5</mass>
                        <inertia><ixx>0.01</ixx><iyy>0.01</iyy><izz>0.01</izz></inertia>
                      </inertial>
                      <collision name="collision">
                        <geometry><box><size>0.2 0.2 0.2</size></box></geometry>
                      </collision>
                      <visual name="visual">
                        <geometry><box><size>0.2 0.2 0.2</size></box></geometry>
                        <material><ambient>0.8 0.2 0.2 1</ambient></material>
                      </visual>
                    </link>
                  </model>
                </sdf>
                """

                req = SpawnEntity.Request()
                req.name = name
                req.xml = box_sdf
                req.initial_pose.position.x = x
                req.initial_pose.position.y = y
                req.initial_pose.position.z = z
                req.initial_pose.orientation.w = 1.0

                future = self.cli.call_async(req)
                futures.append((name, future))

        # Wait for all spawns to complete
        for name, future in futures:
            rclpy.spin_until_future_complete(self, future)
            response = future.result()
            if response.success:
                self.get_logger().info(f'Successfully spawned {name}')
            else:
                self.get_logger().error(f'Failed to spawn {name}')
```

## Integration with Robot Controllers

### Spawning Objects Based on Sensor Data

Create objects based on robot perception:

```python
class PerceptionBasedSpawner(Node):
    def __init__(self):
        super().__init__('perception_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')
        self.subscription = self.create_subscription(
            PointCloud2,
            '/robot1/lidar/points',
            self.lidar_callback,
            10)
        self.spawned_objects = set()

    def lidar_callback(self, msg):
        # Process point cloud to detect objects
        # This is a simplified example
        detected_objects = self.process_pointcloud(msg)

        for obj_info in detected_objects:
            if obj_info['id'] not in self.spawned_objects:
                self.spawn_detected_object(obj_info)
                self.spawned_objects.add(obj_info['id'])

    def process_pointcloud(self, pc_msg):
        # Simplified object detection from point cloud
        # In practice, use clustering algorithms like DBSCAN
        objects = []
        # Process the point cloud data here
        # Return list of detected object information
        return objects

    def spawn_detected_object(self, obj_info):
        # Create a visual representation of the detected object
        object_sdf = f"""
        <?xml version="1.0" ?>
        <sdf version="1.7">
          <model name="detected_{obj_info['id']}">
            <static>true</static>
            <link name="link">
              <visual name="visual">
                <geometry>
                  <box>
                    <size>{obj_info['width']} {obj_info['depth']} {obj_info['height']}</size>
                  </box>
                </geometry>
                <material>
                  <ambient>0.2 0.8 0.2 0.5</ambient>
                  <diffuse>0.2 0.8 0.2 0.5</diffuse>
                </material>
              </visual>
            </link>
          </model>
        </sdf>
        """

        req = SpawnEntity.Request()
        req.name = f"detected_{obj_info['id']}"
        req.xml = object_sdf
        req.initial_pose.position.x = obj_info['x']
        req.initial_pose.position.y = obj_info['y']
        req.initial_pose.position.z = obj_info['z']
        req.initial_pose.orientation.w = 1.0

        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)
```

### Spawning for Navigation Testing

Create dynamic obstacles for navigation testing:

```python
class NavigationTestSpawner(Node):
    def __init__(self):
        super().__init__('nav_test_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')
        self.timer = self.create_timer(5.0, self.spawn_dynamic_obstacle)
        self.obstacle_count = 0

    def spawn_dynamic_obstacle(self):
        name = f"obstacle_{self.obstacle_count}"
        self.obstacle_count += 1

        # Spawn a dynamic box that moves in the environment
        obstacle_sdf = f"""
        <?xml version="1.0" ?>
        <sdf version="1.7">
          <model name="{name}">
            <link name="link">
              <inertial>
                <mass>5.0</mass>
                <inertia>
                  <ixx>0.416667</ixx>
                  <ixy>0</ixy>
                  <ixz>0</ixz>
                  <iyy>0.416667</iyy>
                  <iyz>0</iyz>
                  <izz>0.416667</izz>
                </inertia>
              </inertial>
              <collision name="collision">
                <geometry>
                  <box><size>0.5 0.5 1.0</size></box>
                </geometry>
              </collision>
              <visual name="visual">
                <geometry>
                  <box><size>0.5 0.5 1.0</size></box>
                </geometry>
                <material>
                  <ambient>0.8 0.4 0.0 1</ambient>
                </material>
              </visual>
            </link>
            <plugin name="object_mover" filename="libObjectMover.so">
              <linear_velocity>0.2 0 0</linear_velocity>
              <angular_velocity>0 0 0.1</angular_velocity>
            </plugin>
          </model>
        </sdf>
        """

        # Random position in a defined area
        import random
        x = random.uniform(-5.0, 5.0)
        y = random.uniform(-5.0, 5.0)
        z = 0.5

        req = SpawnEntity.Request()
        req.name = name
        req.xml = obstacle_sdf
        req.initial_pose.position.x = x
        req.initial_pose.position.y = y
        req.initial_pose.position.z = z
        req.initial_pose.orientation.w = 1.0

        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)
```

## Spawning from Parameter Files

Load object configurations from YAML files:

```python
class ParamSpawner(Node):
    def __init__(self):
        super().__init__('param_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')

        # Declare parameters for object configurations
        self.declare_parameter('objects', [])
        self.spawn_from_params()

    def spawn_from_params(self):
        objects = self.get_parameter('objects').value
        if objects is None:
            return

        for obj_config in objects:
            name = obj_config.get('name', f'object_{len(objects)}')
            obj_type = obj_config.get('type', 'box')
            x = obj_config.get('x', 0.0)
            y = obj_config.get('y', 0.0)
            z = obj_config.get('z', 0.0)

            if obj_type == 'box':
                size_x = obj_config.get('size_x', 1.0)
                size_y = obj_config.get('size_y', 1.0)
                size_z = obj_config.get('size_z', 1.0)
                static = obj_config.get('static', True)

                sdf = self.create_box_sdf(name, size_x, size_y, size_z, static)
            elif obj_type == 'sphere':
                radius = obj_config.get('radius', 0.5)
                static = obj_config.get('static', True)

                sdf = self.create_sphere_sdf(name, radius, static)
            else:
                continue

            req = SpawnEntity.Request()
            req.name = name
            req.xml = sdf
            req.initial_pose.position.x = x
            req.initial_pose.position.y = y
            req.initial_pose.position.z = z
            req.initial_pose.orientation.w = 1.0

            future = self.cli.call_async(req)
            rclpy.spin_until_future_complete(self, future)
```

## Error Handling and Validation

### Common Spawning Issues

```python
def robust_spawn(self, name, xml, x, y, z):
    req = SpawnEntity.Request()
    req.name = name
    req.xml = xml
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = z
    req.initial_pose.orientation.w = 1.0

    try:
        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        response = future.result()
        if response.success:
            self.get_logger().info(f'Successfully spawned {name}')
            return True
        else:
            self.get_logger().error(f'Failed to spawn {name}: {response.status_message}')
            return False

    except Exception as e:
        self.get_logger().error(f'Exception during spawning: {str(e)}')
        return False
```

### Validation Before Spawning

```python
def validate_and_spawn(self, name, xml, x, y, z):
    # Check if name is already in use
    if self.check_model_exists(name):
        self.get_logger().warn(f'Model {name} already exists, skipping spawn')
        return False

    # Validate SDF/URDF syntax
    if not self.validate_model_xml(xml):
        self.get_logger().error(f'Invalid XML for model {name}')
        return False

    # Check spawn position
    if not self.is_valid_spawn_position(x, y, z):
        self.get_logger().error(f'Invalid spawn position for {name}: ({x}, {y}, {z})')
        return False

    # Proceed with spawn
    return self.robust_spawn(name, xml, x, y, z)
```

## Performance Considerations

### Spawning Rate Limits

Manage spawning frequency to avoid overwhelming the simulation:

```python
class RateLimitedSpawner(Node):
    def __init__(self):
        super().__init__('rate_limited_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')
        self.spawn_times = {}
        self.min_spawn_interval = 0.1  # 100ms minimum between spawns

    def spawn_with_rate_limit(self, name, xml, x, y, z):
        current_time = self.get_clock().now().nanoseconds / 1e9

        if name in self.spawn_times:
            time_since_last_spawn = current_time - self.spawn_times[name]
            if time_since_last_spawn < self.min_spawn_interval:
                self.get_logger().warn(f'Spawn rate limit exceeded for {name}')
                return False

        success = self.robust_spawn(name, xml, x, y, z)
        if success:
            self.spawn_times[name] = current_time

        return success
```

### Memory Management

Monitor and manage spawned objects:

```python
class ManagedSpawner(Node):
    def __init__(self):
        super().__init__('managed_spawner')
        self.cli_spawn = self.create_client(SpawnEntity, '/spawn_entity')
        self.cli_delete = self.create_client(DeleteEntity, '/delete_entity')
        self.spawned_entities = {}
        self.max_entities = 100  # Maximum number of entities

    def managed_spawn(self, name, xml, x, y, z):
        if len(self.spawned_entities) >= self.max_entities:
            # Remove oldest entity to make room
            oldest_name = min(self.spawned_entities.keys(),
                             key=lambda k: self.spawned_entities[k]['timestamp'])
            self.delete_entity(oldest_name)

        success = self.robust_spawn(name, xml, x, y, z)
        if success:
            self.spawned_entities[name] = {
                'timestamp': self.get_clock().now().nanoseconds / 1e9,
                'position': (x, y, z)
            }

        return success
```

## Integration with Simulation Workflows

### Scenario-Based Spawning

Create different scenarios by spawning objects based on configuration:

```python
class ScenarioManager(Node):
    def __init__(self):
        super().__init__('scenario_manager')
        self.cli_spawn = self.create_client(SpawnEntity, '/spawn_entity')
        self.cli_delete = self.create_client(DeleteEntity, '/delete_entity')

    def load_scenario(self, scenario_name):
        if scenario_name == 'warehouse':
            self.spawn_warehouse_scenario()
        elif scenario_name == 'office':
            self.spawn_office_scenario()
        elif scenario_name == 'outdoor':
            self.spawn_outdoor_scenario()
        else:
            self.get_logger().error(f'Unknown scenario: {scenario_name}')

    def spawn_warehouse_scenario(self):
        # Spawn warehouse-specific objects
        self.spawn_static_box('warehouse_wall_1', 5, 0, 1.5, 0.2, 10, 3)
        self.spawn_static_box('warehouse_wall_2', -5, 0, 1.5, 0.2, 10, 3)
        self.spawn_static_box('warehouse_wall_3', 0, 5, 1.5, 10, 0.2, 3)
        self.spawn_static_box('warehouse_wall_4', 0, -5, 1.5, 10, 0.2, 3)

        # Spawn shelves
        for i in range(5):
            for j in range(3):
                self.spawn_static_box(f'shelf_{i}_{j}',
                                    -4 + i*2, -4 + j*3, 1,
                                    1.5, 0.5, 2)

    def spawn_office_scenario(self):
        # Spawn office-specific objects
        self.spawn_static_box('office_desk_1', 0, 0, 0.75, 1.5, 0.7, 0.75)
        self.spawn_static_box('office_chair', 0.8, 0, 0.5, 0.5, 0.5, 0.5)
```

## Best Practices

### 1. Use Appropriate Model Types
- Use static models for environment elements
- Use dynamic models only when physics interaction is needed
- Consider performance implications of each choice

### 2. Validate Spawning Parameters
- Check for name conflicts before spawning
- Validate positions to avoid collisions
- Ensure proper XML/SDF formatting

### 3. Handle Failures Gracefully
- Implement proper error handling
- Log spawning results for debugging
- Provide fallback mechanisms

### 4. Monitor Performance
- Limit spawning rate to maintain simulation stability
- Track spawned objects to prevent memory issues
- Use appropriate collision geometry complexity

## Summary

Spawning objects via ROS 2 enables dynamic and adaptive simulation environments for digital twin applications. By understanding the spawning services, implementing proper error handling, and following performance best practices, you can create sophisticated simulation scenarios that respond to real-world conditions and robot behaviors. The ability to dynamically add and remove objects during simulation is crucial for testing, validation, and interactive applications in robotics.

## References

1. Open Source Robotics Foundation. (2023). Gazebo Services Documentation. https://gazebosim.org/services
2. ROS 2 Documentation. (2023). Client-Server Communication. https://docs.ros.org/en/rolling/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client.html
3. Gazebo Model Database. (2023). Custom Model Creation. https://gazebosim.org/models

## Exercises

1. Create a ROS 2 node that spawns objects based on user commands
2. Implement batch spawning of objects in a grid pattern
3. Develop a scenario manager that loads different environments
4. Add custom plugins to spawned objects for specific behaviors