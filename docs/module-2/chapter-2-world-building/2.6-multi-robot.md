# 2.6 Multi-Robot and Multi-Environment Simulation

## Introduction

Multi-robot simulation in Gazebo enables the testing and validation of complex robotic systems involving multiple autonomous agents. This chapter covers the implementation of multi-robot scenarios, environment management for multiple robots, communication patterns, and performance optimization techniques. Multi-robot simulation is essential for validating coordination algorithms, swarm behaviors, and collaborative robotics applications in digital twin systems.

## Multi-Robot Architecture in Gazebo

### Robot Namespacing

Each robot in a multi-robot simulation requires unique namespacing to avoid topic and service conflicts:

```xml
<!-- Robot 1 configuration -->
<model name="robot1">
  <include>
    <uri>model://turtlebot3_waffle</uri>
    <name>robot1</name>
    <pose>0 0 0 0 0 0</pose>
  </include>
</model>

<!-- Robot 2 configuration -->
<model name="robot2">
  <include>
    <uri>model://turtlebot3_waffle</uri>
    <name>robot2</name>
    <pose>2 0 0 0 0 0</pose>
  </include>
</model>
```

### TF Frame Management

Proper TF frame management is crucial for multi-robot systems:

```xml
<!-- Robot 1 TF frames -->
<robot_namespace>robot1</robot_namespace>
<ros>
  <remapping>cmd_vel:=robot1/cmd_vel</remapping>
  <remapping>odom:=robot1/odom</remapping>
  <remapping>scan:=robot1/scan</remapping>
</ros>
```

### Example Multi-Robot World File

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="multi_robot_world">
    <!-- Physics configuration -->
    <physics type="bullet">
      <gravity>0 0 -9.8</gravity>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Environment -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Robot 1 -->
    <model name="robot1">
      <include>
        <uri>model://custom_robot</uri>
        <name>robot1</name>
        <pose>0 0 0.1 0 0 0</pose>
      </include>
    </model>

    <!-- Robot 2 -->
    <model name="robot2">
      <include>
        <uri>model://custom_robot</uri>
        <name>robot2</name>
        <pose>2 0 0.1 0 0 0</pose>
      </include>
    </model>

    <!-- Robot 3 -->
    <model name="robot3">
      <include>
        <uri>model://custom_robot</uri>
        <name>robot3</name>
        <pose>-2 0 0.1 0 0 0</pose>
      </include>
    </model>

    <!-- Static obstacles -->
    <model name="obstacle_1">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry><box><size>1 1 1</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>1 1 1</size></box></geometry>
          <material><ambient>0.5 0.5 0.5 1</ambient></material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

## ROS 2 Multi-Robot Configuration

### Launch File for Multi-Robot Simulation

```python
# multi_robot_launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Launch configuration variables
    robot_count = LaunchConfiguration('robot_count', default='3')
    world_name = LaunchConfiguration('world', default='multi_robot_world')

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
        launch_arguments={
            'world': PathJoinSubstitution([
                FindPackageShare('textbook_gazebo'),
                'worlds',
                [world_name, '.world']
            ])
        }.items()
    )

    # Robot spawner nodes
    robot_spawners = []
    for i in range(int(robot_count.perform(LaunchConfiguration('3')))):
        robot_name = f'robot{i+1}'

        # Spawn robot
        spawn_robot = Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=[
                '-entity', robot_name,
                '-topic', f'/{robot_name}/robot_description',
                '-x', str(i * 2.0),
                '-y', '0.0',
                '-z', '0.1'
            ],
            output='screen'
        )
        robot_spawners.append(spawn_robot)

    # Robot controller nodes
    robot_controllers = []
    for i in range(int(robot_count.perform(LaunchConfiguration('3')))):
        robot_name = f'robot{i+1}'

        # Robot state publisher
        robot_state_publisher = Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            namespace=robot_name,
            parameters=[{
                'use_sim_time': True,
                'robot_description': Command([
                    'xacro ',
                    PathJoinSubstitution([
                        FindPackageShare('textbook_gazebo'),
                        'urdf',
                        'robot.urdf.xacro'
                    ]),
                    ' robot_name:=', robot_name
                ])
            }],
            remappings=[
                ('/tf', 'tf'),
                ('/tf_static', 'tf_static')
            ]
        )
        robot_controllers.append(robot_state_publisher)

    return LaunchDescription([
        DeclareLaunchArgument('robot_count', default_value='3', description='Number of robots'),
        DeclareLaunchArgument('world', default_value='multi_robot_world', description='Choose one of the world files from `/textbook_gazebo/worlds`'),
        gazebo
    ] + robot_spawners + robot_controllers)
```

### Robot Description with Namespacing

```xml
<!-- robot.urdf.xacro -->
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="$(arg robot_name)">

  <xacro:arg name="robot_name" default="robot"/>
  <xacro:property name="robot_name" value="$(arg robot_name)"/>

  <!-- Base link -->
  <link name="${robot_name}/base_link">
    <visual>
      <geometry>
        <cylinder radius="0.15" length="0.1"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 0.8 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.15" length="0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Sensor mounts -->
  <joint name="${robot_name}/lidar_joint" type="fixed">
    <parent link="${robot_name}/base_link"/>
    <child link="${robot_name}/lidar_link"/>
    <origin xyz="0.1 0 0.1" rpy="0 0 0"/>
  </joint>

  <link name="${robot_name}/lidar_link">
    <visual>
      <geometry>
        <cylinder radius="0.05" length="0.05"/>
      </geometry>
    </visual>
  </link>

  <!-- Gazebo plugins with namespacing -->
  <gazebo reference="${robot_name}/base_link">
    <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo>
    <plugin name="diff_drive_${robot_name}" filename="libgazebo_ros_diff_drive.so">
      <ros>
        <namespace>${robot_name}</namespace>
        <remapping>cmd_vel:=cmd_vel</remapping>
        <remapping>odom:=odom</remapping>
      </ros>
      <update_rate>30</update_rate>
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>
      <wheel_separation>0.3</wheel_separation>
      <wheel_diameter>0.1</wheel_diameter>
      <max_wheel_torque>20</max_wheel_torque>
      <max_wheel_acceleration>1.0</max_wheel_acceleration>
    </plugin>
  </gazebo>

  <!-- LiDAR sensor -->
  <gazebo reference="${robot_name}/lidar_link">
    <sensor name="${robot_name}_lidar" type="ray">
      <pose>0 0 0 0 0 0</pose>
      <visualize>false</visualize>
      <update_rate>10</update_rate>
      <ray>
        <scan>
          <horizontal>
            <samples>360</samples>
            <resolution>1</resolution>
            <min_angle>-3.14159</min_angle>
            <max_angle>3.14159</max_angle>
          </horizontal>
        </scan>
        <range>
          <min>0.1</min>
          <max>30</max>
          <resolution>0.01</resolution>
        </range>
      </ray>
      <plugin name="sensor_${robot_name}" filename="libgazebo_ros_ray_sensor.so">
        <ros>
          <namespace>${robot_name}</namespace>
          <remapping>~/out:=scan</remapping>
        </ros>
        <output_type>sensor_msgs/LaserScan</output_type>
      </plugin>
    </sensor>
  </gazebo>

</robot>
```

## Multi-Robot Communication Patterns

### Topic-Based Communication

Each robot publishes and subscribes to namespaced topics:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist, Pose
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
import tf2_ros

class MultiRobotController(Node):
    def __init__(self):
        super().__init__('multi_robot_controller')

        # Get robot namespace
        self.robot_namespace = self.get_namespace().strip('/')

        # Create subscribers for each robot's sensor data
        self.scan_subscription = self.create_subscription(
            LaserScan,
            f'/{self.robot_namespace}/scan',
            self.scan_callback,
            10
        )

        self.odom_subscription = self.create_subscription(
            Odometry,
            f'/{self.robot_namespace}/odom',
            self.odom_callback,
            10
        )

        # Create publisher for robot's velocity commands
        self.cmd_vel_publisher = self.create_publisher(
            Twist,
            f'/{self.robot_namespace}/cmd_vel',
            10
        )

        # Create publishers for inter-robot communication
        self.robot_state_publisher = self.create_publisher(
            Pose,
            '/robot_states',
            10
        )

        # Timer for control loop
        self.timer = self.create_timer(0.1, self.control_loop)

        # Robot state
        self.current_pose = Pose()
        self.current_twist = Twist()
        self.scan_data = None

    def scan_callback(self, msg):
        self.scan_data = msg

    def odom_callback(self, msg):
        self.current_pose = msg.pose.pose
        self.current_twist = msg.twist.twist

    def control_loop(self):
        # Implement robot-specific control logic
        cmd_vel = Twist()

        # Example: Simple obstacle avoidance
        if self.scan_data:
            # Check for obstacles in front
            front_scan = self.scan_data.ranges[len(self.scan_data.ranges)//2]
            if front_scan < 1.0:  # Obstacle within 1 meter
                cmd_vel.linear.x = 0.0
                cmd_vel.angular.z = 0.5  # Turn
            else:
                cmd_vel.linear.x = 0.5  # Forward
                cmd_vel.angular.z = 0.0

        # Publish velocity command
        self.cmd_vel_publisher.publish(cmd_vel)

        # Publish robot state for inter-robot communication
        self.publish_robot_state()

    def publish_robot_state(self):
        state_msg = Pose()
        state_msg.position = self.current_pose.position
        state_msg.orientation = self.current_pose.orientation

        # Add robot ID to distinguish between robots
        # This would typically be done with a custom message
        self.robot_state_publisher.publish(state_msg)
```

### Service-Based Communication

Robots can use services for direct communication:

```python
from multi_robot_interfaces.srv import RobotCoordination

class RobotCoordinator(Node):
    def __init__(self):
        super().__init__('robot_coordinator')

        # Create service for other robots to request coordination
        self.coordination_service = self.create_service(
            RobotCoordination,
            '/request_coordination',
            self.handle_coordination_request
        )

        # Create clients for other robots
        self.robot_clients = {}
        for i in range(1, 4):  # Assuming 3 robots
            robot_name = f'robot{i}'
            self.robot_clients[robot_name] = self.create_client(
                RobotCoordination,
                f'/{robot_name}/request_coordination'
            )

    def handle_coordination_request(self, request, response):
        # Handle coordination request from another robot
        requesting_robot = request.robot_id
        task = request.task

        # Implement coordination logic
        response.accepted = self.evaluate_coordination_request(requesting_robot, task)
        response.message = "Coordination request processed"

        return response

    def evaluate_coordination_request(self, requesting_robot, task):
        # Logic to determine if coordination should be accepted
        # This could involve checking current robot state, task priorities, etc.
        return True
```

## Performance Optimization for Multi-Robot Systems

### Physics Optimization

```xml
<!-- Optimized physics settings for multi-robot simulation -->
<physics type="bullet">
  <gravity>0 0 -9.8</gravity>
  <max_step_size>0.01</max_step_size>  <!-- Larger step size for performance -->
  <real_time_factor>1</real_time_factor>
  <real_time_update_rate>100</real_time_update_rate>  <!-- Lower update rate -->
  <ode>
    <solver>
      <type>quick</type>
      <iters>20</iters>  <!-- Reduced iterations for performance -->
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.000001</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

### Sensor Optimization

Reduce sensor update rates for multi-robot scenarios:

```xml
<!-- Reduced update rate for LiDAR in multi-robot simulation -->
<sensor name="lidar" type="ray">
  <update_rate>5</update_rate>  <!-- Reduced from 10Hz to 5Hz -->
  <ray>
    <scan>
      <horizontal>
        <samples>180</samples>  <!-- Reduced from 360 to 180 -->
        <resolution>1</resolution>
        <min_angle>-3.14159</min_angle>
        <max_angle>3.14159</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>
      <max>15</max>  <!-- Reduced range -->
      <resolution>0.01</resolution>
    </range>
  </ray>
</sensor>
```

### Resource Management

```python
class ResourceManager(Node):
    def __init__(self):
        super().__init__('resource_manager')

        # Monitor simulation performance
        self.performance_subscription = self.create_subscription(
            String,
            '/gazebo/performance_metrics',
            self.performance_callback,
            10
        )

        # Timer to adjust simulation parameters based on performance
        self.adjustment_timer = self.create_timer(5.0, self.adjust_performance)

        self.current_update_rate = 1000
        self.current_step_size = 0.001

    def performance_callback(self, msg):
        # Parse performance metrics
        # This would typically be a custom message with performance data
        pass

    def adjust_performance(self):
        # Adjust physics parameters based on current performance
        if self.get_performance_metric() < 0.8:  # If performance is low
            # Reduce update rate
            self.current_update_rate = max(100, self.current_update_rate * 0.9)
            # Increase step size (within limits)
            self.current_step_size = min(0.01, self.current_step_size * 1.1)

            self.get_logger().info(
                f'Adjusted performance: update_rate={self.current_update_rate}, '
                f'step_size={self.current_step_size}'
            )
```

## Multi-Environment Management

### Environment Switching

```python
from gazebo_msgs.srv import SetWorldProperties

class EnvironmentManager(Node):
    def __init__(self):
        super().__init__('environment_manager')

        # Service client for world switching
        self.world_switch_client = self.create_client(
            SetWorldProperties,
            '/world_control'
        )

        # Timer to periodically evaluate environment conditions
        self.evaluation_timer = self.create_timer(10.0, self.evaluate_environment)

    def switch_environment(self, new_world_path):
        # This would involve shutting down current simulation and starting new one
        # In practice, this might require more complex orchestration
        pass

    def evaluate_environment(self):
        # Check if current environment needs to be changed
        # This could be based on robot performance, scenario requirements, etc.
        pass
```

### Dynamic Environment Elements

```xml
<!-- Environment with dynamic elements that can be controlled -->
<model name="dynamic_gate">
  <link name="frame">
    <static>true</static>
    <visual name="visual">
      <geometry><box><size>0.1 2 2</size></box></geometry>
    </visual>
  </link>
  <link name="gate">
    <inertial>
      <mass>10.0</mass>
      <inertia><ixx>1</ixx><iyy>1</iyy><izz>1</izz></inertia>
    </inertial>
    <visual name="visual">
      <geometry><box><size>1 0.1 1.5</size></box></geometry>
    </visual>
    <collision name="collision">
      <geometry><box><size>1 0.1 1.5</size></box></geometry>
    </collision>
  </link>
  <joint name="gate_joint" type="revolute">
    <parent>frame</parent>
    <child>gate</child>
    <axis><xyz>0 0 1</xyz></axis>
  </joint>
  <plugin name="gate_controller" filename="libJointPositionController.so">
    <joint_name>gate_joint</joint_name>
    <topic_name>/gate_position</topic_name>
  </plugin>
</model>
```

## Coordination Algorithms

### Leader-Follower Pattern

```python
class LeaderFollowerController(Node):
    def __init__(self):
        super().__init__('leader_follower_controller')

        self.robot_namespace = self.get_namespace().strip('/')
        self.is_leader = self.declare_parameter('is_leader', False).value

        if self.is_leader:
            # Leader publishes its trajectory
            self.trajectory_publisher = self.create_publisher(
                Path,
                '/leader_trajectory',
                10
            )
        else:
            # Followers subscribe to leader's trajectory
            self.trajectory_subscription = self.create_subscription(
                Path,
                '/leader_trajectory',
                self.trajectory_callback,
                10
            )

    def trajectory_callback(self, msg):
        if not self.is_leader:
            # Implement following logic based on leader's trajectory
            self.follow_leader(msg)

    def follow_leader(self, trajectory):
        # Calculate position relative to leader
        # Publish appropriate velocity commands
        pass
```

### Swarm Behavior Implementation

```python
class SwarmController(Node):
    def __init__(self):
        super().__init__('swarm_controller')

        self.robot_namespace = self.get_namespace().strip('/')

        # Subscribe to all robots' positions
        self.robot_positions = {}
        self.position_subscribers = []

        for i in range(1, 4):  # For 3 robots
            robot_name = f'robot{i}'
            sub = self.create_subscription(
                Pose,
                f'/{robot_name}/current_pose',
                lambda msg, name=robot_name: self.update_robot_position(name, msg),
                10
            )
            self.position_subscribers.append(sub)

    def update_robot_position(self, robot_name, pose_msg):
        self.robot_positions[robot_name] = pose_msg

    def swarm_behavior(self):
        # Implement swarm algorithms like flocking, formation, etc.
        # This would include separation, alignment, and cohesion behaviors
        pass
```

## Validation and Testing

### Multi-Robot Performance Metrics

```python
class MultiRobotValidator(Node):
    def __init__(self):
        super().__init__('multi_robot_validator')

        # Publishers for performance metrics
        self.metrics_publisher = self.create_publisher(
            String,
            '/multi_robot_metrics',
            10
        )

        # Timer for periodic validation
        self.validation_timer = self.create_timer(1.0, self.validate_system)

    def validate_system(self):
        metrics = {
            'robot_count': len(self.get_robots()),
            'avg_cpu_usage': self.get_cpu_usage(),
            'sim_time_factor': self.get_sim_time_factor(),
            'collision_count': self.get_collision_count(),
            'comm_success_rate': self.get_communication_success_rate()
        }

        # Publish metrics
        metrics_msg = String()
        metrics_msg.data = str(metrics)
        self.metrics_publisher.publish(metrics_msg)

    def get_robots(self):
        # Get list of active robots
        pass

    def get_cpu_usage(self):
        # Monitor CPU usage
        pass

    def get_sim_time_factor(self):
        # Get simulation time factor from Gazebo
        pass
```

### Collision Avoidance Validation

```python
class CollisionValidator(Node):
    def __init__(self):
        super().__init__('collision_validator')

        # Subscribe to collision events
        self.collision_subscription = self.create_subscription(
            ContactsState,
            '/gazebo/collision_states',
            self.collision_callback,
            10
        )

        self.collision_count = 0
        self.robot_collisions = {}

    def collision_callback(self, msg):
        for state in msg.states:
            # Check if collision involves robots
            if 'robot' in state.collision1_name or 'robot' in state.collision2_name:
                self.collision_count += 1
                self.get_logger().warn(f'Robot collision detected: {state.collision1_name} vs {state.collision2_name}')
```

## Best Practices for Multi-Robot Simulation

### 1. Proper Namespacing
- Use consistent naming conventions for all topics, services, and TF frames
- Implement automated validation of namespace uniqueness
- Document the namespace structure clearly

### 2. Performance Monitoring
- Monitor simulation time factor and adjust parameters accordingly
- Track resource usage (CPU, memory, GPU) during simulation
- Implement dynamic adjustment of simulation parameters

### 3. Communication Optimization
- Use appropriate QoS settings for different message types
- Implement message filtering to reduce unnecessary communication
- Consider using shared memory for high-frequency data exchange

### 4. Failure Handling
- Implement graceful degradation when robots fail
- Provide fallback behaviors for communication failures
- Log all robot states for debugging and analysis

### 5. Scalability Considerations
- Test with increasing numbers of robots to identify bottlenecks
- Optimize algorithms for the expected maximum number of robots
- Consider distributed simulation approaches for large-scale scenarios

## Troubleshooting Common Issues

### Topic Conflicts
- **Issue**: Multiple robots publishing to same topics
- **Solution**: Ensure proper namespacing and remapping

### TF Tree Conflicts
- **Issue**: Conflicting TF frames between robots
- **Solution**: Use robot-specific TF prefixes

### Performance Degradation
- **Issue**: Simulation slows down with more robots
- **Solution**: Optimize physics parameters, reduce sensor update rates

### Communication Failures
- **Issue**: Robots cannot communicate effectively
- **Solution**: Check network configuration and topic remapping

## Summary

Multi-robot simulation in Gazebo requires careful attention to namespacing, communication patterns, and performance optimization. By implementing proper architecture, coordination algorithms, and validation techniques, you can create realistic multi-robot scenarios for digital twin applications. The key to successful multi-robot simulation lies in balancing simulation fidelity with computational performance while maintaining the ability to scale to the required number of robots.

## References

1. Open Source Robotics Foundation. (2023). Gazebo Multi-Robot Tutorial. https://gazebosim.org/tutorials?tut=multi_robot
2. ROS 2 Documentation. (2023). Multi-Robot Systems. https://docs.ros.org/en/rolling/Tutorials/Advanced/Simulating-Multiple-Robots.html
3. Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo. IEEE/RSJ International Conference on Intelligent Robots and Systems.

## Exercises

1. Create a multi-robot launch file that spawns 5 robots in a warehouse environment
2. Implement a leader-follower formation control algorithm
3. Develop collision avoidance between multiple robots
4. Validate communication performance with increasing robot count