# 2.4 Importing CAD and Mesh Assets

## Introduction

Importing CAD and mesh assets into Gazebo is essential for creating realistic simulation environments that closely match real-world objects and scenarios. This chapter covers the process of converting CAD models to simulation-ready formats, optimizing mesh geometry for physics and visualization, and integrating complex 3D assets into Gazebo environments. Proper mesh handling ensures accurate physics simulation while maintaining performance.

## Mesh File Formats in Gazebo

### Supported Formats

Gazebo supports several 3D mesh formats for both visual and collision geometry:

1. **DAE (Collada)**: Most widely supported format with good material support
2. **STL**: Simple format for basic geometry (no materials or textures)
3. **OBJ**: Common format with material support
4. **PLY**: Polygon file format for complex meshes
5. **3DS**: 3D Studio format (legacy support)

### Recommended Format: DAE (Collada)

DAE is the preferred format due to its comprehensive support for:
- Geometry and topology information
- Material properties and textures
- Hierarchical structure
- Multiple mesh components

### Example DAE Integration

```xml
<model name="custom_object">
  <link name="link">
    <visual name="visual">
      <geometry>
        <mesh>
          <uri>model://custom_object/meshes/object.dae</uri>
        </mesh>
      </geometry>
      <material>
        <script>
          <uri>file://media/materials/scripts/gazebo.material</uri>
          <name>Gazebo/Orange</name>
        </script>
      </material>
    </visual>
    <collision name="collision">
      <geometry>
        <mesh>
          <uri>model://custom_object/meshes/object.dae</uri>
        </mesh>
      </geometry>
    </collision>
  </link>
</model>
```

## CAD to Gazebo Workflow

### Step 1: CAD Model Preparation

Before importing CAD models into Gazebo, ensure they are properly prepared:

1. **Unit Consistency**: Ensure all dimensions are in meters (Gazebo's default unit)
2. **Coordinate System**: Use right-handed coordinate system (X forward, Y left, Z up)
3. **Origin Positioning**: Position the model's origin at a logical point (usually the base or center)
4. **Scale Verification**: Verify that the model is correctly scaled for simulation

### Step 2: Export from CAD Software

When exporting from CAD software, follow these guidelines:

#### SolidWorks Export
1. Export as STEP or IGES format
2. Convert to DAE using mesh processing tools
3. Verify units are in meters

#### Fusion 360 Export
1. Export as STL, OBJ, or DAE
2. Ensure units are set to meters
3. Optimize mesh density for simulation

#### Blender Export
1. Import CAD file into Blender
2. Clean up geometry and optimize mesh
3. Export as DAE with proper scale

### Step 3: Mesh Optimization

Optimize meshes for both visual and collision performance:

#### Visual Mesh Optimization
- **Polygon Count**: Reduce to 10,000-50,000 polygons for complex objects
- **Texture Resolution**: Use 1024x1024 or 2048x2048 textures
- **UV Mapping**: Ensure proper texture coordinate mapping

#### Collision Mesh Optimization
- **Simplified Geometry**: Use much simpler geometry than visual mesh
- **Convex Hulls**: Convert complex meshes to convex hulls when possible
- **Triangle Count**: Keep under 1,000 triangles for collision meshes

## Mesh Processing Tools

### MeshLab

MeshLab is a powerful open-source tool for mesh processing:

```bash
# Simplify mesh to target triangle count
meshlabserver -i input.obj -o output.obj -s simplify_script.mlx

# Repair mesh normals and topology
meshlabserver -i input.obj -o output.obj -s repair_script.mlx
```

### Blender

Blender provides comprehensive mesh processing capabilities:

```python
# Example Blender script for mesh optimization
import bpy

# Select object
bpy.context.view_layer.objects.active = bpy.data.objects['ObjectName']
bpy.data.objects['ObjectName'].select_set(True)

# Apply decimation modifier
mod = bpy.context.object.modifiers.new(name="Decimate", type='DECIMATE')
mod.ratio = 0.5  # Reduce to 50% of original vertices

# Apply modifier
bpy.ops.object.modifier_apply(modifier="Decimate")

# Export optimized mesh
bpy.ops.export_scene.obj(filepath="optimized_mesh.obj")
```

### Open3D

Open3D provides Python-based mesh processing:

```python
import open3d as o3d

# Load mesh
mesh = o3d.io.read_triangle_mesh("input_mesh.stl")

# Simplify mesh
simplified_mesh = mesh.simplify_quadric_decimation(target_number_of_triangles=1000)

# Save simplified mesh
o3d.io.write_triangle_mesh("simplified_mesh.stl", simplified_mesh)
```

## Gazebo Model Structure

### Model Directory Organization

Gazebo expects a specific directory structure for custom models:

```
~/.gazebo/models/custom_robot/
├── model.config          # Model metadata and configuration
├── meshes/
│   ├── visual/
│   │   └── robot_visual.dae
│   └── collision/
│       └── robot_collision.dae
├── materials/
│   ├── scripts/
│   │   └── custom_materials.g.material
│   └── textures/
│       └── robot_texture.png
└── model.sdf             # SDF description of the model
```

### Model Configuration File

The `model.config` file provides metadata about the model:

```xml
<?xml version="1.0"?>
<model>
  <name>custom_robot</name>
  <version>1.0</version>
  <sdf version="1.7">model.sdf</sdf>
  <author>
    <name>Your Name</name>
    <email>your.email@example.com</email>
  </author>
  <description>A custom robot model with imported CAD assets.</description>
</model>
```

## Collision Mesh Optimization

### Importance of Collision Meshes

Collision meshes are critical for physics simulation performance and stability. They should be:
- **Simpler than visual meshes**: Lower polygon count for better performance
- **Watertight**: No holes or gaps in the mesh
- **Convex when possible**: Convex meshes are more efficient for collision detection

### Creating Simplified Collision Meshes

#### Using Convex Decomposition

For complex meshes, use convex decomposition:

```python
import numpy as np
from scipy.spatial import ConvexHull

def create_convex_collision_mesh(visual_mesh_path, output_path):
    # Load visual mesh
    mesh = o3d.io.read_triangle_mesh(visual_mesh_path)

    # Create convex hull
    hull, _ = mesh.compute_convex_hull()

    # Save collision mesh
    o3d.io.write_triangle_mesh(output_path, hull)
```

#### Using Simplified Geometries

Replace complex meshes with simpler geometric primitives when appropriate:

```xml
<!-- Instead of complex mesh collision -->
<collision name="collision">
  <geometry>
    <mesh>
      <uri>model://robot/meshes/complex_collision.dae</uri>
    </mesh>
  </geometry>
</collision>

<!-- Use simplified geometry -->
<collision name="collision">
  <geometry>
    <box>
      <size>0.5 0.3 0.4</size>
    </box>
  </geometry>
</collision>
```

## Material and Texture Integration

### Material Definition in SDF

Materials can be defined directly in SDF or referenced from material scripts:

```xml
<visual name="visual">
  <geometry>
    <mesh>
      <uri>model://robot/meshes/visual.dae</uri>
    </mesh>
  </geometry>
  <material>
    <ambient>0.1 0.1 0.1 1</ambient>
    <diffuse>0.7 0.7 0.7 1</diffuse>
    <specular>0.01 0.01 0.01 1</specular>
    <emissive>0 0 0 1</emissive>
  </material>
</visual>
```

### Texture Mapping

For complex textures, use material scripts:

```material
material CustomRobotMaterial
{
  technique
  {
    pass
    {
      ambient 0.1 0.1 0.1 1.0
      diffuse 0.8 0.8 0.8 1.0
      specular 0.2 0.2 0.2 1.0

      texture_unit
      {
        texture robot_texture.png
        filtering anisotropic
        max_anisotropy 16
      }
    }
  }
}
```

## Performance Optimization Strategies

### Level of Detail (LOD)

Implement LOD for complex models based on distance from camera:

```xml
<visual name="visual">
  <geometry>
    <mesh>
      <uri>model://robot/meshes/robot_lod0.dae</uri>
    </mesh>
  </geometry>
  <laser_retro>0.0</laser_retro>
  <transparency>0.0</transparency>
  <cast_shadows>true</cast_shadows>
</visual>
```

### Mesh Simplification Guidelines

1. **Visual Meshes**: 10,000-50,000 triangles for complex objects
2. **Collision Meshes**: 500-2,000 triangles maximum
3. **Simple Objects**: 100-1,000 triangles for basic geometry
4. **Large Environments**: Use instancing for repeated objects

### Memory Management

Monitor memory usage when importing large meshes:

```xml
<!-- Use model instancing for repeated objects -->
<include>
  <uri>model://table</uri>
  <pose>1 0 0 0 0 0</pose>
</include>
<include>
  <uri>model://table</uri>
  <pose>2 0 0 0 0 0</pose>
</include>
```

## Validation and Quality Assurance

### Mesh Validation

Validate imported meshes for simulation readiness:

```python
import open3d as o3d

def validate_mesh(mesh_path):
    mesh = o3d.io.read_triangle_mesh(mesh_path)

    # Check if mesh is watertight
    is_watertight = mesh.is_watertight()
    print(f"Is watertight: {is_watertight}")

    # Check triangle count
    triangle_count = len(mesh.triangles)
    print(f"Triangle count: {triangle_count}")

    # Check for degenerate triangles
    is_edge_manifold = mesh.is_edge_manifold(allow_boundary_edges=True)
    print(f"Is edge manifold: {is_edge_manifold}")

    return is_watertight and triangle_count < 50000
```

### Physics Validation

Test imported models in physics simulation:

1. **Stability**: Ensure objects don't exhibit unexpected behavior
2. **Collision Detection**: Verify proper collision response
3. **Performance**: Monitor simulation frame rate with new models
4. **Realism**: Check that physical behavior matches expectations

## Troubleshooting Common Issues

### Mesh Import Problems

#### Scale Issues
- **Problem**: Objects appear too large or small
- **Solution**: Verify units are in meters, check CAD export settings

#### Orientation Problems
- **Problem**: Objects are rotated incorrectly
- **Solution**: Verify coordinate system (X forward, Y left, Z up)

#### Texture Problems
- **Problem**: Textures don't appear correctly
- **Solution**: Check texture paths and material definitions

### Performance Issues

#### Slow Simulation
- **Problem**: Simulation runs slowly with imported models
- **Solution**: Simplify collision meshes, reduce visual polygon count

#### High Memory Usage
- **Problem**: Memory consumption is excessive
- **Solution**: Optimize mesh complexity, use instancing

## Advanced Techniques

### Procedural Mesh Generation

For parametric models, generate meshes programmatically:

```python
def generate_parametric_mesh(length, width, height):
    """Generate a parametric box mesh"""
    import numpy as np

    # Define vertices
    vertices = np.array([
        [-length/2, -width/2, -height/2],  # 0
        [length/2, -width/2, -height/2],   # 1
        [length/2, width/2, -height/2],    # 2
        [-length/2, width/2, -height/2],   # 3
        [-length/2, -width/2, height/2],   # 4
        [length/2, -width/2, height/2],    # 5
        [length/2, width/2, height/2],     # 6
        [-length/2, width/2, height/2],    # 7
    ])

    # Define faces
    faces = np.array([
        [0, 1, 2], [0, 2, 3],  # bottom
        [4, 7, 6], [4, 6, 5],  # top
        [0, 4, 5], [0, 5, 1],  # front
        [2, 6, 7], [2, 7, 3],  # back
        [0, 3, 7], [0, 7, 4],  # left
        [1, 5, 6], [1, 6, 2],  # right
    ])

    return vertices, faces
```

### Multi-Resolution Meshes

Use different mesh resolutions for different purposes:

```xml
<model name="multi_resolution_object">
  <link name="link">
    <!-- High-resolution visual mesh -->
    <visual name="visual">
      <geometry>
        <mesh>
          <uri>model://object/meshes/visual_high_res.dae</uri>
        </mesh>
      </geometry>
    </visual>

    <!-- Medium-resolution collision mesh -->
    <collision name="collision">
      <geometry>
        <mesh>
          <uri>model://object/meshes/collision_medium_res.dae</uri>
        </mesh>
      </geometry>
    </collision>

    <!-- Simple bounding box for physics optimization -->
    <collision name="bounding_box">
      <geometry>
        <box>
          <size>1.0 1.0 1.0</size>
        </box>
      </geometry>
    </collision>
  </link>
</model>
```

## Integration with ROS 2

### Model Spawning with Custom Meshes

When spawning models with custom meshes via ROS 2:

```python
import rclpy
from gazebo_msgs.srv import SpawnEntity
from std_msgs.msg import String

def spawn_custom_model():
    node = rclpy.create_node('model_spawner')
    client = node.create_client(SpawnEntity, '/spawn_entity')

    # Load model from file
    with open('path/to/model.sdf', 'r') as model_file:
        model_xml = model_file.read()

    request = SpawnEntity.Request()
    request.name = "custom_robot"
    request.xml = model_xml
    request.robot_namespace = ""
    request.initial_pose.position.x = 0.0
    request.initial_pose.position.y = 0.0
    request.initial_pose.position.z = 0.0

    future = client.call_async(request)
    rclpy.spin_until_future_complete(node, future)
```

## Best Practices Summary

1. **Use DAE format** for best compatibility and feature support
2. **Optimize collision meshes** separately from visual meshes
3. **Maintain proper units** (meters for Gazebo)
4. **Validate mesh quality** before simulation use
5. **Test performance** with new models in your specific environment
6. **Document mesh sources** and modification history
7. **Use appropriate LOD** based on application requirements

## Summary

Importing CAD and mesh assets into Gazebo requires careful attention to format compatibility, mesh optimization, and performance considerations. Proper mesh handling ensures that simulation environments accurately represent real-world objects while maintaining computational efficiency. The process involves CAD preparation, mesh optimization, and validation to ensure both visual fidelity and physics accuracy.

## References

1. Open Source Robotics Foundation. (2023). Gazebo Model Database Tutorial. https://gazebosim.org/tutorials?tut=model_structure
2. CAD-to-Gazebo Pipeline. (2023). ROS-Industrial Consortium. https://ros-industrial.github.io/industrial_training/
3. Open3D Documentation. (2023). 3D Data Processing and Visualization. http://www.open3d.org/

## Exercises

1. Import a simple CAD model and optimize it for Gazebo simulation
2. Create collision meshes with different levels of simplification
3. Test performance differences between high and low-resolution meshes
4. Validate that imported models behave correctly in physics simulation