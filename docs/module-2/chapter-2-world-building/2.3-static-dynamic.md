# 2.3 Static vs Dynamic Objects

## Introduction

Understanding the distinction between static and dynamic objects in Gazebo is crucial for creating efficient and realistic simulation environments. Static objects remain fixed in space and do not respond to physics forces, while dynamic objects interact with the physics engine and can move, collide, and respond to forces. This chapter explores the implementation and optimization of both object types for digital twin applications.

## Static Objects in Gazebo

### Definition and Characteristics

Static objects in Gazebo are elements that do not move or respond to physical forces during simulation. They serve as the fixed infrastructure of the environment, such as walls, floors, furniture, and architectural elements.

### Implementation

Static objects are defined in SDF with the `<static>` tag set to `true`:

```xml
<model name="static_wall">
  <static>true</static>
  <link name="link">
    <collision name="collision">
      <geometry>
        <box>
          <size>3 0.1 2</size>
        </box>
      </geometry>
      <surface>
        <friction>
          <ode>
            <mu>1.0</mu>
            <mu2>1.0</mu2>
          </ode>
        </friction>
      </surface>
    </collision>
    <visual name="visual">
      <geometry>
        <box>
          <size>3 0.1 2</size>
        </box>
      </geometry>
      <material>
        <script>
          <uri>file://media/materials/scripts/gazebo.material</uri>
          <name>Gazebo/White</name>
        </script>
      </material>
    </visual>
  </link>
</model>
```

### Performance Benefits

Static objects provide significant performance advantages:

1. **Reduced Physics Calculations**: No need to calculate motion, acceleration, or velocity
2. **Optimized Collision Detection**: Fixed spatial relationships can be precomputed
3. **Memory Efficiency**: No need to store dynamic state information
4. **Stability**: No risk of physics-related instabilities or drift

### Common Static Object Applications

- **Building Infrastructure**: Walls, floors, ceilings, stairs
- **Furniture**: Tables, chairs, cabinets (when fixed in place)
- **Landscaping**: Fixed terrain, rock formations, permanent structures
- **Infrastructure**: Traffic signs, lamp posts, fixed equipment

## Dynamic Objects in Gazebo

### Definition and Characteristics

Dynamic objects respond to physics forces, can move, collide with other objects, and participate fully in the simulation physics. They have mass, can be affected by gravity, and interact with other dynamic and static objects.

### Implementation

Dynamic objects are defined without the `<static>` tag or with `<static>false</static>`:

```xml
<model name="dynamic_box">
  <link name="link">
    <inertial>
      <mass>1.0</mass>
      <inertia>
        <ixx>0.083</ixx>
        <ixy>0</ixy>
        <ixz>0</ixz>
        <iyy>0.083</iyy>
        <iyz>0</iyz>
        <izz>0.083</izz>
      </inertia>
    </inertial>
    <collision name="collision">
      <geometry>
        <box>
          <size>0.5 0.5 0.5</size>
        </box>
      </geometry>
      <surface>
        <friction>
          <ode>
            <mu>0.5</mu>
            <mu2>0.5</mu2>
          </ode>
        </friction>
      </surface>
    </collision>
    <visual name="visual">
      <geometry>
        <box>
          <size>0.5 0.5 0.5</size>
        </box>
      </geometry>
      <material>
        <script>
          <uri>file://media/materials/scripts/gazebo.material</uri>
          <name>Gazebo/Blue</name>
        </script>
      </material>
    </visual>
  </link>
</model>
```

### Key Components of Dynamic Objects

#### Inertial Properties

The `<inertial>` block defines how the object responds to forces:

```xml
<inertial>
  <mass>1.0</mass>  <!-- Mass in kilograms -->
  <inertia>
    <!-- Moments of inertia (Ixx, Iyy, Izz) and products of inertia (Ixy, Ixz, Iyz) -->
    <ixx>0.083</ixx>
    <ixy>0</ixy>
    <ixz>0</ixz>
    <iyy>0.083</iyy>
    <iyz>0</iyz>
    <izz>0.083</izz>
  </inertia>
</inertial>
```

#### Collision Properties

Collision geometry defines how the object interacts with other objects:

```xml
<collision name="collision">
  <geometry>
    <box>
      <size>0.5 0.5 0.5</size>
    </box>
  </geometry>
  <surface>
    <friction>
      <ode>
        <mu>0.5</mu>  <!-- Primary friction coefficient -->
        <mu2>0.5</mu2>  <!-- Secondary friction coefficient -->
      </ode>
    </friction>
    <bounce>
      <restitution_coefficient>0.1</restitution_coefficient>  <!-- Bounciness -->
    </bounce>
  </surface>
</collision>
```

## Performance Considerations

### Static Object Optimization

1. **Collision Mesh Simplification**: Use simplified collision meshes for static objects
2. **Spatial Partitioning**: Static objects enable efficient spatial partitioning algorithms
3. **Level of Detail**: Use detailed visual geometry with simplified collision geometry

### Dynamic Object Optimization

1. **Mass Distribution**: Proper mass distribution prevents simulation instability
2. **Collision Geometry**: Simplified collision geometry improves performance
3. **Update Frequency**: Adjust physics update rates based on object importance
4. **Sleeping Thresholds**: Enable sleeping for objects at rest to save computation

## Advanced Dynamic Object Features

### Joints and Articulation

Dynamic objects can be connected with joints to create articulated systems:

```xml
<model name="articulated_arm">
  <!-- Base link (static or dynamic) -->
  <link name="base">
    <inertial>
      <mass>5.0</mass>
      <inertia>...</inertia>
    </inertial>
    <visual>...</visual>
    <collision>...</collision>
  </link>

  <!-- First arm segment -->
  <link name="link1">
    <inertial>
      <mass>2.0</mass>
      <inertia>...</inertia>
    </inertial>
    <visual>...</visual>
    <collision>...</collision>
  </link>

  <!-- Revolute joint connecting base to first segment -->
  <joint name="joint1" type="revolute">
    <parent>base</parent>
    <child>link1</child>
    <axis>
      <xyz>0 0 1</xyz>  <!-- Rotation axis -->
      <limit>
        <lower>-1.57</lower>  <!-- -90 degrees -->
        <upper>1.57</upper>   <!-- 90 degrees -->
        <effort>100</effort>  <!-- Maximum torque -->
        <velocity>1.0</velocity>  <!-- Maximum velocity -->
      </limit>
    </axis>
  </joint>
</model>
```

### Dynamic Properties via Plugins

Gazebo plugins can modify object properties during simulation:

```xml
<model name="dynamic_object_with_plugin">
  <link name="link">
    <!-- Link definition -->
  </link>
  <plugin name="model_pusher" filename="libModelPusher.so">
    <frequency>1</frequency>
    <force>5 0 0</force>
  </plugin>
</model>
```

## Static vs Dynamic Decision Framework

### When to Use Static Objects

- **Fixed Infrastructure**: Walls, floors, permanent fixtures
- **Unchanging Environments**: Static terrain, fixed obstacles
- **Performance Critical**: When many objects need to be in the scene
- **Stability Requirements**: When simulation stability is paramount

### When to Use Dynamic Objects

- **Interactive Elements**: Objects that robots can manipulate
- **Moving Components**: Doors, elevators, conveyors
- **Physics Validation**: Objects that need realistic physics response
- **Sensor Testing**: Objects that should respond to robot interactions

## Multi-Object Scenarios

### Static Environment with Dynamic Objects

The most common pattern is a static environment with dynamic objects:

```xml
<!-- Static environment -->
<model name="room">
  <static>true</static>
  <!-- Room definition -->
</model>

<!-- Dynamic objects in the room -->
<model name="robot">
  <!-- Dynamic robot model -->
</model>

<model name="movable_box">
  <link name="link">
    <inertial>
      <mass>2.0</mass>
      <inertia>...</inertia>
    </inertial>
    <!-- Other properties -->
  </link>
</model>
```

### Dynamic Environment Elements

Some environments may have dynamic components:

```xml
<model name="moving_door">
  <link name="door_frame">
    <static>true</static>
    <!-- Fixed frame -->
  </link>
  <link name="door_panel">
    <inertial>
      <mass>10.0</mass>
      <inertia>...</inertia>
    </inertial>
    <!-- Moving panel -->
  </link>
  <joint name="door_hinge" type="revolute">
    <parent>door_frame</parent>
    <child>door_panel</child>
    <axis><xyz>0 0 1</xyz></axis>
  </joint>
</model>
```

## ROS 2 Integration Considerations

### Static Objects

Static objects require minimal ROS 2 interaction since they don't change state:

- **TF Publishing**: Static transforms for fixed objects
- **Model Spawning**: Typically spawned once at simulation start
- **Collision Checking**: Not typically needed during runtime

### Dynamic Objects

Dynamic objects require more extensive ROS 2 integration:

- **State Publishing**: Joint states, model poses
- **Control Interfaces**: Joint commands, model forces
- **Sensor Integration**: Object detection, manipulation feedback
- **Dynamic Reconfiguration**: Runtime parameter changes

## Validation and Testing

### Static Object Validation

1. **Stability**: Ensure objects remain fixed in position
2. **Collision**: Verify proper collision detection with dynamic objects
3. **Performance**: Measure simulation frame rate with various static object counts
4. **Memory Usage**: Monitor memory consumption with static objects

### Dynamic Object Validation

1. **Physics Response**: Verify realistic response to forces and collisions
2. **Stability**: Check for simulation instabilities with multiple dynamic objects
3. **Performance**: Measure frame rate degradation with dynamic objects
4. **Energy Conservation**: Verify realistic energy transfer in collisions

## Best Practices

### For Static Objects

1. **Use Appropriate Collision Geometry**: Simplified geometry for better performance
2. **Group Related Objects**: Combine multiple static elements into single models when possible
3. **Validate Static Flag**: Ensure objects that should be static are properly flagged
4. **Optimize Materials**: Use efficient materials for static objects

### For Dynamic Objects

1. **Realistic Inertial Properties**: Use accurate mass and inertia values
2. **Appropriate Friction**: Set friction coefficients based on real-world materials
3. **Stable Joints**: Use appropriate joint limits and damping
4. **Performance Monitoring**: Monitor simulation performance with dynamic objects

## Troubleshooting Common Issues

### Static Object Issues

- **Unexpected Movement**: Check that `<static>` is set to `true`
- **Collision Problems**: Verify collision geometry is properly defined
- **Performance**: Ensure static objects don't have unnecessary dynamic properties

### Dynamic Object Issues

- **Instability**: Check mass, inertia, and friction values
- **Penetration**: Increase physics iterations or adjust collision properties
- **Excessive Drift**: Verify joint constraints and damping

## Summary

The proper use of static and dynamic objects is fundamental to creating efficient and realistic Gazebo simulations. Static objects provide the stable foundation for the environment while dynamic objects enable interactive and responsive simulation scenarios. Understanding when to use each type and how to implement them effectively is essential for digital twin applications in robotics.

## References

1. Open Source Robotics Foundation. (2023). Gazebo Static vs Dynamic Objects. https://gazebosim.org/tutorials?tut=kinematic_loop
2. Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo. IEEE/RSJ International Conference on Intelligent Robots and Systems.
3. Coumans, E. (2023). Bullet Physics Engine Documentation. https://pybullet.org/

## Exercises

1. Create a scene with both static and dynamic objects and observe performance differences
2. Implement an articulated mechanism using joints between dynamic links
3. Test how different inertial properties affect object behavior
4. Validate collision detection between static and dynamic objects