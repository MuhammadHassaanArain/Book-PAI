---
title: Global and Local Planning for Humanoid Navigation
description: Comprehensive coverage of global and local path planning algorithms adapted for humanoid robot navigation
sidebar_position: 3
---

# 3.3 Global and Local Planning for Humanoid Navigation

## Overview

Path planning is a fundamental component of autonomous navigation, enabling humanoid robots to navigate efficiently and safely through complex environments. The Nav2 stack implements a two-tier planning approach: global planning for long-term path generation and local planning for real-time trajectory execution. For humanoid robots, these planning systems must account for unique kinematic and dynamic constraints that differ significantly from wheeled platforms.

The global planner generates an optimal or near-optimal path from the robot's current position to the goal, considering static obstacles and overall environment topology. The local planner then executes this path while avoiding dynamic obstacles and ensuring kinematic feasibility for the humanoid platform.

## Global Planning Concepts

### Path Planning Fundamentals

Global path planning involves finding a collision-free path from a start position to a goal position in a known environment. For humanoid robots, this process must consider:

- **Kinematic constraints**: The robot's physical limitations for movement
- **Dynamic stability**: Maintaining balance throughout the planned path
- **Traversability**: Ensuring the path is suitable for bipedal locomotion
- **Energy efficiency**: Optimizing for power consumption during locomotion

### Common Global Planning Algorithms

#### A* Algorithm
A* is a popular graph-based search algorithm that uses heuristics to find optimal paths efficiently. Key characteristics include:

- **Completeness**: Guaranteed to find a solution if one exists
- **Optimality**: Finds the shortest path based on the cost function
- **Efficiency**: Uses heuristics to reduce search space
- **Adaptability**: Can incorporate custom cost functions for humanoid navigation

For humanoid robots, A* can be adapted by:
- Modifying the heuristic function to account for balance constraints
- Adjusting edge costs based on terrain traversability
- Incorporating energy consumption models

#### Dijkstra's Algorithm
Dijkstra's algorithm guarantees finding the shortest path in a weighted graph. While more computationally intensive than A*, it offers:

- **Guaranteed optimality**: Always finds the true shortest path
- **Flexibility**: Can handle complex cost functions
- **Robustness**: Works well with multi-objective optimization

For humanoid navigation, Dijkstra's algorithm can be enhanced with:
- **Multi-objective costs**: Balancing path length, stability, and energy
- **Dynamic cost updates**: Adjusting based on real-time sensor data
- **Preprocessing**: Using hierarchical maps for efficiency

#### Theta* Algorithm
Theta* is an any-angle path planning algorithm that allows for more natural paths by permitting direct line-of-sight connections between nodes:

- **Any-angle paths**: Produces smoother, more natural paths
- **Reduced path length**: Often finds shorter paths than grid-based methods
- **Real-time performance**: Efficient for dynamic environments

For humanoid robots, Theta* provides benefits in:
- **Natural movement patterns**: More human-like path following
- **Reduced turning**: Fewer direction changes that require balance adjustments
- **Energy efficiency**: More direct paths reduce energy consumption

### Global Planner Implementation in Nav2

#### NavFn Planner
The NavFn planner in Nav2 implements a Dijkstra-like algorithm with support for:

- **Gradient descent**: For smooth path following
- **Costmap integration**: Using Nav2's costmap framework
- **Real-time updates**: Adapting to dynamic environments

```cpp
// Example of customizing NavFn for humanoid constraints
class HumanoidNavFnPlanner : public nav2_navfn_planner::NavfnPlanner
{
public:
  HumanoidNavFnPlanner() = default;
  ~HumanoidNavFnPlanner() = default;

  // Override the planning function to incorporate humanoid constraints
  bool makePlan(const geometry_msgs::msg::PoseStamped & start,
                const geometry_msgs::msg::PoseStamped & goal,
                double tolerance,
                std::vector<geometry_msgs::msg::PoseStamped> & plan) override
  {
    // Apply humanoid-specific constraints before planning
    if (!validateTraversability(start, goal)) {
      RCLCPP_ERROR(get_logger(), "Goal not traversable for humanoid robot");
      return false;
    }

    // Call parent implementation
    bool success = nav2_navfn_planner::NavfnPlanner::makePlan(start, goal, tolerance, plan);

    if (success) {
      // Post-process the plan to ensure balance constraints
      applyBalanceConstraints(plan);
    }

    return success;
  }

private:
  bool validateTraversability(const geometry_msgs::msg::PoseStamped & start,
                            const geometry_msgs::msg::PoseStamped & goal)
  {
    // Check if the path is suitable for bipedal locomotion
    // Implementation details for traversability checking
    return true; // Simplified for example
  }

  void applyBalanceConstraints(std::vector<geometry_msgs::msg::PoseStamped> & plan)
  {
    // Modify the plan to ensure balance during execution
    // This might involve smoothing, adding intermediate waypoints, etc.
  }
};
```

#### GlobalPlanner Plugin
The GlobalPlanner plugin implements A* with additional features:

- **Costmap integration**: Full compatibility with Nav2's costmap system
- **Custom potential functions**: For specialized navigation requirements
- **Multi-resolution planning**: Hierarchical planning for efficiency

### Humanoid-Specific Global Planning Considerations

#### Traversability Analysis
Humanoid robots require specialized traversability analysis that considers:

- **Slope constraints**: Maximum allowable incline/decline angles
- **Step height limitations**: Maximum step-up and step-down heights
- **Surface stability**: Roughness, slipperiness, and support quality
- **Obstacle clearance**: Ensuring sufficient space for leg swing motion

```yaml
# Example traversability layer configuration
traversability_layer:
  plugin: "nav2_costmap_2d::TraversabilityLayer"
  max_slope: 15.0          # Maximum traversable slope in degrees
  max_step_height: 0.15    # Maximum step-up height in meters
  min_step_height: -0.10   # Maximum step-down height in meters
  min_traversable_width: 0.6  # Minimum path width for humanoid
  ground_plane_threshold: 0.05  # Ground plane detection threshold
```

#### Balance-Aware Path Planning
Global paths for humanoid robots must consider:

- **Zero Moment Point (ZMP) constraints**: Ensuring dynamic stability
- **Center of Mass (CoM) limits**: Maintaining balance during path following
- **Foot placement optimization**: Planning paths that allow for stable foot placement
- **Turning radius**: Accounting for balance constraints during turns

#### Multi-Modal Path Planning
Humanoid navigation often requires considering multiple modes of movement:

- **Walking modes**: Different gaits for various situations
- **Standing turns**: In-place rotation vs. turning while moving
- **Step adjustments**: Ability to modify step patterns based on terrain
- **Recovery actions**: Planning for balance recovery when needed

## Local Planning Concepts

### Local Planning Fundamentals

Local planning focuses on generating safe, executable trajectories in real-time while following the global plan. For humanoid robots, local planning must address:

- **Dynamic obstacle avoidance**: Reacting to moving obstacles in real-time
- **Kinematic feasibility**: Ensuring trajectories are executable by the humanoid
- **Balance maintenance**: Keeping the robot stable during navigation
- **Sensor integration**: Using real-time sensor data for navigation decisions

### Local Planning Algorithms

#### Dynamic Window Approach (DWA)
DWA is a local planning algorithm that considers robot dynamics and constraints:

- **Dynamic feasibility**: Ensures velocities are achievable given acceleration limits
- **Real-time performance**: Efficient computation for real-time applications
- **Obstacle avoidance**: Considers sensor data for collision avoidance
- **Stability**: Incorporates balance constraints for humanoid robots

For humanoid robots, DWA can be enhanced with:
- **Balance constraints**: Limiting velocities based on stability requirements
- **Step planning integration**: Coordinating with footstep planning systems
- **Multi-contact dynamics**: Considering complex humanoid kinematics

#### Timed Elastic Band (TEB) Planner
TEB represents the trajectory as an elastic band optimized over time:

- **Smooth trajectories**: Produces smooth, dynamically feasible paths
- **Obstacle avoidance**: Efficiently handles static and dynamic obstacles
- **Kinematic constraints**: Incorporates robot-specific constraints
- **Time optimization**: Optimizes both path and timing

For humanoid navigation, TEB provides advantages in:
- **Smooth transitions**: Reducing balance disturbances during navigation
- **Multi-objective optimization**: Balancing path length, smoothness, and safety
- **Real-time adaptation**: Efficiently updating trajectories based on sensor data

#### Model Predictive Control (MPC)
MPC uses predictive models to optimize navigation over a finite horizon:

- **Predictive capability**: Considers future states and constraints
- **Optimization-based**: Solves optimization problems in real-time
- **Constraint handling**: Explicitly handles complex constraints
- **Robustness**: Handles model uncertainties and disturbances

### Local Planner Implementation in Nav2

#### DWB Controller
The Dynamic Window Approach controller in Nav2 (DWB) provides:

- **Modular architecture**: Easy to customize and extend
- **Plugin-based design**: Supports multiple trajectory generators
- **Cost function evaluation**: Flexible scoring of trajectories
- **Real-time performance**: Optimized for real-time applications

```cpp
// Example of DWB controller configuration for humanoid navigation
class HumanoidDWBController : public dwb_core::DWBLocalPlanner
{
public:
  HumanoidDWBController() = default;
  ~HumanoidDWBController() = default;

  // Override trajectory generation to consider humanoid constraints
  std::vector<dwb_msgs::msg::TrajectoryScore>
  scoreTrajectories(const geometry_msgs::msg::Pose2D & pose,
                   const geometry_msgs::msg::Twist & velocity,
                   const std::vector<std::string> & velocity_iters) override
  {
    // Apply humanoid-specific constraints to trajectory generation
    auto trajectories = dwb_core::DWBLocalPlanner::scoreTrajectories(pose, velocity, velocity_iters);

    // Filter trajectories based on balance constraints
    filterBalanceConstrainedTrajectories(trajectories, pose);

    return trajectories;
  }

private:
  void filterBalanceConstrainedTrajectories(
    std::vector<dwb_msgs::msg::TrajectoryScore> & trajectories,
    const geometry_msgs::msg::Pose2D & pose)
  {
    // Implementation to filter trajectories based on humanoid balance constraints
    // Remove trajectories that would compromise robot stability
  }
};
```

#### TEB Controller
The TEB controller in Nav2 provides advanced trajectory optimization:

- **Elastic band optimization**: Optimizes trajectory shape and timing
- **Multi-objective optimization**: Balances competing objectives
- **Dynamic obstacle handling**: Predicts and avoids moving obstacles
- **Kinematic constraint integration**: Incorporates robot-specific constraints

### Humanoid-Specific Local Planning Considerations

#### Balance-Aware Trajectory Generation
Local planners for humanoid robots must consider:

- **Stability margins**: Maintaining safety margins for dynamic stability
- **ZMP tracking**: Ensuring trajectories maintain ZMP within support polygon
- **CoM control**: Managing center of mass position and velocity
- **Angular momentum**: Controlling body orientation and rotation

#### Step Planning Integration
For true bipedal robots, local planning must integrate with:

- **Footstep planning**: Coordinating navigation with foot placement
- **Gait pattern generation**: Creating stable walking patterns
- **Step timing**: Synchronizing steps with navigation commands
- **Balance transitions**: Managing balance during step transitions

#### Multi-Contact Navigation
Humanoid local planning may need to consider:

- **Hand support**: Using arms for balance in challenging situations
- **Multi-contact planning**: Planning trajectories that maintain multiple contacts
- **Recovery strategies**: Planning for balance recovery when needed
- **Adaptive gait**: Changing walking patterns based on terrain

## Planning for Complex Humanoid Navigation Scenarios

### Narrow Space Navigation
Navigating through narrow spaces requires specialized planning:

- **Foot placement optimization**: Careful positioning for stability
- **Body orientation**: Managing robot orientation in constrained spaces
- **Step sequence planning**: Planning the sequence of steps carefully
- **Balance recovery**: Planning for potential balance disturbances

### Stair Navigation
Stair navigation introduces additional complexity:

- **Step height planning**: Ensuring each step is within robot capabilities
- **Balance control**: Managing balance during step transitions
- **Foot placement**: Precise foot placement on each step
- **Gait adaptation**: Adjusting walking pattern for stairs

### Dynamic Obstacle Navigation
Moving in environments with dynamic obstacles:

- **Predictive planning**: Anticipating obstacle movements
- **Social navigation**: Following social conventions for humanoid robots
- **Multi-agent coordination**: Avoiding collisions with other agents
- **Uncertainty handling**: Managing uncertainty in obstacle behavior

## Performance Optimization

### Computational Efficiency
Planning algorithms for humanoid robots must be computationally efficient:

- **Hierarchical planning**: Using multiple resolution maps
- **Incremental updates**: Updating plans efficiently
- **Parallel processing**: Utilizing multi-core systems
- **Approximation algorithms**: Using efficient approximations when possible

### Memory Management
Efficient memory usage is crucial for embedded humanoid systems:

- **Map representation**: Efficient representation of environment data
- **Trajectory storage**: Managing multiple trajectory candidates
- **Cache optimization**: Optimizing data access patterns
- **Real-time allocation**: Minimizing dynamic memory allocation

## Integration with Perception Systems

### Sensor Data Integration
Planning systems must integrate with perception systems:

- **LiDAR data**: Using range data for obstacle detection
- **Vision systems**: Incorporating visual information for navigation
- **IMU data**: Using orientation and acceleration information
- **Force/torque sensors**: Using contact information for navigation

### Real-Time Adaptation
Planning systems must adapt to real-time sensor data:

- **Dynamic map updates**: Updating costmaps with new sensor data
- **Trajectory replanning**: Replanning when new obstacles are detected
- **Uncertainty handling**: Managing uncertainty in sensor data
- **Fusion algorithms**: Combining multiple sensor sources effectively

## Configuration and Tuning

### Parameter Optimization
Key parameters for humanoid navigation planning:

```yaml
# Global planner parameters for humanoid navigation
global_planner:
  ros__parameters:
    use_sim_time: false
    global_frame: map
    robot_base_frame: base_link
    # Humanoid-specific parameters
    max_planning_attempts: 5
    allow_unknown: false
    planner_frequency: 1.0
    # Balance constraints
    max_inclination: 15.0  # Maximum slope in degrees
    min_traversable_width: 0.6  # Minimum width for humanoid passage
    # Energy optimization
    prefer_energy_efficient_paths: true
    energy_cost_factor: 1.5

# Local planner parameters for humanoid navigation
local_planner:
  ros__parameters:
    controller_frequency: 20.0
    # Humanoid-specific velocity limits
    max_vel_x: 0.4      # Reduced for stability
    min_vel_x: 0.1
    max_vel_theta: 0.8  # Limited for balance
    # Acceleration limits for stability
    acc_lim_x: 1.0      # Lower acceleration for balance
    acc_lim_theta: 1.5
    # Balance-related parameters
    balance_margin: 0.15  # Safety margin for balance
    max_tilt_rate: 0.5    # Maximum rate of tilt change
    # Trajectory generation parameters
    vx_samples: 15        # Fewer samples for computational efficiency
    vtheta_samples: 25
    sim_time: 2.0         # Longer simulation time for stability
    # Goal tolerance for humanoid
    xy_goal_tolerance: 0.3  # Larger tolerance for humanoid positioning
    yaw_goal_tolerance: 0.3
```

### Performance Monitoring
Monitoring planning performance:

- **Planning time**: Measuring computation time for planning algorithms
- **Path quality**: Evaluating path length, smoothness, and safety
- **Success rate**: Tracking navigation success rates
- **Balance metrics**: Monitoring balance-related performance

## Safety Considerations

### Collision Avoidance
Planning systems must ensure collision-free navigation:

- **Static obstacles**: Avoiding known obstacles in the environment
- **Dynamic obstacles**: Reacting to moving obstacles
- **Self-collision**: Preventing robot self-collision
- **Environmental constraints**: Respecting environmental boundaries

### Stability Assurance
Maintaining robot stability during navigation:

- **Balance monitoring**: Continuously monitoring balance state
- **Emergency stopping**: Implementing emergency stops when unstable
- **Recovery planning**: Planning for balance recovery when needed
- **Stability margins**: Maintaining safety margins for stability

## Learning Objectives

After studying this section, students should be able to:

1. Implement and configure global and local planners for humanoid navigation
2. Adapt planning algorithms to incorporate humanoid kinematic and dynamic constraints
3. Integrate planning systems with perception and control systems
4. Optimize planning performance for real-time humanoid navigation
5. Evaluate and tune planning parameters for specific humanoid platforms

## References

1. Fox, D., Burgard, W., & Thrun, S. (1997). The dynamic window approach to collision avoidance. IEEE Robotics & Automation Magazine, 4(1), 23-33.
2. Rösmann, C., Feiten, W., Wösch, T., & Kirchner, F. (2012). Trajectory modification considering dynamic constraints of autonomous robots. Proceedings of the 7th German Conference on Robotics.
3. Khatib, O. (1986). Real-time obstacle avoidance for manipulators and mobile robots. The International Journal of Robotics Research, 5(1), 90-98.
4. ROS 2 Navigation Working Group. (2023). Nav2 Planning Configuration Guide. Retrieved from https://navigation.ros.org/configuration/index.html
5. Sisbot, E. A., & Marques, L. (2015). A new approach for human-aware robot navigation. IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS).

---

This document was generated as part of the AI-Native Textbook on Physical AI & Humanoid Robotics. For more information, visit the project repository.