---
title: Costmap Configuration for Humanoid Navigation
description: Comprehensive guide to configuring costmaps for humanoid robot navigation with specialized layers and parameters
sidebar_position: 4
---

# 3.4 Costmap Configuration for Humanoid Navigation

## Overview

Costmaps are fundamental to the Nav2 navigation system, providing a grid-based representation of the environment that incorporates obstacles, inflation zones, and other navigational constraints. For humanoid robots, costmap configuration requires special considerations due to the unique challenges of bipedal locomotion, dynamic stability requirements, and complex kinematic constraints.

Traditional costmaps for wheeled robots primarily focus on planar obstacle avoidance. However, humanoid robots require enhanced costmap capabilities that account for:

- **Traversability analysis**: Determining which areas are suitable for bipedal locomotion
- **Stability zones**: Identifying regions that support dynamic stability
- **Step planning requirements**: Precomputing viable foot placement locations
- **Multi-level terrain assessment**: Handling environments with varying elevations

## Costmap Fundamentals

### Costmap Representation

A costmap in Nav2 represents the environment as a 2D grid where each cell contains a cost value indicating the desirability of that location for navigation. The cost values typically follow this convention:

- **0 (FREE_SPACE)**: Completely free space
- **1-252**: Increasing cost values based on proximity to obstacles or other constraints
- **253 (LETHAL_OBSTACLE)**: Areas that should be avoided completely
- **254 (INSCRIBED_INFLATED_OBSTACLE)**: Areas that would cause the robot to hit an obstacle
- **255 (NO_INFORMATION)**: Areas with no sensor information

### Costmap Layers

The Nav2 costmap system uses a layered architecture where multiple layers contribute to the final costmap. Each layer processes specific types of information and contributes to the overall costmap through a combination strategy.

## Standard Costmap Layers

### Static Layer

The static layer incorporates map information from a known static map, typically provided by a map server. This layer is essential for navigation in known environments.

```yaml
static_layer:
  plugin: "nav2_costmap_2d::StaticLayer"
  enabled: true
  map_topic: map
  transform_tolerance: 0.3
  map_subscribe_transient_local: true
  track_unknown_space: true
  use_maximum: false
  unknown_cost_value: -1
  trinary_costmap: true
  lethal_cost_threshold: 100
```

For humanoid robots, the static layer may include additional information:

- **Traversability maps**: Precomputed traversability information
- **Stability zones**: Areas marked for stability characteristics
- **Terrain classification**: Different terrain types with varying costs

### Obstacle Layer

The obstacle layer processes sensor data to detect and mark obstacles in the environment. It handles both static and dynamic obstacles based on sensor observations.

```yaml
obstacle_layer:
  plugin: "nav2_costmap_2d::ObstacleLayer"
  enabled: true
  observation_sources: scan
  scan:
    topic: /scan
    max_obstacle_height: 2.0
    clearing: true
    marking: true
    data_type: "LaserScan"
    raytrace_max_range: 3.0
    raytrace_min_range: 0.0
    obstacle_max_range: 2.5
    obstacle_min_range: 0.0
    obstacle_max_range_buffer: 0.0
    obstacle_min_range_buffer: 0.0
    inf_is_valid: false
    clearing_threshold: 0.02
    marking_threshold: 0.95
```

For humanoid robots, the obstacle layer configuration may include:

- **Height-based filtering**: Allowing the robot to step over small obstacles
- **Dynamic obstacle prediction**: Predicting movement of dynamic obstacles
- **Sensor fusion**: Combining multiple sensor sources

### Voxel Layer

The voxel layer extends obstacle detection to 3D space, creating a 3D grid of obstacles. This is particularly important for humanoid robots that must navigate in 3D environments.

```yaml
voxel_layer:
  plugin: "nav2_costmap_2d::VoxelLayer"
  enabled: true
  publish_voxel_map: true
  origin_z: 0.0
  z_resolution: 0.2
  z_voxels: 8
  max_obstacle_height: 2.0
  mark_threshold: 0
  observation_sources: pointcloud
  pointcloud:
    topic: /pointcloud
    max_obstacle_height: 2.0
    clearing: true
    marking: true
    data_type: "PointCloud2"
    min_obstacle_height: 0.0
    obstacle_max_range: 3.0
    obstacle_min_range: 0.0
    raytrace_max_range: 4.0
    raytrace_min_range: 0.0
    min_z: 0.0
    max_z: 2.0
    vertical_fov_angle: 1.047  # 60 degrees
    observation_persistence: 0.0
    expected_update_rate: 0.0
    data_transform_timeout: 0.3
    inf_is_valid: false
    clearing_threshold: 0.1
    marking_threshold: 0.9
    voxel_filter: true
    max_obstacle_range: 3.0
    min_obstacle_range: 0.0
```

### Inflation Layer

The inflation layer creates safety margins around obstacles by increasing the cost of areas near obstacles. This is crucial for ensuring safe navigation.

```yaml
inflation_layer:
  plugin: "nav2_costmap_2d::InflationLayer"
  enabled: true
  cost_scaling_factor: 3.0
  inflation_radius: 0.55
  inflate_to_robot_radius: false
  inflate_unknown: false
  robot_radius: 0.3  # Should match robot's radius
```

For humanoid robots, inflation parameters may be adjusted based on:

- **Step size**: Ensuring sufficient space for foot placement
- **Balance requirements**: Creating larger safety margins for stability
- **Gait patterns**: Accounting for different walking patterns

## Humanoid-Specific Costmap Layers

### Traversability Layer

The traversability layer is crucial for humanoid navigation, indicating which areas are suitable for bipedal locomotion. This layer considers factors such as:

- **Surface slope**: Maximum allowable incline/decline
- **Step height constraints**: Maximum step-up and step-down heights
- **Surface roughness**: Stability of the walking surface
- **Ground clearance**: Ensuring adequate clearance for leg swing

```cpp
// Example implementation of a traversability layer
class TraversabilityLayer : public nav2_costmap_2d::Layer
{
public:
  TraversabilityLayer() = default;
  ~TraversabilityLayer() = default;

  void onInitialize() override
  {
    ros::NodeHandle nh("~/" + name_);
    current_ = true;

    // Load humanoid-specific parameters
    nh.param("max_slope", max_slope_, 15.0);
    nh.param("max_step_up", max_step_up_, 0.15);
    nh.param("max_step_down", max_step_down_, -0.10);
    nh.param("min_traversable_width", min_traversable_width_, 0.6);

    // Initialize other parameters
    matchSize();
  }

  void updateBounds(
    double robot_x, double robot_y, double robot_yaw,
    double* min_x, double* min_y, double* max_x, double* max_y) override
  {
    // Update bounds based on traversability information
    updateWithOverwrite(*min_x, *min_y, *max_x, *max_y);
  }

  void updateCosts(
    nav2_costmap_2d::Costmap2D& master_grid,
    int min_i, int min_j, int max_i, int max_j) override
  {
    if (!enabled_) return;

    // Apply traversability costs to the master grid
    for (int j = min_j; j < max_j; j++) {
      for (int i = min_i; i < max_i; i++) {
        int index = getIndex(i, j);
        unsigned char old_cost = master_grid.getCost(i, j);

        if (old_cost == nav2_costmap_2d::NO_INFORMATION) continue;

        // Calculate traversability cost based on terrain analysis
        unsigned char traversability_cost = calculateTraversabilityCost(i, j);

        // Combine with existing cost
        unsigned char new_cost = combineTraversabilityCost(old_cost, traversability_cost);
        master_grid.setCost(i, j, new_cost);
      }
    }
  }

private:
  double max_slope_;
  double max_step_up_;
  double max_step_down_;
  double min_traversable_width_;

  unsigned char calculateTraversabilityCost(int i, int j)
  {
    // Implementation for calculating traversability cost
    // This would analyze the terrain at the given cell
    // and return a cost based on humanoid constraints

    // Simplified example:
    if (isTooSloped(i, j)) {
      return nav2_costmap_2d::LETHAL_OBSTACLE;
    }
    if (isUntraversable(i, j)) {
      return nav2_costmap_2d::LETHAL_OBSTACLE;
    }

    // Return cost based on difficulty of traversal
    return nav2_costmap_2d::FREE_SPACE;
  }

  bool isTooSloped(int i, int j)
  {
    // Check if the slope at this location exceeds humanoid limits
    return false; // Simplified implementation
  }

  bool isUntraversable(int i, int j)
  {
    // Check if this location is untraversable for humanoid
    return false; // Simplified implementation
  }

  unsigned char combineTraversabilityCost(unsigned char base_cost, unsigned char traversability_cost)
  {
    // Combine base cost with traversability cost
    // This might involve max operation or weighted combination
    return std::max(base_cost, traversability_cost);
  }
};
```

### Stability Layer

The stability layer marks areas where the humanoid robot can maintain dynamic stability. This layer considers:

- **Support polygon**: Areas where feet can be placed to maintain balance
- **Center of Mass constraints**: Regions where CoM can be safely positioned
- **Ground contact quality**: Stability of potential foot placement locations

```yaml
stability_layer:
  plugin: "humanoid_layers::StabilityLayer"
  enabled: true
  max_tilt_angle: 15.0  # Maximum acceptable tilt for stability
  min_support_area: 0.05  # Minimum area for stable foot contact
  stability_buffer: 0.1   # Safety buffer around stable areas
  ground_quality_threshold: 0.7  # Minimum ground quality for stability
```

### Step Planning Layer

The step planning layer precomputes viable foot placement locations, which is essential for bipedal robots. This layer considers:

- **Step reachability**: Whether a foot can reach a given location
- **Step stability**: Whether a step to that location would maintain balance
- **Step sequence feasibility**: Whether the step fits into a viable sequence

```yaml
step_planning_layer:
  plugin: "humanoid_layers::StepPlanningLayer"
  enabled: true
  max_step_length: 0.3    # Maximum step length for the humanoid
  max_step_width: 0.2     # Maximum step width
  min_step_width: 0.1     # Minimum step width for stability
  step_clearance: 0.1     # Required clearance for step placement
  support_polygon_margin: 0.05  # Margin for support polygon
```

## Costmap Configuration for Humanoid Navigation

### Global Costmap Configuration

The global costmap provides a comprehensive view of the environment for path planning:

```yaml
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: false
      rolling_window: false
      track_unknown_space: true

      # Robot parameters
      robot_radius: 0.3  # Approximate radius for humanoid torso
      resolution: 0.05   # Grid resolution in meters

      # Layer configuration
      plugins: [
        "static_layer",
        "traversability_layer",
        "obstacle_layer",
        "inflation_layer",
        "stability_layer"
      ]

      # Static layer configuration
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: true
        transform_tolerance: 0.3
        map_topic: map

      # Traversability layer for humanoid
      traversability_layer:
        plugin: "humanoid_layers::TraversabilityLayer"
        max_slope: 15.0
        max_step_up: 0.15
        max_step_down: -0.10
        min_traversable_width: 0.6
        traversability_topic: /terrain_analysis/traversability_map

      # Obstacle layer configuration
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0

      # Inflation layer for safety margins
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55
        inflate_to_robot_radius: false

      # Stability layer for humanoid navigation
      stability_layer:
        plugin: "humanoid_layers::StabilityLayer"
        max_tilt_angle: 15.0
        min_support_area: 0.05
        stability_buffer: 0.1
        ground_quality_threshold: 0.7
  always_send_full_costmap: true
```

### Local Costmap Configuration

The local costmap focuses on the immediate vicinity of the robot for local planning:

```yaml
local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: odom
      robot_base_frame: base_link
      use_sim_time: false
      rolling_window: true
      width: 6.0    # Width of the local costmap in meters
      height: 6.0   # Height of the local costmap in meters
      resolution: 0.05  # Grid resolution in meters

      # Robot parameters
      robot_radius: 0.3  # Approximate radius for humanoid torso

      # Layer configuration
      plugins: [
        "obstacle_layer",
        "voxel_layer",
        "inflation_layer",
        "stability_layer",
        "step_planning_layer"
      ]

      # Obstacle layer for immediate obstacle detection
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
          obstacle_max_range_buffer: 0.1
          obstacle_min_range_buffer: 0.05

      # Voxel layer for 3D obstacle detection
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: true
        publish_voxel_map: true
        origin_z: 0.0
        z_resolution: 0.2
        z_voxels: 8
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: pointcloud
        pointcloud:
          topic: /pointcloud
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "PointCloud2"
          min_obstacle_height: 0.0
          obstacle_max_range: 3.0
          obstacle_min_range: 0.0
          raytrace_max_range: 4.0
          raytrace_min_range: 0.0
          min_z: 0.0
          max_z: 2.0

      # Inflation layer for safety margins
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.3  # Smaller radius for local planning
        inflate_to_robot_radius: false

      # Stability layer for humanoid balance
      stability_layer:
        plugin: "humanoid_layers::StabilityLayer"
        max_tilt_angle: 10.0  # Stricter stability in local planning
        min_support_area: 0.05
        stability_buffer: 0.05  # Smaller buffer for local planning
        ground_quality_threshold: 0.8  # Higher threshold for safety

      # Step planning layer for bipedal navigation
      step_planning_layer:
        plugin: "humanoid_layers::StepPlanningLayer"
        max_step_length: 0.3
        max_step_width: 0.2
        min_step_width: 0.1
        step_clearance: 0.1
        support_polygon_margin: 0.05
        planning_horizon: 1.0  # Time horizon for step planning
  always_send_full_costmap: false
```

## Advanced Costmap Features for Humanoid Navigation

### Multi-Resolution Costmaps

For computational efficiency, humanoid robots may use multi-resolution costmaps:

```yaml
# High-resolution local costmap for immediate navigation
high_res_local_costmap:
  local_costmap:
    ros__parameters:
      resolution: 0.025  # Higher resolution (2.5cm)
      width: 4.0
      height: 4.0
      # ... other parameters

# Lower-resolution global costmap for long-term planning
low_res_global_costmap:
  global_costmap:
    ros__parameters:
      resolution: 0.1  # Lower resolution (10cm)
      # ... other parameters
```

### Dynamic Costmap Updates

Humanoid navigation may require dynamic updates based on robot state:

```cpp
// Example of dynamic costmap update based on robot state
class DynamicHumanoidCostmap : public nav2_costmap_2d::Costmap2DROS
{
public:
  void updateRobotState(const humanoid_msgs::msg::RobotState & state)
  {
    // Update costmap parameters based on current robot state
    updateBalanceConstraints(state.balance_state);
    updateGaitParameters(state.current_gait);
    updateTerrainAdaptation(state.terrain_type);
  }

private:
  void updateBalanceConstraints(const BalanceState & balance_state)
  {
    // Adjust costmap parameters based on current balance state
    if (balance_state == UNSTABLE) {
      increaseStabilityLayerInflation();
    }
  }

  void updateGaitParameters(const GaitType & gait_type)
  {
    // Adjust costmap based on current gait
    switch(gait_type) {
      case WALKING:
        setDefaultStepConstraints();
        break;
      case CLIMBING:
        adjustForStepUpConstraints();
        break;
      case CAREFUL_WALK:
        increaseSafetyMargins();
        break;
    }
  }

  void updateTerrainAdaptation(const TerrainType & terrain_type)
  {
    // Adjust costmap based on terrain type
    switch(terrain_type) {
      case NORMAL:
        setNormalTerrainParameters();
        break;
      case UNEVEN:
        increaseTraversabilityCosts();
        break;
      case SLIPPERY:
        increaseStabilityConstraints();
        break;
    }
  }
};
```

### Sensor Fusion in Costmaps

Combining multiple sensor sources for enhanced costmap accuracy:

```yaml
sensor_fusion_layer:
  plugin: "humanoid_layers::SensorFusionLayer"
  enabled: true

  # Sensor configuration
  sensors:
    lidar:
      topic: /scan
      weight: 0.7
      max_range: 5.0
      min_range: 0.1
    stereo_camera:
      topic: /stereo/depth
      weight: 0.5
      max_range: 3.0
      min_range: 0.2
    imu:
      topic: /imu
      weight: 0.3
      update_rate: 100.0
    force_torque:
      topic: /ft_sensors
      weight: 0.4
      update_rate: 100.0

  # Fusion parameters
  fusion_method: "weighted_average"
  confidence_threshold: 0.6
  temporal_filtering: true
  temporal_window_size: 5
```

## Performance Optimization

### Memory Management

Efficient memory usage for costmaps on humanoid platforms:

```cpp
// Memory-efficient costmap implementation
class EfficientHumanoidCostmap
{
public:
  EfficientHumanoidCostmap(int width, int height, double resolution)
    : width_(width), height_(height), resolution_(resolution)
  {
    // Use compressed data structures for cost storage
    cost_data_ = std::make_unique<std::vector<uint8_t>>(width * height);

    // Initialize with default values
    std::fill(cost_data_->begin(), cost_data_->end(),
              nav2_costmap_2d::FREE_SPACE);
  }

  // Use bit manipulation for efficient operations
  inline void setCost(int index, unsigned char cost) {
    (*cost_data_)[index] = cost;
  }

  inline unsigned char getCost(int index) const {
    return (*cost_data_)[index];
  }

private:
  int width_, height_;
  double resolution_;
  std::unique_ptr<std::vector<uint8_t>> cost_data_;
};
```

### Update Optimization

Optimizing costmap updates for real-time performance:

```cpp
// Incremental update approach
class IncrementalCostmapUpdater
{
public:
  void updateIncrementally(const SensorData & sensor_data)
  {
    // Only update regions affected by new sensor data
    auto affected_regions = calculateAffectedRegions(sensor_data);

    for (const auto & region : affected_regions) {
      updateRegion(region, sensor_data);
    }

    // Update only necessary layers
    updateCriticalLayers(affected_regions);
  }

private:
  std::vector<Region> calculateAffectedRegions(const SensorData & data)
  {
    // Calculate only the regions that need updating
    // based on sensor data and robot movement
    return {};
  }

  void updateRegion(const Region & region, const SensorData & data)
  {
    // Update specific region with new sensor data
  }

  void updateCriticalLayers(const std::vector<Region> & regions)
  {
    // Update only critical layers that affect navigation safety
  }
};
```

## Safety and Reliability

### Costmap Validation

Ensuring costmap accuracy and reliability:

```cpp
class CostmapValidator
{
public:
  bool validateCostmap(const nav2_costmap_2d::Costmap2D & costmap)
  {
    // Check for consistency in costmap data
    if (!checkCostmapIntegrity(costmap)) {
      return false;
    }

    // Validate that safety constraints are properly enforced
    if (!validateSafetyMargins(costmap)) {
      return false;
    }

    // Ensure humanoid-specific constraints are met
    if (!validateHumanoidConstraints(costmap)) {
      return false;
    }

    return true;
  }

private:
  bool checkCostmapIntegrity(const nav2_costmap_2d::Costmap2D & costmap)
  {
    // Verify that costmap data is consistent and valid
    return true;
  }

  bool validateSafetyMargins(const nav2_costmap_2d::Costmap2D & costmap)
  {
    // Ensure adequate safety margins around obstacles
    return true;
  }

  bool validateHumanoidConstraints(const nav2_costmap_2d::Costmap2D & costmap)
  {
    // Verify that humanoid-specific constraints are properly applied
    return true;
  }
};
```

### Emergency Handling

Costmap behavior during emergency situations:

```yaml
emergency_costmap:
  ros__parameters:
    # Parameters for emergency costmap updates
    emergency_inflation_radius: 1.0  # Larger safety margin during emergencies
    emergency_cost_scaling: 5.0      # Higher cost scaling factor
    emergency_update_frequency: 10.0 # Faster updates during emergencies
    emergency_layers: [
      "obstacle_layer",
      "inflation_layer",
      "stability_layer"
    ]
```

## Configuration Best Practices

### Parameter Tuning Guidelines

When configuring costmaps for humanoid navigation:

1. **Start with conservative parameters**: Begin with larger safety margins and adjust based on performance
2. **Consider robot dynamics**: Account for the robot's balance and stability characteristics
3. **Validate in simulation**: Test configurations in simulation before real-world deployment
4. **Monitor performance metrics**: Track navigation success rates and adjust accordingly

### Common Configuration Issues

**Issue**: Robot getting stuck near obstacles
**Solution**: Increase inflation radius and cost scaling factor

**Issue**: Navigation paths too far from obstacles
**Solution**: Decrease inflation radius for more efficient paths

**Issue**: Robot attempting to navigate through untraversable terrain
**Solution**: Ensure traversability layer is properly configured and weighted

**Issue**: High computational load
**Solution**: Use appropriate resolution and update frequency for the platform

## Integration with Navigation Stack

### Costmap-Planner Integration

The costmaps integrate with the planning components through:

```cpp
// Example of costmap-planner integration
class HumanoidPathPlanner
{
public:
  HumanoidPathPlanner(std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap)
    : costmap_ros_(costmap), costmap_(costmap->getCostmap())
  {
  }

  bool planPath(const Pose & start, const Pose & goal, Path & path)
  {
    // Check traversability before planning
    if (!isTraversable(goal)) {
      return false;
    }

    // Plan path considering humanoid constraints
    path = planHumanoidPath(start, goal);

    // Validate path against costmap
    if (!validatePath(path)) {
      return false;
    }

    return true;
  }

private:
  bool isTraversable(const Pose & pose)
  {
    unsigned int mx, my;
    if (!costmap_->worldToMap(pose.x, pose.y, mx, my)) {
      return false;
    }

    unsigned char cost = costmap_->getCost(mx, my);
    return cost < nav2_costmap_2d::INSCRIBED_INFLATED_OBSTACLE;
  }

  Path planHumanoidPath(const Pose & start, const Pose & goal)
  {
    // Implementation of humanoid-specific path planning
    return Path();
  }

  bool validatePath(const Path & path)
  {
    // Validate path against costmap and humanoid constraints
    return true;
  }

  std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;
  nav2_costmap_2d::Costmap2D * costmap_;
};
```

## Learning Objectives

After studying this section, students should be able to:

1. Configure and customize costmaps for humanoid robot navigation
2. Implement humanoid-specific costmap layers for traversability and stability
3. Optimize costmap parameters for computational efficiency and navigation performance
4. Integrate costmaps with path planning and control systems
5. Validate and debug costmap configurations for safe humanoid navigation

## References

1. Lu, M. T., et al. (2019). Costmap-based navigation for humanoid robots. IEEE-RAS International Conference on Humanoid Robots (Humanoids).
2. Nav2 Costmap 2D Documentation. (2023). ROS 2 Navigation Documentation. https://navigation.ros.org/configuration/costmap_configuration/index.html
3. Fox, D., et al. (1996). Dynamic world modeling for mobile robots using 3D occupancy grids. Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS).
4. Koenig, S., & Likhachev, M. (2002). D*Lite: An incremental path planning algorithm for mobile robots. IEEE International Conference on Robotics and Automation (ICRA).
5. Humanoid Navigation Working Group. (2023). Humanoid Navigation Costmap Extensions. Retrieved from https://github.com/humanoid-navigation/costmap-extensions

---

This document was generated as part of the AI-Native Textbook on Physical AI & Humanoid Robotics. For more information, visit the project repository.